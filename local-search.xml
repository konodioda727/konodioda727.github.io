<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>垃圾校园网</title>
    <link href="/2024/07/21/network/"/>
    <url>/2024/07/21/network/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么校园网这么难用？☹️"><a href="#为什么校园网这么难用？☹️" class="headerlink" title="为什么校园网这么难用？☹️"></a>为什么校园网这么难用？☹️</h1><blockquote><p>自从学校决定升级校园网之后，这个破网就越发的难用，根据哥们的观察，主要体现在以下两点：</p><ul><li>部分网站无法访问</li><li>宿舍连的网，到教室要重新登录</li></ul><p>这篇主要讲讲第一点，想看后续可以蹲我博客💩</p></blockquote><h2 id="为什么某些网站无法访问？"><a href="#为什么某些网站无法访问？" class="headerlink" title="为什么某些网站无法访问？"></a>为什么某些网站无法访问？</h2><h3 id="1-故事背景😡"><a href="#1-故事背景😡" class="headerlink" title="1. 故事背景😡"></a>1. 故事背景😡</h3><p>本人和舍友都是cs孝子，最近发现我们一整个寝室，链接<code>完美世界竞技平台</code> 的时候，页面展示不全，还会弹出：网络错误 的提示。</p><p>因此每次都需要换到我手机热点再重新连，这令我十分恼火😒。</p><p>为此，我专门去研究了研究校园网这个玩意</p><h3 id="2-初露端倪🧐"><a href="#2-初露端倪🧐" class="headerlink" title="2. 初露端倪🧐"></a>2. 初露端倪🧐</h3><p>首先，我尝试去抓出来<code>完美世界</code>的域名和ip，不抓不知道，一抓吓一跳，这是我连校园网时解析出来的ip：![image-20240520145724577](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240520145724577.png)</p><p>这是我连手机热点时解析的IP：</p><p>![image-20240520154139524](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240520154139524.png)</p><p>连手机网时，ping它：</p><p>![image-20240520194812437](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240520194812437.png)</p><p>可以看到，相当成功</p><p>接着我试着连校园网去ping它。接着发现大事不妙🙂‍↔️</p><p>![image-20240520154049356](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240520154049356.png)</p><p>怎么是timeout？？？？问题可能出在<code>DNS</code>的解析上</p><blockquote><p>为什么说可能呢，因为解析结果不同有可能是因为<code>负载均衡</code>，会出来不同的ip</p></blockquote><p>还有个更幽默的，我去查询这俩ip的地址的时候，惊奇的发现：</p><p>⬇️这是连手机热点时解析的ip，在杭州对吧，很合理</p><p>![image-20240520154352360](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240520154352360.png)</p><p>⬇️但是连校园网解析的…</p><p>![image-20240520154604662](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240520154604662.png)</p><p>它竟然是个教育网，教育网，不知道是巧合还是故意的…😵‍💫</p><p>这下可以确定确实是<code>DNS</code>出问题了</p><h3 id="3-DNS劫持"><a href="#3-DNS劫持" class="headerlink" title="3. DNS劫持"></a>3. DNS劫持</h3><p>上述情况就是<code>DNS</code>劫持导致的。</p><p>所谓<code>DNS</code>劫持就是通过拦截<code>DNS</code>解析请求，找出特定范围的请求，返回错误的ip，导致访问错误，或者什么都不做，等待请求过期。</p><p>解决也很简单，去系统设置里，添加<code>DNS</code>服务地址即可，我这里添加<code>8.8.8.4</code>和<code>8.8.4.4</code>，为GoogleDNS地址，接下来就能正常访问啦！</p><p>![image-20240520155630716](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240520155630716.png)</p><p>![image-20240520155755660](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240520155755660.png)</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>完美世界怎么你了🤡</p><p>校园网你诗人握持🤡</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>浏览器原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热更新系列（一）：浏览器缓存</title>
    <link href="/2024/07/21/HMR-storage/"/>
    <url>/2024/07/21/HMR-storage/</url>
    
    <content type="html"><![CDATA[<h1 id="热更新系列（一）：浏览器缓存"><a href="#热更新系列（一）：浏览器缓存" class="headerlink" title="热更新系列（一）：浏览器缓存"></a>热更新系列（一）：浏览器缓存</h1><blockquote><p><strong>之前面试的时候被问到一个问题，还蛮有意思：服务器上代码变化的时候，如何通知浏览器端更新文件？</strong></p><p>你可能疑惑：</p><ul><li>浏览器进入页面的时候，发起请求，拿到最新的html文件，里面带上最新的js文件link不就好了吗</li><li>这个东西在开发的时候，不是改一点他就更新一点的吗？怎么部署上去就不行了呢？</li></ul><p>别急，让我们慢慢讲，本次主讲第一个问题</p></blockquote><h2 id="一、浏览器进入页面的时候，不是会get吗？那这个时候不就能进行页面的更新了吗？🧐"><a href="#一、浏览器进入页面的时候，不是会get吗？那这个时候不就能进行页面的更新了吗？🧐" class="headerlink" title="一、浏览器进入页面的时候，不是会get吗？那这个时候不就能进行页面的更新了吗？🧐"></a>一、浏览器进入页面的时候，不是会get吗？那这个时候不就能进行页面的更新了吗？🧐</h2><p>首先，这个思路很对，在浏览器<code>第一次</code>进入某个页面的时候，的确会向服务端发起一个<code>GET</code>请求，拿到html文件，但是注意我标红的地方：<em><strong>第一次</strong></em>。</p><p>没错，在某些情况下，浏览器并不会去向服务端发起请求，那是在什么时候呢？其实，为了浏览器的性能，浏览器会尽量减少网络请求的个数，其他的则采用<code>缓存</code>处理</p><p>那<code>缓存</code>又是什么呢？</p><h3 id="1-不同种类的缓存"><a href="#1-不同种类的缓存" class="headerlink" title="1. 不同种类的缓存"></a>1. 不同种类的缓存</h3><p>首先，最大的分类，可以分为两种不同类型：<strong>私有缓存</strong>和<strong>共享缓存</strong>。</p><ul><li><p><code>私有缓存</code>是绑定到特定客户端的缓存——通常是<code>浏览器缓存</code>。存储不与其他客户端共享，因此私有缓存可以存储该用户的个性化数据，浏览器缓存主要分为三大类：<code>Cookie</code> <code>SeesionStorage</code> <code>localStorage</code>，感兴趣的可以去了解一下</p></li><li><p><code>共享缓存</code>位于客户端和服务器之间，可以存储能在用户之间共享的响应。共享缓存可以进一步细分为<strong>代理缓存</strong>和<strong>托管缓存</strong>。</p><ul><li><code>代理缓存</code>: 简单来说就是存在代理服务器上的缓存，请求是如果满足要求，从代理服务器获取数据，不用向主服务器发起请求</li><li><code>托管缓存</code>: 个人理解与代理缓存区别主要在于代理缓存多由浏览器决定，而托管缓存则是程序员主导</li></ul></li></ul><h3 id="2-基于age的缓存策略"><a href="#2-基于age的缓存策略" class="headerlink" title="2. 基于age的缓存策略"></a>2. 基于<code>age</code>的缓存策略</h3><p>浏览器对于缓存的处理主要基于<code>age</code>，<code>age</code>可以理解为生命周期，如果<code>age</code>超出某个阈值该缓存就会被判定为<code>stale</code>，即腐烂，那浏览器是如何利用<code>age</code>的呢？如果是你，你会怎么设计呢？</p><h4 id="2-1-首先，总得有age吧"><a href="#2-1-首先，总得有age吧" class="headerlink" title="2.1 首先，总得有age吧"></a>2.1 首先，总得有<code>age</code>吧</h4><p>那<code>age</code>肯定得从后端传过来吧，那放在哪里呢？</p><p><code>http</code>的策略是在请求中专门开辟一个<code>Cache-Control</code>字段，用于缓存的管理</p><p>服务端可以在返回中带上</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=10086<br></code></pre></td></tr></table></figure><p>这样的字段，这个就声明了这个请求的最大生命周期是<code>10086</code>毫秒，那到现在是不是还觉得有些不靠谱，只有时间长度，那我从哪开始算呢？从我接受到请求开始吗？</p><p><strong>肯定不是！</strong></p><p>说到这点，就要谈谈<code>http</code>的历史了，<code>http</code>在初期1.0的时候，采用的缓存控制字段是<code>expires</code>，这是个啥呢？这是一个绝对时间，比如说：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Sun, 21 JUL 2024 18:00:00 GMT<br></code></pre></td></tr></table></figure><p>但是这样有什么坏处呢？</p><ul><li>一是每台机器的时钟可能不一样，因此可能会出现客户端根据<code>expires</code>判断并为过期而资源实际已经发生变化的情况。还有居心叵测之人调整系统时钟来诱发匪夷所思的问题</li><li>二是这么一长串，还带日期、字母，难以解析</li></ul><p>因此，在http&#x2F;1.1中，引入了<code>max-age</code>这个概念，现在让我们回到上一个问题：<strong>只有时间长度，那我从哪开始算呢？从我接受到请求开始吗？</strong></p><p>如果是按照系统的时钟计算，那不就又和之前的<code>expires</code>别无二致了嘛，不安全还不准确，网络波动大了可能会造成严重问题，为此，<code>max-age</code>的计算是根据后端返回中的<code>TimeStamp</code>字段也就是生成时间计算的。</p><p>当然，这只是为经过缓存，直接发送请求的结果，最后缓存也是缓存在浏览器缓存中，然而，别忘了，还有一种<code>共享缓存</code>呢！那如果加上共享缓存，会有不同吗？</p><hr><p><strong>答案是肯定的</strong></p><p>假设现在有一个请求从浏览器发出，它将首先访问缓存服务器，而代理服务器上的数据如果在有效期内，就会返回出去，不把请求转发给目的服务器，但是如果再极致一点，再把从代理服务器过来的缓存再在本地缓存一下呢？代理服务器也很忙，没事别去打扰他！其实浏览器也想到咯</p><p>那就是<code>Age</code>字段：他负责计算从生成开始，这个请求已经经过了多少时间，在别人请求该资源时，会把<code>max-age</code>和<code>age</code>一起带上：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Sun, 21 JUL 2024 18:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=600<br><span class="hljs-attribute">Age</span><span class="hljs-punctuation">: </span>400<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>这就代表着浏览器接受到这个请求的时候，只有<code>600 - 400 = 200</code>的有效时间咯，过200ms之后，浏览器会再次向代理服务器发送请求，而代理服务器会向目的服务器发送请求，然而再次发请求，就一定要去换新数据吗？</p><h3 id="3-验证响应"><a href="#3-验证响应" class="headerlink" title="3. 验证响应"></a>3. 验证响应</h3><blockquote><p>在这一部分之上的部分可以称为<code>强制缓存</code></p><p>而接下来的内容则属于<code>协商缓存</code></p></blockquote><p>过时的响应不会立即被丢弃。HTTP 有一种机制，可以通过询问源服务器将陈旧的响应转换为新的响应。这称为<strong>验证</strong>，有时也称为<strong>重新验证</strong>。</p><p>验证是通过使用包含 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> 请求标头的<strong>条件请求</strong>完成的。</p><h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching#if-modified-since">If-Modified-Since</a></h3><p>以下响应在 22:22:22 生成，<code>max-age</code> 为 1 小时，因此你知道它在 23:22:22 之前是有效的。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p>到 23:22:22 时，响应会过时并且不能重用缓存。因此，下面的请求显示客户端发送带有 <code>If-Modified-Since</code> 请求标头的请求，以询问服务器自指定时间以来是否有任何的改变。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br></code></pre></td></tr></table></figure><p>如果内容自指定时间以来没有更改，服务器将响应 <code>304 Not Modified</code>。</p><p>由于此响应仅表示“没有变化”，因此没有响应主体——只有一个状态码——因此传输大小非常小。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">304</span> Not Modified<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 23:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600<br></code></pre></td></tr></table></figure><p>收到该响应后，客户端将存储的过期响应恢复为有效的，并可以在剩余的 1 小时内重复使用它。</p><p>服务器可以从操作系统的文件系统中获取修改时间，这对于提供静态文件的情况来说是比较容易做到的。但是，也存在一些问题；例如，时间格式复杂且难以解析，分布式服务器难以同步文件更新时间。</p><p>为了解决这些问题，<code>ETag</code> 响应标头被标准化作为替代方案。</p><h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag&#x2F;If-None-Match"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching#etagif-none-match">ETag&#x2F;If-None-Match</a></h3><p><code>ETag</code> 响应标头的值是服务器生成的任意值。服务器对于生成值没有任何限制，因此服务器可以根据他们选择的任何方式自由设置值——例如主体内容的哈希或版本号。</p><p>举个例子，如果 <code>ETag</code> 标头使用了 hash 值，<code>index.html</code> 资源的 hash 值是 <code>deadbeef</code>，响应如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:22:22 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;deadbeef&quot;<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p>如果该响应是陈旧的，则客户端获取缓存响应的 <code>ETag</code> 响应标头的值，并将其放入 <code>If-None-Match</code> 请求标头中，以询问服务器资源是否已被修改：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;deadbeef&quot;<br></code></pre></td></tr></table></figure><p>如果服务器为请求的资源确定的 <code>ETag</code> 标头的值与请求中的 <code>If-None-Match</code> 值相同，则服务器将返回 <code>304 Not Modified</code>。</p><p>但是，如果服务器确定请求的资源现在应该具有不同的 <code>ETag</code> 值，则服务器将其改为 <code>200 OK</code> 和资源的最新版本进行响应。</p><p><strong>备注：</strong> 在评估如何使用 <code>ETag</code> 和 <code>Last-Modified</code> 时，请考虑以下几点：在缓存重新验证期间，如果 <code>ETag</code> 和 <code>Last-Modified</code> 都存在，则 <code>ETag</code> 优先。因此，如果你只考虑缓存，你可能会认为 <code>Last-Modified</code> 是不必要的。然而，<code>Last-Modified</code> 不仅仅对缓存有用；相反，它是一个标准的 HTTP 标头，内容管理 (CMS) 系统也使用它来显示上次修改时间，由爬虫调整爬取频率，以及用于其他各种目的。所以考虑到整个 HTTP 生态系统，最好同时提供 <code>ETag</code> 和 <code>Last-Modified</code>。</p><h3 id="强制重新验证"><a href="#强制重新验证" class="headerlink" title="强制重新验证"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching#%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E9%AA%8C%E8%AF%81">强制重新验证</a></h3><p>如果你不希望重复使用响应，而是希望始终从服务器获取最新内容，则可以使用 <code>no-cache</code> 指令强制验证。</p><p>通过在响应中添加 <code>Cache-Control: no-cache</code> 以及 <code>Last-Modified</code> 和 <code>ETag</code>——如下所示——如果请求的资源已更新，客户端将收到 <code>200 OK</code> 响应，否则，如果请求的资源尚未更新，则会收到 <code>304 Not Modified</code> 响应。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>deadbeef<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p><code>max-age=0</code> 和 <code>must-revalidate</code> 的组合与 <code>no-cache</code> 具有相同的含义。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0, must-revalidate<br></code></pre></td></tr></table></figure><p><code>max-age=0</code> 意味着响应立即过时，而 <code>must-revalidate</code> 意味着一旦过时就不得在没有重新验证的情况下重用它——因此，结合起来，语义似乎与 <code>no-cache</code> 相同。</p><p>然而，<code>max-age=0</code> 的使用是解决 HTTP&#x2F;1.1 之前的许多实现无法处理 <code>no-cache</code> 这一指令——因此为了解决这个限制，<code>max-age=0</code> 被用作解决方法。</p><p>但是现在符合 HTTP&#x2F;1.1 的服务器已经广泛部署，没有理由使用 <code>max-age=0</code> 和 <code>must-revalidate</code> 组合——你应该只使用 <code>no-cache</code>。</p><h3 id="4-现在知道为什么有时候让用户刷新页面也拿不到新数据了吧"><a href="#4-现在知道为什么有时候让用户刷新页面也拿不到新数据了吧" class="headerlink" title="4. 现在知道为什么有时候让用户刷新页面也拿不到新数据了吧"></a>4. 现在知道为什么有时候让用户刷新页面也拿不到新数据了吧</h3><p>就是因为可能在返回的请求中，带上了<code>Cache-Control: max-age=10086</code>，然而也确实时常带上，因为html文件基本不会有太大的变化，所以在一段时间内，只要没过<code>max-age</code>，那你的更新就不会成现在用户的页面上</p><p><em><strong>那你可能又要问了：那我直接<code>no-cache</code>或者<code>no-cache</code>不就行了？</strong></em></p><p>实际上也确实可以这么干，我一开始也是这么回答面试官的，但是这样做会有弊端：<strong>必须用户刷新页面之后才能看到新的内容，因为只有刷新的时候才会去请求新的html</strong></p><p>那又怎么办呢？那我们平常开发的 <code>dev server</code> 又是怎么做到实时更新的呢？那就是另一个故事咯</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>浏览器原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS的GC到底怎么工作的？💼</title>
    <link href="/2024/05/01/gc/"/>
    <url>/2024/05/01/gc/</url>
    
    <content type="html"><![CDATA[<h1 id="JS的GC到底怎么工作的？💼"><a href="#JS的GC到底怎么工作的？💼" class="headerlink" title="JS的GC到底怎么工作的？💼"></a>JS的GC到底怎么工作的？💼</h1><h2 id="引子：-啥是GC，为什么需要GC🗑️"><a href="#引子：-啥是GC，为什么需要GC🗑️" class="headerlink" title="引子： 啥是GC，为什么需要GC🗑️"></a>引子： 啥是GC，为什么需要GC🗑️</h2><p><code>GC</code>看起来高端，其实就是 <code>垃圾回收机制(Garbage Collection)</code> 的英文简称，主要负责清理执行过程中遗留的未被使用的变量，避免程序执行过程中耗尽内存而崩溃。</p><blockquote><p><strong>注意⚠️</strong></p><p>高级编程语言中，<code>GC</code>似乎成了一个必需品。但是需要注意的是，像<code>C</code>&#x2F;<code>CPP</code>这种偏底层的语言中，<code>GC</code>是不存在的。</p><p><em><strong>为什么呢？？？🥲</strong></em></p><p>其实这么做也是有原因的</p><ol><li>由于<code>GC</code>运行比较耗时，在高级语言中性能可能不是问题，但在C&#x2F;C++中，这可是不被允许的</li><li>C&#x2F;C++的设计哲学就是把控制权交给程序员，加上GC显然违背了设计理念</li></ol><p><strong>这种把所有控制权都交给程序员的做法可能很酷，但是会给日常开发带来很多麻烦，对于咱们这种三脚猫🐱来说是很痛苦的</strong></p></blockquote><p>反观咱们JS，主打就是一个</p><ul><li>皮实☝️，</li><li>性能什么的也不用在乎了（反正本来就是一片废墟了）</li><li>开发怎么舒服怎么来（虽然奇奇怪怪的bug让人很😖）</li></ul><p><em><strong>已经在谷底了，怎么走都是向上🔝</strong></em></p><hr><p>因此，有个<code>GC</code>很合理吧🤓。那么，今天就来讨论讨论</p><ul><li><code>JS</code>的<code>GC</code>到底是怎么工作的？</li><li>那些操作会绕过<code>GC</code>，造成内存泄漏？</li><li>如何查看是否内存泄漏？</li><li>如何预防内存泄漏</li></ul><h2 id="拓展知识-编译器、作用域、引擎的爱恨情仇🤡"><a href="#拓展知识-编译器、作用域、引擎的爱恨情仇🤡" class="headerlink" title="拓展知识: 编译器、作用域、引擎的爱恨情仇🤡"></a>拓展知识: 编译器、作用域、引擎的爱恨情仇🤡</h2><p>大家都知道，JS的执行分为 <code>编译</code>和<code>执行</code>两个阶段。那么这两个阶段都干了什么事呢？这两个阶段跟作用域又有什么关系呢？</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译阶段看名字也知道，是编译器在干活，主要干两件事：</p><ul><li>把变量放到作用域里边</li><li>给之后的引擎编译执行代码</li></ul><p>那么，它又是如何做到识别变量的呢？这可是字节的面试题，仔细听</p><p>来看例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>这个例子中，编译器先会把上边的句子分成 <code>let, a, =, 4</code>几个部分，这一步叫<code>词法分析</code>，</p><p>之后，它会根据词法分析的结果，构建抽象语法树<code>AST</code>，构建出来的树首先有一个<code>Variable Declearation</code>的父节点，下来的子节点是<code>Identifier</code>，就是<code>a</code>，与他为兄弟节点的是<code>AssignmentExpression</code>，代表赋值操作，它也有一个子节点，是<code>NumericLiteral</code>，代表数字。</p><p>遇到<code>let a</code>，编译器先向作用域询问是否存在<code>a</code>这个变量，如果存在，就抛出错误</p><blockquote><p>思考：如果把 <code>let</code>改成<code>var</code>呢？</p></blockquote><p>如果不存在，由上边AST得知是一个基本类型变量<code>NUmbericLiteral</code>，在栈内存中开辟一个变量<code>a</code>，在作用域里新建一个<code>a</code>；</p><p>如果是一个引用对象，即AST中<code>AssignmentExpression</code>子节点为<code>Reference</code>，那么就会把内容存入堆内存，栈中创建新变量保留堆地址</p><p><img src="https://img-blog.csdnimg.cn/4458babe7fae4db0bb16be3f73586d75.png#pic_center" alt="在这里插入图片描述"></p><p>之后，编译器才会处理<code>a=2</code>语句，它会把这个语句编译为引擎能执行的句法，把压力交给引擎</p><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>引擎在执行上一步生成的代码时，会查找变量的声明，就比如上边的例子，引擎执行时会询问作用域是否存在<code>a</code>变量，查找也分为两种：<code>LHS</code>和<code>RHS</code>，分别代表地址查询和值查询，这里的<code>a</code>就是一个地址查询，因为要把值赋给它嘛。很好理解吧！好！那我们进入正题咯</p><h2 id="Part1-JS的GC到底怎么工作的💼"><a href="#Part1-JS的GC到底怎么工作的💼" class="headerlink" title="Part1: JS的GC到底怎么工作的💼"></a>Part1: JS的GC到底怎么工作的💼</h2><p>🗑️垃圾回收机制的原理很简单，就跟把🐘塞到冰箱一样，主要分为三步</p><ol><li>找出不再使用的变量</li><li>释放其占用的内存</li><li>固定的时间间隔运行</li></ol><p>可以看到，只要第一步做对了，那第二、第三步就是洒洒水🙂‍↕️，那么引擎是如何找到不再使用的变量的呢？</p><p>再来给大家科普一下<code>ECMA</code>吧🥰</p><blockquote><p><code>ECMA</code>是<code>JS</code>的规范，按道理来说<code>JS</code>其实应该叫做<code>ECMAScript</code>，或者说是<code>ECMAScript</code>的一种。<code>JS</code>的所有特性都是由<code>ECMA</code>决定的</p><p>![image-20240428171503709](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240428171503709.png)</p></blockquote><p>那么，在ECMA中，有没有GC的定义呢？</p><p>很遗憾，没有，在ECMA中并没有GC的相关定义，所以GC似乎是靠各浏览器厂商自由发挥的，查了一下，大概分为两种方法。</p><h3 id="1-计数清除"><a href="#1-计数清除" class="headerlink" title="1. 计数清除"></a>1. 计数清除</h3><p>计数清除主要是咱们大名鼎鼎的<code>IE</code>在使用，原理很简单，就是<strong>当这个变量被引用时，计数加一，解除引用时，计数减一</strong>，当计数为零的时候，这个变量就会被GC回收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// a = 1</span><br>  <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// b = 1</span><br>  <br>  <span class="hljs-keyword">let</span> c = a; <span class="hljs-comment">// a++ -&gt; 2</span><br>  <span class="hljs-keyword">let</span> c = b; <span class="hljs-comment">// a-- -&gt; 1</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里就要用到咱们上边提到的预备知识啦</p><ul><li>你看这个<code>let a = new Object();</code>，<code>new Object</code>在堆新建变量，然后栈中<code>a</code>引用这个object，count++；</li></ul><blockquote><p> 在下方，<code>let c = a</code>的时候，构建的AST语法树是怎么样的呢？为什么这个时候引用会是2呢？</p></blockquote><p>那来看下一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">let</span> a=&#123;&#125;;<br><span class="hljs-keyword">let</span> b=&#123;&#125;;<br>a.<span class="hljs-property">prop</span> = b;<br>b.<span class="hljs-property">prop</span> = a;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里a和b的引用次数是多少呢？</p><p>不难看出，这里a和b的引用次数都是1，这代表着两个变量都不会被GC回收，这就是计数清除掉一大缺点：<strong>循环引用</strong></p><p>那这下就糟糕了，一旦有循环引用出现，就会引发内存泄漏，太危险了‼️</p><p>而且，这种做法计数器更改的会很频繁，每一次赋值操作可能都会更改计数器，因此也被抛弃在时代的长河中。</p><h3 id="2-标记清除"><a href="#2-标记清除" class="headerlink" title="2. 标记清除"></a>2. 标记清除</h3><p>这是目前浏览器大多基于标记清除法。我们可以分为两个阶段：</p><ul><li><strong>标记</strong>：从根节点遍历为每个可以访问到的对象都打上一个标记，表示该对象可达。</li><li><strong>清除</strong>：在没有可用分块时，对堆内存遍历，若没有被标记为可达对象就将其回收。</li></ul><p>这下子就很暴力了，直接遍历这个AST，没找到的变量就不打标记🏷️</p><p>而且完美解决了计数清除的两大问题🙋‍♀️：</p><ul><li>循环引用 -&gt; 打标记哪来的循环引用</li><li>计数器更改频繁 -&gt; 要没空间了才遍历整棵树，改动次数大大减少</li></ul><p>但是，这样不是完美的，主要有两大缺点：</p><ul><li>内存碎片化，删除没标记的变量的内存是随机的，很零散</li><li>内存分配速度慢，由于内存随机，所以速度慢</li></ul><p>针对这些问题，就衍生出了<strong>标记-整理</strong>法</p><p><img src="https://img-blog.csdnimg.cn/5b845752427c497389980380b6181007.png#pic_center" alt="在这里插入图片描述"></p><p>标记阶段一致，不过在分配的过程中，把被引用的对象移到一端，凑出完整的内存空间</p><h3 id="3-NodeJs-V8-中的垃圾回收机制"><a href="#3-NodeJs-V8-中的垃圾回收机制" class="headerlink" title="3. NodeJs V8 中的垃圾回收机制"></a>3. NodeJs V8 中的垃圾回收机制</h3><p>在 Node 中，通过 JS 使用内存时就会发现只能使用部分内存（64 位系统下约为 1.4 GB, 32 位系统下约为 0.7 GB），这导致 Node 无法直接操作大内存对象。</p><p>这是因为，以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收要 1 秒以上，而垃圾回收过程会引起 JS 线程暂停执行这么多时间。因此，在当时的考虑下，直接限制堆内存是一个好的选择。（目前已经可以并行）</p><h3 id="3-那么，在这个情况下，V8会怎么做？"><a href="#3-那么，在这个情况下，V8会怎么做？" class="headerlink" title="3.那么，在这个情况下，V8会怎么做？"></a>3.那么，在这个情况下，V8会怎么做？</h3><p><img src="https://img-blog.csdnimg.cn/4d0d1931a1084ee39b1deb00c38ed534.png#pic_center" alt="新老生代视图"></p><p>chrome把内存分为两个区，新生代和老生代，老生代就是常驻嘉宾🤨，新生代就是存活时间较短的变量，对于这两个区，垃圾回收的频次是不一样的。来看看吧</p><h4 id="1-新生代"><a href="#1-新生代" class="headerlink" title="1. 新生代"></a>1. 新生代</h4><p>新生代可以看到，把内存分为 使用区 和 空闲区，新加入的对象都会被存放到使用区，当使用区<strong>快被写满时</strong>，就执行一次垃圾回收操作。由此还引出了 Scavenge 算法</p><blockquote><p>Scavenge 流程如下：</p><ul><li>标记活动对象和非活动对象</li><li>复制 from space 的活动对象到 to space 并对其进行排序</li><li>释放 from space 中的非活动对象的内存</li><li>将 from space 和 to space 角色互换</li></ul><p><img src="https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Chrome%20V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20200925123816388.png" alt="image-20200925123816388"></p></blockquote><p><em><strong>那么，新生代对象如何才能变成老生代呢？</strong></em></p><ul><li>第一种情况：经过多次复制后依然存活的对象会被认为是生命周期较强的对象，会被移到老生代管理。</li><li>第二种情况：如果复制一个对象到空闲区时，空闲区空间占用超过25%，那么这个对象将被移到老生代区域。原因是，当完成回收后，空闲区转变成使用区，需继续进行内存分配，若占比过大，将会影响后续内存的分配。</li></ul><h4 id="2-老生代"><a href="#2-老生代" class="headerlink" title="2. 老生代"></a>2. 老生代</h4><p>老生代内容不需要怎么清理，采用的方法就是上边说的<strong>标记-整理</strong>。</p><h4 id="3-增量标记算法"><a href="#3-增量标记算法" class="headerlink" title="3. 增量标记算法"></a>3. 增量标记算法</h4><p>前面的三种算法，都需要将正在执行的 JavaScript 应用逻辑暂停下来，待垃圾回收完毕后再恢复。这种行为叫作“全停顿”（stop-the-world）。</p><p>在 V8 新生代的分代回收中，只收集新生代，而新生代通常配置较小，且存活对象较少，所以全停顿的影响不大，而老生代就相反了。</p><p>为了降低全部老生代全堆垃圾回收带来的停顿时间，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JS应用逻辑交替进行，直到标记阶段完成。</p><p><img src="https://pic3.zhimg.com/80/v2-a3b04ebaacf8f2b04309b68bcf37f72e_1440w.webp" alt="img"></p><p>经过增量标记改进后，垃圾回收的最大停顿时间可以减少到原来的 1&#x2F;6 左右。</p><h2 id="Part2-怎么欺骗GC🥰"><a href="#Part2-怎么欺骗GC🥰" class="headerlink" title="Part2. 怎么欺骗GC🥰"></a>Part2. 怎么欺骗GC🥰</h2><p>要做到欺骗GC，那就要破坏掉GC的工作条件咯，可以看到，只要变量可达，就不会被删除</p><p>那么怎么做到变量可达，又没什么用呢？</p><h3 id="1-那当然是闭包啦！"><a href="#1-那当然是闭包啦！" class="headerlink" title="1. 那当然是闭包啦！"></a>1. 那当然是闭包啦！</h3><p>来看例子：</p><p>以下代码就会引发内存泄漏哦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fun1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span><br>  arr.<span class="hljs-property">length</span> = <span class="hljs-number">1008658</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br>  &#125;<br>&#125;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> b = <span class="hljs-title function_">fun1</span>()<br>&#125;, <span class="hljs-number">6000</span>)<br></code></pre></td></tr></table></figure><h3 id="2-那当然是全局变量啦"><a href="#2-那当然是全局变量啦" class="headerlink" title="2. 那当然是全局变量啦"></a>2. 那当然是全局变量啦</h3><p>声明过多的全局变量，会导致变量变为常驻内存，要直到进程结束才能释放内存。</p><blockquote><p>⚠️注意：</p><h4 id="不仅仅是声明的变量会导致常驻内存，我们的计时器，是不是也挂载在globalThis上边呢？"><a href="#不仅仅是声明的变量会导致常驻内存，我们的计时器，是不是也挂载在globalThis上边呢？" class="headerlink" title="不仅仅是声明的变量会导致常驻内存，我们的计时器，是不是也挂载在globalThis上边呢？"></a>不仅仅是声明的变量会导致常驻内存，我们的计时器，是不是也挂载在<code>globalThis</code>上边呢？</h4><p>因此，来看看例子吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>   <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">1000</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>         i++;<br>      &#125;, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>运行看看，会是怎么样的？不过要慎用，小心页面崩溃！！！</p><h4 id="同样的，还有挂载在globalThis上的事件监听"><a href="#同样的，还有挂载在globalThis上的事件监听" class="headerlink" title="同样的，还有挂载在globalThis上的事件监听"></a>同样的，还有挂载在<code>globalThis</code>上的事件监听</h4></blockquote><h2 id="Part3-如何查看是否内存泄漏？👻"><a href="#Part3-如何查看是否内存泄漏？👻" class="headerlink" title="Part3. 如何查看是否内存泄漏？👻"></a>Part3. 如何查看是否内存泄漏？👻</h2><p>Chrome已经把工具给咱们做好啦，就在开发者面板上。</p><p>别忘了把旁边的<code>内存</code>打开！！！</p><p>![image-20240506144233098](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240506144233098.png)</p><p>就拿上边的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fun1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span><br>  arr.<span class="hljs-property">length</span> = <span class="hljs-number">1008658</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br>  &#125;<br>&#125;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> b = <span class="hljs-title function_">fun1</span>()<br>&#125;, <span class="hljs-number">6000</span>)<br></code></pre></td></tr></table></figure><p>举例吧！</p><p>![image-20240506144405667](&#x2F;Users&#x2F;lawkaiqing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240506144405667.png)</p><p>可以看到中间框内，<em><strong>内存只升不降，那就是造成了内存泄漏</strong></em>；</p><p>或者如果是点击事件，一般认为，<em><strong>五次连续点击后，仍没被回收，那就是内存泄漏</strong></em>，换句话说，就是图中呈现连续向上的五个阶梯，那就是内存泄漏</p><h2 id="Part4-如何预防内存泄漏🥲"><a href="#Part4-如何预防内存泄漏🥲" class="headerlink" title="Part4. 如何预防内存泄漏🥲"></a>Part4. 如何预防内存泄漏🥲</h2><h3 id="解除引用"><a href="#解除引用" class="headerlink" title="解除引用"></a>解除引用</h3><p>确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-keyword">var</span> localPerson = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  localPerson.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-keyword">return</span> localPerson;<br>&#125;<br><span class="hljs-keyword">var</span> globalPerson = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><span class="hljs-comment">// 手动解除 globalPerson 的引用</span><br>globalPerson = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p><h3 id="提供手动清空变量的方法"><a href="#提供手动清空变量的方法" class="headerlink" title="提供手动清空变量的方法"></a>提供手动清空变量的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> leakArray = [];<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">clear</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> leakArray = [];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在业务不需要用到的内部函数，可以重构在函数外，实现解除闭包"><a href="#在业务不需要用到的内部函数，可以重构在函数外，实现解除闭包" class="headerlink" title="在业务不需要用到的内部函数，可以重构在函数外，实现解除闭包"></a>在业务不需要用到的内部函数，可以重构在函数外，实现解除闭包</h3><h3 id="免创建过多生命周期较长的对象，或将对象分解成多个子对象"><a href="#免创建过多生命周期较长的对象，或将对象分解成多个子对象" class="headerlink" title="免创建过多生命周期较长的对象，或将对象分解成多个子对象"></a>免创建过多生命周期较长的对象，或将对象分解成多个子对象</h3><h3 id="避免过多使用闭包"><a href="#避免过多使用闭包" class="headerlink" title="避免过多使用闭包"></a>避免过多使用闭包</h3><h3 id="注意清除定时器和事件监听器"><a href="#注意清除定时器和事件监听器" class="headerlink" title="注意清除定时器和事件监听器"></a>注意清除定时器和事件监听器</h3><h3 id="Nodejs-中使用-stream-或-buffer-来操作大文件，不会受-Nodejs-内存限制"><a href="#Nodejs-中使用-stream-或-buffer-来操作大文件，不会受-Nodejs-内存限制" class="headerlink" title="Nodejs 中使用 stream 或 buffer 来操作大文件，不会受 Nodejs 内存限制"></a>Nodejs 中使用 stream 或 buffer 来操作大文件，不会受 Nodejs 内存限制</h3><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>垃圾回收机制是把双刃剑，它可以让开发者不用担心内存分配，但是同时，会造成脚本执行速度变慢。</p></li><li><p>以前的浏览器中主要通过标记清除方法来回收垃圾，NodeJs 和Chrome V8中主要通过分代回收、Scavenge、标记清除、增量标记等算法来回收垃圾。</p></li></ul><p>在日常开发中，有一些不引人注意的书写方式可能会导致内存泄漏，需要多注意自己的代码规范！！！🥳</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从0开始的React native教程🥹</title>
    <link href="/2024/03/16/from_0_to_react-native/"/>
    <url>/2024/03/16/from_0_to_react-native/</url>
    
    <content type="html"><![CDATA[<h1 id="从0开始的React-native教程🥹"><a href="#从0开始的React-native教程🥹" class="headerlink" title="从0开始的React native教程🥹"></a>从0开始的React native教程🥹</h1><h2 id="1-前端基本知识（速成版）"><a href="#1-前端基本知识（速成版）" class="headerlink" title="1.  前端基本知识（速成版）"></a>1.  前端基本知识（速成版）</h2><blockquote><p> <em><strong>简单介绍一下前端三件套：</strong></em></p><ul><li><p>HTML：网页的主干部分，可以理解为骨骼</p></li><li><p>CSS：给页面增加样式，可以理解为皮肤</p></li><li><p>JS：让静态页面动起来，可以理解为肌肉</p></li></ul></blockquote><blockquote><p><em><strong>然后简单介绍一下前端学习的基本路线：</strong></em></p><p>这个是神，前端任何知识点基本都有囊括，有事没事都可以去翻翻：<a href="https://developer.mozilla.org/zh-CN/">MDN</a></p></blockquote><p>对于这三座大山，各有各的千秋😣一个个来看</p><h3 id="1-1-HTML咋学🥶"><a href="#1-1-HTML咋学🥶" class="headerlink" title="1.1 HTML咋学🥶"></a>1.1 HTML咋学🥶</h3><p>感觉很少有人注意到这个问题，都感觉HTML有手就行，甚至于给只鸡撒把米都能写</p><p><img src="https://img2.imgtp.com/2024/03/16/vza01YbK.jpeg" alt="html"></p><p>然而，好像确实是这样😵‍💫</p><p>这里列个大纲，真的有👋就行：</p><ul><li>HTML文件结构：<code>&lt;head&gt;、&lt;body&gt;</code></li><li>HTML常见标签：<code>&lt;div&gt; &lt;span&gt; &lt;h1-6&gt; &lt;a&gt; &lt;p&gt; &lt;form&gt; &lt;input&gt;</code>等</li><li>HTML引入标签：<code>&lt;script&gt; &lt;link&gt; </code></li><li>HTML5语义化标签：<code>&lt;header&gt; &lt;nav&gt; &lt;main&gt;</code>等</li></ul><p>其实还有 <code>音视频标签</code> 和 <code>Canvas</code>这类较难的内容，这里不做展开，只讲最基础的🤠</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">MDN上的HTML教程</a></p><h3 id="1-2-CSS呢🙀"><a href="#1-2-CSS呢🙀" class="headerlink" title="1.2 CSS呢🙀"></a>1.2 CSS呢🙀</h3><p>有了解过前端的同学一定听说过：<em><strong>CSS才是前端最难的一部分</strong></em> </p><p>确实是嗷，但是CSS难在<em><strong>不同选择器不同属性的搭配出好看的视觉效果</strong></em>，其实说语法，也是相当简单的，就是要注意：</p><ul><li><code>各选择器的权重组合计算</code>,</li><li><code>伪类伪元素选择器的概念和作用</code></li><li>最新出的css新特性，比如：<code>is,has,of</code>选择器和<code>css</code>嵌套语法。</li></ul><blockquote><p>入门的话我也写过一篇博客：<a href="https://konodioda727.github.io/2023/09/10/CSS/">CSS入门</a>，可以参考（这还是招新的时候写的文档🫠）</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">MDN上CSS的教程</a></p><h3 id="1-3-JS☠️"><a href="#1-3-JS☠️" class="headerlink" title="1.3 JS☠️"></a>1.3 JS☠️</h3><p>直接上图；</p><p><img src="https://img2.imgtp.com/2024/03/16/rV6gzoFW.jpeg" alt="抽象JS"></p><p>JS没什么好说的：<strong>如果你的代码出现了问题，请先不要怀疑自己，先怀疑是不是js又犯病了🤡</strong></p><p>JS的语法也是相当简单，没什么条条框框，随便写，要注意的就是</p><ul><li><p>每个类中有大量的方法，需要灵活使用这些内置方法，比如<code>Array</code>类型含有<code>slice</code>,<code>splice</code>,<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>等众多方法。</p></li><li><p>同时还有个大哥：<code>DOM(Document Object Module)</code>  ，简单来说就是浏览器提供了一系列api， 让js可以控制html元素，基本的<code>节点增删改查</code>一定要会，比如<code>document.querySelector</code>，<code>document.appendChild</code></p><blockquote><p>在React Native中，<code>DOM</code>操作很受限：不能自由增加、删除节点</p></blockquote></li><li><p><code>ES6+</code>新加功能: </p><ul><li><code>Promise（这个不是新加功能）</code>，<code>async/await</code>：异步操作，网络请求都要用他俩</li><li><code>class</code>语法，这对你们来说肯定是小<code>case</code>啦</li><li><code>import</code> <code>export</code>语法</li><li><code>...args</code>：解构语法</li><li>等等等等</li></ul></li></ul><p>好好看<code>MDN</code>好好学</p><h2 id="2-bundler、开发服务器和runtime😎"><a href="#2-bundler、开发服务器和runtime😎" class="headerlink" title="2. bundler、开发服务器和runtime😎"></a>2. bundler、开发服务器和runtime😎</h2><h3 id="2-1-bundler"><a href="#2-1-bundler" class="headerlink" title="2.1 bundler"></a>2.1 bundler</h3><p>上边的三件套是写一个基本网页的基本要求。在这些要求之外，为了优化性能，还要把code打包压缩一下，这就要提到我们的<code>bundler</code>，现在流行的<code>bundler</code>：</p><ul><li>webpack：老东西，很慢，但是是很多框架的默认打包工具，比较底层，有很多插件可以用，想了解<code>bundler</code>原理可以看看</li><li>vi te：现在最流行的打包工具，比webpack快很多，中文文档很详细，毕竟是中国人写的</li><li>parcel：开箱即用，速度快，不用什么配置</li><li>bun：最近横空出世的网红打包工具、开发服务器和runtime，只支持<code>类unix</code>，比vite还快一些</li></ul><h3 id="2-2-开发服务器"><a href="#2-2-开发服务器" class="headerlink" title="2.2 开发服务器"></a>2.2 开发服务器</h3><p>一般的打包工具都会配置一个<code>server</code>.</p><p>就比如<code>bun</code>，默认直接<code>bun run dev</code>就可以跑，之后在浏览器直接打开页面就行，一般是<code>localhost:5173</code></p><p>同时使用框架的构建工具的同时，基本会配置好这一项，只用去<code>package.json</code>看相关配置就行，下面讲讲<code>package.json</code></p><h3 id="2-3-runtime"><a href="#2-3-runtime" class="headerlink" title="2.3 runtime"></a>2.3 runtime</h3><p>正常js运行在浏览器中，runtime自然就是浏览器中的js引擎，而如果在<code>Node</code>就是<code>node</code>的runtime，包含解释引擎和一些包含文件管理等的模块。</p><p>在<code>RN</code>中也是如此，<code>RN</code>提供了<code>Hermes</code>这个runtime，因为没有浏览器的环境，因此很多dom操作也会🚫</p><h2 id="3-依赖管理🥰"><a href="#3-依赖管理🥰" class="headerlink" title="3. 依赖管理🥰"></a>3. 依赖管理🥰</h2><p>首先，要装个<code>Node</code></p><blockquote><p>如果你用<code>bun</code>，那也行，但接下来我都按<code>node</code>讲</p><p><code>bun</code>的话遵循下面的转换规则：</p><ul><li><code>npm i &lt;pcakage&gt;</code> 换成<code>bun add &lt;package&gt;</code></li><li><code>npm i </code> 换成 <code>bun i</code></li><li><code>npx</code> 换成 <code>bunx</code></li></ul></blockquote><p>刚刚不是说讲讲<code>package.json</code>吗，怎么讲<code>Node</code>了？😱</p><p>你先别急，不讲<code>server</code>端的东西，讲讲它的故事</p><p>当你去下载<code>Node</code>的时候，会有两个东西被一起下载下来：<code>npm</code>和<code>npx</code>,他俩就像那个舒克和贝塔：</p><ul><li><code>npm</code>：管理包的</li><li><code>npx</code>：把包拿出来溜溜的</li></ul><p>下好之后，执行: <code>npm init</code>初始化，或者<code>npm init -y</code>一切都按默认配置来，这个时候就能看见<code>package.json</code>，初学只需要知道三个信息：</p><ul><li>dependencies：开发模式和生产模式公用的依赖，一般是核心功能的包</li><li>devdependencies：开发模式的依赖，一般是测试，代码审查、打包工具之类的</li><li>scripts：快捷方式</li></ul><h2 id="4-好啦，这些基本知识都有啦，来看看React😊"><a href="#4-好啦，这些基本知识都有啦，来看看React😊" class="headerlink" title="4. 好啦，这些基本知识都有啦，来看看React😊"></a>4. 好啦，这些基本知识都有啦，来看看React😊</h2><p>React的核心就是<code>JSX</code>语法，什么意思呢，就是可以把<code>html</code>和<code>js</code>揉在一起写，像这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/login/login&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">PageWrap</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/pageWrap/pageWrap&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;stuLoginConfig&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/configs/loginConfig&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StuLogin</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123;loginProps, topBarProps&#125; = stuLoginConfig<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">PageWrap</span> <span class="hljs-attr">topBarProps</span>=<span class="hljs-string">&#123;topBarProps&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Login</span> &#123;<span class="hljs-attr">...loginProps</span>&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Login</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">PageWrap</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">StuLogin</span><br><br></code></pre></td></tr></table></figure><p><code>JSX</code>的核心是<code>hooks</code>，React提供了一些默认<code>hooks</code>，比如<code>useState</code>，<code>useEffect</code>，<code>useCallback</code>等</p><p>可以看看<a href="https://react.dev/reference/react/hooks">官方文档</a>，这里不多赘述</p><p>最后最后，组件化这件事，也不用多说了，通过export和import就可以实现灵活的引入导出组件</p><p>然后看看文件结构，就差不多可以毕业了</p><h2 id="5-React-Native🤪"><a href="#5-React-Native🤪" class="headerlink" title="5. React Native🤪"></a>5. React Native🤪</h2><p><a href="https://reactnative.dev/docs/environment-setup">Native官网</a></p><p>看名字也看得出来，<code>React Native</code>是基于<code>React</code>的一款上层框架，所以之前学的<code>React</code>语法要派的上用场咯👆</p><blockquote><p>你们有sdk的用哪个方法跑都可以，但我个人还是比较推荐<code>expo</code>的方法：手机上下个<code>expo</code>，扫个码就能在手机上跑，或者直接在浏览器上跑</p></blockquote><p>然后,来讲讲<code>RN</code>与<code>React</code>不同的地方:</p><ul><li><p><strong>组件不同</strong>，<code>RN</code>中不能使用原始的<code>HTML</code>标签，<code>RN</code>提供的标签有：</p><ul><li><strong>View</strong>：<code>&lt;View&gt;</code> 组件类似于 Web 开发中的 <code>&lt;div&gt;</code> 元素，用于创建一个视图容器，可以包含其他组件，并且可以进行布局和样式控制。</li><li><strong>Text</strong>：<code>&lt;Text&gt;</code> 组件用于显示文本内容，类似于 Web 开发中的 <code>&lt;span&gt;</code> 元素，但是具有更多的文本样式控制属性。</li><li><strong>Image</strong>：<code>&lt;Image&gt;</code> 组件用于显示图片，可以加载本地图片或远程图片，并且支持缩放、裁剪和加载中状态。</li><li><strong>TextInput</strong>：<code>&lt;TextInput&gt;</code> 组件用于接收用户输入的文本，类似于 Web 开发中的 <code>&lt;input&gt;</code> 元素，可以实现文本输入框、密码输入框等功能。</li><li><strong>ScrollView</strong>：<code>&lt;ScrollView&gt;</code> 组件用于创建一个可滚动的视图容器，可以包含大量的子组件，并且支持垂直和水平方向的滚动。</li><li><strong>FlatList</strong>：<code>&lt;FlatList&gt;</code> 组件用于渲染长列表数据，性能更高，支持基于数据源的渲染方式，适用于大型数据集合。</li><li><strong>TouchableOpacity</strong>：<code>&lt;TouchableOpacity&gt;</code> 组件用于实现触摸事件的响应，类似于 Web 开发中的按钮元素，但可以实现点击时的视觉反馈效果。</li><li><strong>TouchableHighlight</strong>：<code>&lt;TouchableHighlight&gt;</code> 组件也用于实现触摸事件的响应，与 <code>&lt;TouchableOpacity&gt;</code> 类似，但是在被按下时会有不同的视觉效果。</li><li><strong>ActivityIndicator</strong>：<code>&lt;ActivityIndicator&gt;</code> 组件用于显示加载指示器，通常用于表示正在加载或处理中的状态。</li></ul></li><li><p><strong>事件不同，元素属性不同</strong></p><blockquote><p>比如，在<code>RN</code>中，并不支持<code>onClick</code>属性，要绑定按压事件等话要使用<code>onPress</code>，也不是所有属性都支持<code>onPress</code>，如果想给不支持<code>onPress</code>的组件增加事件监听，就要用到上边的<code>Touchable</code>等标签。</p></blockquote><p>要想看看每个组件的<code>props</code>，还得去看官方文档：这里拿<a href="https://reactnative.dev/docs/view">View</a>举例</p></li><li><p><strong>更多的api</strong></p><p><code>RN</code>支持更多系统api，这对你们来说也是老朋友啦，<a href="https://reactnative.dev/docs/accessibilityinfo">api文档在这里</a></p></li><li><p>**<code>RN</code>不支持<code>CSS</code>**，因为没有浏览器的<code>runtime</code>，不能解析css用在原生组件上，但是它支持<code>stylesheet</code>这个api，可以用类似于css的方式添加样式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">StyleSheet</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-native&quot;</span>;<br><br><span class="hljs-keyword">const</span> styles = <span class="hljs-title class_">StyleSheet</span>.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-attr">conversationModalButton</span>: &#123;<br>        <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,<br>        <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;80%&#x27;</span>,<br>        <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;10%&#x27;</span>,<br>        wq<br><span class="hljs-attr">display</span>: <span class="hljs-string">&quot;flex&quot;</span>,<br>        <span class="hljs-attr">justifyContent</span>: <span class="hljs-string">&quot;center&quot;</span>,<br>        <span class="hljs-attr">alignItems</span>: <span class="hljs-string">&quot;center&quot;</span>,<br>        <span class="hljs-attr">fontFamily</span>: <span class="hljs-string">&quot;PMingLiU Regular&quot;</span>,<br>        <span class="hljs-attr">fontSize</span>: <span class="hljs-number">24</span>,<br>        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#fff&quot;</span><br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> styles<br></code></pre></td></tr></table></figure><p>然后在组件中引入就行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Button</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-native&quot;</span>;<br><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./button_style&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">ConversationButton</span> = (<span class="hljs-params">&#123;onClick, title&#125;</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&#123;title&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;styles.conversationModalButton&#125;</span> <span class="hljs-attr">onPress</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ConversationButton</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>react基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>react基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数执行</title>
    <link href="/2024/03/16/scope_chain/"/>
    <url>/2024/03/16/scope_chain/</url>
    
    <content type="html"><![CDATA[<h1 id="JS函数执行机制"><a href="#JS函数执行机制" class="headerlink" title="JS函数执行机制"></a>JS函数执行机制</h1><blockquote><p> 前几天看到一片js深入的系列文，写到我心巴上，把作用域链这部分整理了一下，搞了这篇出来😊</p></blockquote><h2 id="1-词法作用域"><a href="#1-词法作用域" class="headerlink" title="1. 词法作用域"></a>1. 词法作用域</h2><p><em><strong>虽然js是一门动态的语言，但是它对于作用域的审查理念却是静态的</strong></em></p><p>来看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> value = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> value = <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-title function_">bar</span>();<br><br><span class="hljs-comment">// 结果是 ???</span><br></code></pre></td></tr></table></figure><p>我们先来假设：</p><ul><li><p>如果js采用的是静态检查，那么调用<code>bar</code>的时候，会调用<code>foo</code>，而<code>foo</code>中会使用<code>value</code>这个变量，而<code>foo</code>中并未定义，那么就会**沿着这个定义的位置，向上寻找<code>value</code>，如果一直查到顶部作用域<code>global</code>，仍未找到，就<code>throw ReferenceError</code>**，在这里，顶部作用域定义了value为1，因此会打印出1；</p></li><li><p>而如果是动态检查，就会从<code>foo</code>调用的位置往外层作用域找，找到的自然就是2</p></li></ul><p><em><strong>来看看吧👀</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">1<br></code></pre></td></tr></table></figure><p>前边也说了，js的作用域是静态的，所以显然会输出1，而这个作用域，就叫做<code>词法作用域</code></p><p>前面我标中的部分，也就是js处理作用域的方式（理论方式，接下来我会从代码层面讲讲它的实现，但是现在先不急，我们先再来看一个例子☝️，来自我们亲爱的🦏书）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一个例子</span><br><span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>();<br>&#125;<br><span class="hljs-title function_">checkscope</span>();<br><br><span class="hljs-comment">//第二个例子</span><br><span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-title function_">checkscope</span>()();<br></code></pre></td></tr></table></figure><p>猜猜这两段代码分别会输出什么？</p><p>揭晓答案😘：均会输出<code>local scope</code></p><p>但是二者其实还是有点区别的，现在告诉你们，他们的<code>执行上下文栈</code>会有区别，但是有什么区别呢？我们接下来好好唠唠第一个重点：<code>执行上下文栈</code></p><h2 id="2-执行上下文栈🤪"><a href="#2-执行上下文栈🤪" class="headerlink" title="2. 执行上下文栈🤪"></a>2. 执行上下文栈🤪</h2><p>在这我们要好好唠唠js的函数执行，不光是<code>执行上下文栈</code>哦，</p><p>但还是来看看<code>执行上下文</code>，特别简单，就是<code>执行函数的静态作用域链</code>。主要由三部分组成：</p><ul><li>变量对象（Variable Object）</li><li>作用域链</li><li>this</li></ul><p>首先，js执行函数分为两个部分：</p><ul><li><code>准备部分</code>：把变量、函数都定义好，放在<code>AO/VO</code>中，以备后用</li><li><code>执行部分</code>：执行函数，更改<code>AO/VO</code>的值</li></ul><p>至于<code>AO/VO</code>是什么，别急，下面会讲👇，现在只用知道它分为两个阶段就行咯</p><h3 id="2-1-执行部分"><a href="#2-1-执行部分" class="headerlink" title="2.1 执行部分"></a>2.1 执行部分</h3><p>举个🌰先：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun3</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fun3&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fun3</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fun2</span>();<br>&#125;<br><br><span class="hljs-title function_">fun1</span>();<br></code></pre></td></tr></table></figure><p>执行这段代码的时候，会发生什么？</p><p>我们一步一步来看，只看<code>fun1</code>的执行，假设执行上下文栈为<code>EStack</code>，首先得有个全局上下文</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">EStack</span>:[<br>  <span class="hljs-variable language_">global</span><br>]<br></code></pre></td></tr></table></figure><p>先执行<code>fun1</code>，把<code>fun1</code>入栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">EStack</span>:[<br>  fun1,<br>  <span class="hljs-variable language_">global</span><br>]<br></code></pre></td></tr></table></figure><p>发现<code>fun2</code>被调用了，<code>fun2</code>入栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">EStack</span>:[<br>  fun2,<br>fun1,<br>  <span class="hljs-variable language_">global</span><br>]<br></code></pre></td></tr></table></figure><p>发现<code>fun3</code>被调用了，<code>fun3</code>入栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">EStack</span>:[<br>  fun3,<br>fun2,<br>fun1,<br>  <span class="hljs-variable language_">global</span><br>]<br></code></pre></td></tr></table></figure><p><code>fun3</code>执行完，出栈，之后<code>fun2</code>,<code>fun1</code>依次出栈</p><p>简单吧😇，再来看看上边的例子咯，这个例子要一直用到结尾，贯穿全文的线索</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一版的栈</span><br><span class="hljs-title class_">EStack</span>: [<br>  f,<br>checkscope,<br>  <span class="hljs-variable language_">global</span><br>]<br><span class="hljs-comment">// 随后返回执行的f，f出栈，随后checkscope出栈</span><br><br><span class="hljs-comment">// 第二版的栈</span><br><span class="hljs-title class_">EStack</span>: [<br>  checkscope,<br>  <span class="hljs-variable language_">global</span><br>]<br><span class="hljs-comment">// 由于返回的是f函数，因此栈先这样</span><br><span class="hljs-comment">// 之后checkscope执行完毕，出栈，调用f，f入栈</span><br><span class="hljs-title class_">EStack</span>: [<br>  f,<br>  <span class="hljs-variable language_">global</span><br>]<br></code></pre></td></tr></table></figure><p>看出来了吧，执行上下文栈还是有很大区别的，但是这还没完，这只是执行部分哦，还有准备部分，来看看吧</p><h3 id="2-2-准备部分"><a href="#2-2-准备部分" class="headerlink" title="2.2 准备部分"></a>2.2 准备部分</h3><p>准备部分要涉及到 <code>变量对象(VO)</code>的知识，我们下面来讲，别着急，现在只需要知道，它会把变量什么的都定义好</p><h2 id="3-变量对象🤨"><a href="#3-变量对象🤨" class="headerlink" title="3. 变量对象🤨"></a>3. 变量对象🤨</h2><p>前面卖了这么久的关子，那这个<code>VO</code>是个什么呢？<code>ECMA</code>上是这么定义的：</p><blockquote><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p></blockquote><p>每个<code>执行上下文</code>都会有自己的变量对象，而因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊<strong>全局上下文下的变量对象</strong>和<strong>函数上下文下的变量对象</strong></p><p>在全局上下文中，变量对象就是<code>VO</code>本身，也就是全局变量本身，在浏览器中，全局变量被具化为<code>window</code>；而函数中，则需要活化，变成<code>AO（Activated Object）</code>，才能算是一个真正的变量对象</p><p>那么执行过程是怎么样的呢，简单写写：</p><h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p><p>变量对象会包括（次序不能乱！！！）：</p><ol><li>函数的所有形参 (如果是函数上下文)<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则<strong>完全替换这个属性</strong></li></ul></li><li>变量声明<ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明<strong>不会干扰已经存在的这类属性</strong></li></ul></li></ol><p>由于这个次序问题，也可以引出很多奇怪的问题，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> fun1)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> fun1 = <span class="hljs-number">2</span><br><br><span class="hljs-comment">// 会输出什么？</span><br><span class="hljs-comment">// 如果把 第二行改成 var fun1 = function() &#123;&#125; 呢？</span><br><span class="hljs-comment">// 如果把 var 改成 let 呢？</span><br></code></pre></td></tr></table></figure><p>但是你可能会好奇，那值什么时候加进来呢？别急，马上就讲</p><hr><p>进入上下文的时候，首先会初始化一个<code>变量对象</code></p><ul><li>如果是<code>全局环境</code>，就把所有全局定义的变量拉过来初始化；</li><li>如果是<code>函数环境</code>，就按上边说的，把参数拿来初始化</li></ul><p>举个🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br>  b = <span class="hljs-number">3</span>;<br><br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>进入<code>foo</code>执行上下文后，会激活<code>foo</code>的变量对象，并拿<code>arguments</code>初始化它，就是上边讲的三步依次执行得到如下的<code>AO</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">AO</span> = &#123;<br><span class="hljs-attr">arguments</span>: &#123;<br><span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br><span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>&#125;,<br><span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br><span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,<br><span class="hljs-attr">c</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-attr">d</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><p>逐行依次执行，更新<code>AO</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">AO</span> = &#123;<br>    <span class="hljs-attr">arguments</span>: &#123;<br>        <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>    &#125;,<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">c</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>    <span class="hljs-attr">d</span>: reference to <span class="hljs-title class_">FunctionExpression</span> <span class="hljs-string">&quot;d&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>到这一步，AO就算构造完毕了，就要把它扔到函数的<code>[[scope]]</code>中，也就是接下来要讲的<code>作用域链</code>，但是先别急，来看个例子先：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>    a = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// ???</span><br><br><span class="hljs-comment">// 第二版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    a = <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ???</span><br></code></pre></td></tr></table></figure><p>这两个会有什么差别吗</p><h2 id="4-作用域链😏"><a href="#4-作用域链😏" class="headerlink" title="4. 作用域链😏"></a>4. 作用域链😏</h2><p>每个函数都有一个<code>[[scope]]</code>属性，用来存放作用域链，其实说白了，还记得咱们一开始讲的<code>词法作用域</code>吗？就是这玩意啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">gg</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bond</span>(<span class="hljs-params"></span>) &#123;<br>        ...<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>就像这个函数，初始化的时候是这样的：</p><p><code>gg.[[scope]] = [globalContext.VO]</code> </p><p><code>bond.[[scope]] = [ggContext.AO, global.VO]</code></p><p>之后，函数被调用，激活的时候，就会把当前的<code>AO</code>推入到<code>执行上下文的作用域链中</code></p><p>这么说可能有点抽象，来看🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 还记得它不</span><br><br><span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>();<br>&#125;<br><span class="hljs-title function_">checkscope</span>();<br></code></pre></td></tr></table></figure><p>首先，进入<code>全局上下文</code>，<code>EStack</code>推入<code>globalContext</code>并且初始化<code>globalContext</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// EStack</span><br><span class="hljs-title class_">EStack</span> = [<br>  globalContext<br>]<br><br><span class="hljs-comment">// globalContext</span><br>globalContext = &#123;<br>  <span class="hljs-attr">VO</span>: [<span class="hljs-variable language_">global</span>],<br>  <span class="hljs-attr">this</span>: globalContext.<span class="hljs-property">VO</span>,<br>  <span class="hljs-attr">scope</span>: [globalContext.<span class="hljs-property">VO</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>遇到<code>checkscope</code>，也推进去，同时把当前作用域保存到<code>[[scope]]</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// EStack</span><br><span class="hljs-title class_">EStack</span> = [<br>  checkScopeContext,<br>globalContext<br>]<br><span class="hljs-comment">// checkscope</span><br>checkscope.[[scope]] = [globalContext.<span class="hljs-property">VO</span>]<br></code></pre></td></tr></table></figure><p>然后，把<code>scope</code>传给<code>checkscopeContext</code>，并用<code>arguments</code>初始化<code>checkscopeContext</code>(忘了的自己回去看):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">checkscopeContext = &#123;<br><span class="hljs-attr">scope</span>: checkscope.[[scope]],<br><span class="hljs-attr">this</span>: <span class="hljs-literal">undefined</span>,<br><span class="hljs-attr">AO</span>: &#123;<br><span class="hljs-attr">arguments</span>: &#123;<br><span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>&#125;,<br>  <span class="hljs-attr">scope</span>: <span class="hljs-literal">undefined</span>,<br>    <span class="hljs-attr">f</span>: references to <span class="hljs-keyword">function</span> f<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>等<code>AO</code>创建完毕，把<code>AO</code>压到<code>scope</code>的最顶端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">checkscopeContext = &#123;<br><span class="hljs-attr">scope</span>: <span class="hljs-variable constant_">AO</span>.<span class="hljs-title function_">concat</span>(checkscope.[[scope]]),<br><span class="hljs-attr">this</span>: <span class="hljs-literal">undefined</span>,<br><span class="hljs-attr">AO</span>: &#123;<br><span class="hljs-attr">arguments</span>: &#123;<br><span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>&#125;,<br>  <span class="hljs-attr">scope</span>: <span class="hljs-literal">undefined</span>,<br>    <span class="hljs-attr">f</span>: references to <span class="hljs-keyword">function</span> f<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行<code>checkscope</code>函数，此时的<code>Context</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">checkscopeContext = &#123;<br><span class="hljs-attr">scope</span>: <span class="hljs-variable constant_">AO</span>.<span class="hljs-title function_">concat</span>(checkscope.[[scope]]),<br><span class="hljs-attr">this</span>: <span class="hljs-literal">undefined</span>,<br><span class="hljs-attr">AO</span>: &#123;<br><span class="hljs-attr">arguments</span>: &#123;<br><span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>&#125;,<br>  <span class="hljs-attr">scope</span>: <span class="hljs-string">&quot;local scope&quot;</span>,<br>    <span class="hljs-attr">f</span>: references to <span class="hljs-keyword">function</span> f<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后发现要执行<code>f</code>，就把<code>f</code>也压进<code>EStack</code>，同样的，<code>fContext</code>最终为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">fContext = &#123;<br><span class="hljs-attr">scope</span>: <span class="hljs-variable constant_">AO</span>.<span class="hljs-title function_">concat</span>(checkscopeContext.<span class="hljs-property">AO</span>),<br><span class="hljs-attr">this</span>: fscope.[[scope]],<br>  <span class="hljs-attr">AO</span>: &#123;<br>    <span class="hljs-attr">arguments</span>: &#123;<br><span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>&#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这里的<code>f</code>中本身未定义<code>scope</code>，是通过作用域链向上寻找找到的, 上一层是<code>checkscope</code>,所以最后会打印出<code>localscope</code></p><p>之后返回<code>f()</code>，<code>f</code>出栈，<code>checkscope</code>出栈</p><p>第二段代码的实现就交给大家咯，不清楚没关系，下一节也要讲🤣</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-title function_">checkscope</span>()();<br></code></pre></td></tr></table></figure><h2 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h2><p>经过上边的解释，闭包就很好理解了，无非就是引用上层变量嘛，其实说白了，任何函数其实都可以说是一个闭包，看这个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><br><span class="hljs-title function_">checkscope</span>()();<br></code></pre></td></tr></table></figure><p>分析一下不难发现，在<code>f</code>函数调用的时候，<code>checkscope</code>已经被弹出了，但是为什么他仍然能引用到<code>checkscope</code>的东西呢，原因就在<code>scope</code>上。</p><p>除了调用栈，js中还可以通过<code>scope</code>访问上层变量，这也是js闭包形成的原因</p><p>话不多说，看题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]();<br><br><span class="hljs-comment">// 输出什么？</span><br><span class="hljs-comment">// 如果把 for 中的 var 变成 let 呢？</span><br></code></pre></td></tr></table></figure><p>这里要涉及到一个很黑的知识点：<code>var</code>没有块级作用域</p><p>因此i的值存在<code>global</code>中，在执行函数之前，<code>globalContext</code>是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">globalContext = &#123;<br>    <span class="hljs-attr">VO</span>: &#123;<br>        <span class="hljs-attr">data</span>: [...],<br>        <span class="hljs-attr">i</span>: <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>function</code>的<code>scope</code>是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">data[<span class="hljs-number">0</span>]<span class="hljs-title class_">Context</span> = &#123;<br>    <span class="hljs-title class_">Scope</span>: [<span class="hljs-variable constant_">AO</span>,forContext, globalContext.<span class="hljs-property">VO</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>因此答案就呼之欲出咯：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">3<br>3<br>3<br></code></pre></td></tr></table></figure><p>那如果要改成 let，let是有块级作用域的，因此，每次循环都会保留一份i的副本在<code>forContext</code>中，因此会打印出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>那现在请思考：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = (<span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>        &#125;<br>  &#125;)(i);<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]();<br></code></pre></td></tr></table></figure><p>这样会输出什么？</p><p>其实道理和<code>let</code>相似，你不是没有块级作用域吗，那我就想办法让你有呗，咋整？</p><p>那不是传入的参数会被用来初始化吗，而<em><strong>js中所有传参都是值传递</strong></em>，那这不就结了吗，再搞个函数，把i当参数穿进去，这不就相当于有了一个有变量的块作用域了吗？因此，会输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="5-总结🤓"><a href="#5-总结🤓" class="headerlink" title="5. 总结🤓"></a>5. 总结🤓</h2><ul><li>先进入全局上下文，把所有全局变量放到<code>global.VO</code>中，之后一行行扫描，其实也可以把<code>global</code>看作特殊的函数</li><li>之后扫描遇到的函数声明，先把<code>[[scope]]</code>定义好</li><li>调用的时候，把<code>Context</code>推入调用栈，用<code>arguments</code>初始化<code>AO</code></li><li>执行函数，更改<code>AO</code>的引用</li><li>执行完毕，推出栈</li></ul><hr><p>最后还有一道看到的有意思的题目，与上边无关嗷，看看咯：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>)&#123;<br>getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>        &#125;;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构的艺术</title>
    <link href="/2024/03/06/refactor/"/>
    <url>/2024/03/06/refactor/</url>
    
    <content type="html"><![CDATA[<h1 id="重构的艺术🤪"><a href="#重构的艺术🤪" class="headerlink" title="重构的艺术🤪"></a>重构的艺术🤪</h1><blockquote><p>强烈建议大家去看一下： <code>《重构：改善代码的既有设计》</code>这本书，超级好看，计算机圣经。🥳</p><p>前半部分讲解<strong>为什么要进行重构</strong>、<strong>什么时候进行重构</strong>以及<strong>重构的好处</strong>，超级有意思；后半部分就是纯纯工具书，不知道咋重构的时候翻一翻就行💩</p><p>里面有句话我现在都记得：<em><strong>傻瓜都能写出计算机能看懂的代码，而能写出人能够看懂的代码的才叫优秀的程序员</strong></em></p></blockquote><h2 id="一、为什么需要重构🤡"><a href="#一、为什么需要重构🤡" class="headerlink" title="一、为什么需要重构🤡"></a>一、为什么需要重构🤡</h2><p>其实在计算机<code>早期发展阶段</code>是没有重构的概念的，因为那个时候程序<strong>体量很小</strong>，所以推崇<strong>在开发之前就规划好一整个程序</strong>。</p><p>但是随着程序体量越来越大，即使是最优秀的大牛也不能在开发之前就把所有情况都考虑进去。👾</p><p>所以只能一次又一次地给原来的程序贴补丁，然而这种<strong>面对bug贴补丁</strong>的治标不治本的方式只会使补丁越来越多，程序<strong>越来越臃肿，越来越难以维护</strong>🫨</p><p>终于，到了一点都写不下去的时候，<code>重构</code>的概念就诞生了，并且迅速获得了大家的青睐，并被认为是一种可以极大提高开发效率的方式。</p><blockquote><p>在大家的<code>miniproject</code>中肯定也会遇到相似的问题：产品要求越来越多😵，一些原来根本没考虑的用法的产生，会导致代码逻辑越来越混乱，越写越自闭（去年我就在是这样的🤡🤡🤡）。</p><p>这个时候，别害怕，捋清思路，果断重构！！！</p></blockquote><p>但是，<code>重构</code>的意义不止于此：随着技术的迅速发展，老一代技术渐渐被取代，这个时候，<code>用新技术重构老项目</code>就显得格外重要</p><p>就比如用<code>react</code>重构之前<code>jQuery</code>的项目🤪</p><p><em>因此，小小总结一下，重构就是因为：</em></p><ul><li>之前写的烂，改不了一点或者改的很耗时很费精力</li><li>项目要与时俱进，换上新技术，提高效能</li></ul><h2 id="二、要怎么重构🤕"><a href="#二、要怎么重构🤕" class="headerlink" title="二、要怎么重构🤕"></a>二、要怎么重构🤕</h2><p><strong>《重构》的作者称这个为发现代码里的坏味道💩</strong></p><blockquote><p>首先，肯定是要捋清<code>逻辑混乱</code>产生的原因，分析过后，把逻辑重写，重新组织函数、组件的关系</p></blockquote><ul><li><p>一些逻辑混乱来源于不合理的组件拆分，<em><strong>不要想着让一个组件适应所有的情况</strong></em>，这样只会让这一个组件越来越难懂复杂</p><p><em><strong>一个组件只干一件事情😃😃😃</strong></em></p><blockquote><p>就比如<code>button</code>组件，一开始的功能就是按下有反应。但是现在发现又需要一个可以有弹窗的<code>button</code>组件。</p><p>这时候一般的想法就是做个判断，给原来的组件上加一个<code>hasModal</code>，有这个属性就有弹窗，也不是不行嗷🤣。</p><p>确实是这样，稍微加一点<code>prop</code>会让我们的组件功能更强大，但是过多的<code>props</code>就挺让人头大了</p><p>就比如再给这个<code>button</code>加上跳转页面、下载文件、上传文件等等的功能，这个时候浅浅看一下有多少个<code>props</code>呢？ <code>hasModal</code>,<code>navigatePath</code>,<code>download</code>,<code>upload</code></p><p>这个时候我就已经相当烦了，但是情况可能更超乎意料，可能还有<code>button</code>在页面上存在3秒之后页面就要开始抖动这种逆天的功能呢。你永远想象不到你的老板有什么鬼马点子😏</p><p>所以，这个时候完全可以把这些个<code>button</code>拆开，正常的<code>button</code>用一个组件，有特殊功能的，就单独再写一个，避免别人要这个组件的时候点开看到1000行的<code>props提示</code>发呆。👾</p></blockquote></li><li><p>一些逻辑问题出现在<em><strong>组件之间<code>耦合度</code>太高</strong></em>，改动一个小部分要修改大半个页面的代码，这种是真的痛苦🤗</p><blockquote><p>还是拿上边的<code>button</code>做例子，<code>hasModal</code>,<code>navigatePath</code>,<code>download</code>,<code>upload</code>这些功能，完全可以改成一个<code>onClick</code>回调函数😏,之后要用的时候把要执行的任务作为函数传进来，这样<code>button</code>就只用单独处理自身<code>onClick</code>的逻辑就行啦，复用性自然也就提高了</p><p><strong>一个好的组件写完之后用800年也不需要改一次代码</strong></p></blockquote></li><li><p>还有一些出在<em><strong>乱七八糟的逻辑条件判断</strong></em>上</p><p><code>if</code>嵌800行，图灵来了都看不懂，再来点循环，上帝都看不懂🦢</p><p>好好<code>review</code>自己写的💩💩💩,把类似什么 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">True</span> = flag ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这种脱裤子放屁的东西都化简了（有时候<code>ide</code>都看不下去会给你标黄🤣）；再把<code>if</code>这种语句尽量改成<code>三目运算符</code>；把<code>switch</code>这种语句换成<code>多态类</code>；</p><p>提高点可读性，对你和你的<code>partner</code>都好🤯🤯🤯</p></li></ul><blockquote><p>其次就是<em><strong>重新组织文件结构</strong></em></p></blockquote><ul><li><p>文件结构应该层次分明，逻辑清晰，以下是<code>husky🐶</code>推荐的目录结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── .husky              <span class="hljs-comment"># husky的配置文件</span><br>├── dist               <span class="hljs-comment"># 打包后的代码和资源文件</span><br>├── node_modules        <span class="hljs-comment"># 依赖库和模块</span><br>├── src<br>│   ├── assets          <span class="hljs-comment"># 静态资源</span><br>│   ├── components      <span class="hljs-comment"># 公共组件</span><br>│   ├── pages           <span class="hljs-comment"># 页面</span><br>│   ├── <span class="hljs-built_in">type</span>            <span class="hljs-comment"># 全局类型声明</span><br>│   ├── utils           <span class="hljs-comment"># 工具函数</span><br>│   ├── App.tsx<br>│   ├── fetch.ts        <span class="hljs-comment"># 网络请求</span><br>│   ├── main.tsx<br>│   ├── router.tsx      <span class="hljs-comment"># 路由配置信息</span><br>│   └── vite-env.d.ts<br>├── .commitlintrc.cjs<span class="hljs-comment"># commitlint的配置文件</span><br>├── .eslintignore<br>├── .eslintrc.cjs       <span class="hljs-comment"># ESLint的配置文件</span><br>├── .gitignore<br>├── .prettierignore<br>├── .prettierrc.cjs     <span class="hljs-comment"># Prettier的配置文件</span><br>├── index.html<br>├── package.json<br>├── README.md<br>├── tsconfig.json<br>├── tsconfig.node.json<br>├── vite.config.ts<br>└── yarn.lock<br></code></pre></td></tr></table></figure><p>其中，每个<code>page</code>和<code>component</code>也都可以有自己独有的<code>component</code>，最外层的<code>component</code>只放不同页面不同组件均要用到的组件</p></li></ul><blockquote><p>然后就是一个被很多人忽略的点：<em><strong>换个好的名字</strong></em></p></blockquote><ul><li><p>有时候，换一个人类能看懂的名字真的能帮上大忙😐。</p><p>不要怕名字太长什么的，又不是你自己写，<code>ide</code>都没抱怨你急什么？</p><blockquote><p>就比如说（真实案例哈😕）：</p><p>你看到一个组件，叫<code>Ritem</code>，你能看出来它是干啥的吗？</p><p>但是，如果改个名字，叫<code>RescueInfoItem</code>,是不是就清晰多了</p><p>顺带提一句，前几天我起出了这辈子来最长的名字： <code>RescueInfoSortedByTargetIDSlice</code>😶‍🌫️</p></blockquote></li></ul><h2 id="四、重构的步骤"><a href="#四、重构的步骤" class="headerlink" title="四、重构的步骤"></a>四、重构的步骤</h2><p><strong>光说说可能没什么感觉，接下来，我将会使用我最近重构的一段代码（js-&gt;ts）来给大家展示重构的魅力👽，用例子的方式给大家讲解一下重构的步骤（这段代码的来源保密🤪）</strong></p><blockquote><p>msgItem.jsx (这是我们要重构的组件)</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Taro</span>, &#123;useReady&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tarojs/taro&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">View</span> ,<span class="hljs-title class_">Image</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tarojs/components&#x27;</span><br><span class="hljs-keyword">import</span> &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.less&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Fetch</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../Service/fetch&#x27;</span><br><br><br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">MsgItem</span>=(<span class="hljs-params">props</span>)=&gt;&#123;<br><br>        <span class="hljs-keyword">const</span> [flag,setFlag]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>        <span class="hljs-keyword">const</span> [finish,setFinish]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;已救援&#x27;</span>)<br>      <span class="hljs-comment">//  const [jiean,setJiean]=useState(&#x27;&#x27;)</span><br>        <span class="hljs-keyword">const</span> [color,setColor]=<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">//0:#f57b70  1:#76A9FF 2:#f9a53e</span><br>       <span class="hljs-comment">// const [status,setStatus]=useState(0)</span><br>        <span class="hljs-keyword">const</span> [text,setText]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">const</span> [area,setArea]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">const</span> [level,setLevel]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">const</span> [data,setData]=<span class="hljs-title function_">useState</span>([])<br>        <span class="hljs-keyword">const</span> [ifmine,setIfmine] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)<br><br>        <span class="hljs-keyword">const</span> param=props<br><br>        <span class="hljs-keyword">const</span> status = [<br>            <span class="hljs-string">&#x27;未救援&#x27;</span>,<br>            <span class="hljs-string">&#x27;救援中&#x27;</span>,<br>            <span class="hljs-string">&#x27;已救援&#x27;</span><br>        ]<br>        <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-comment">/* console.log(param.flag) */</span><br>          <span class="hljs-comment">//  setStatus(param.status)//主页item</span><br>        <br>          <span class="hljs-keyword">if</span>(param.<span class="hljs-property">flag</span>==<span class="hljs-string">&#x27;main&#x27;</span>)  <span class="hljs-comment">//主页</span><br>          &#123;<br>            <span class="hljs-title function_">setFlag</span>(<span class="hljs-string">&#x27;alarm&#x27;</span>)<br>            <span class="hljs-keyword">if</span>(param.<span class="hljs-property">ifmine</span>)<br>            &#123;<br>                <span class="hljs-title function_">setIfmine</span>(<span class="hljs-literal">true</span>)<br>                <span class="hljs-title function_">setFinish</span>(<span class="hljs-string">&#x27;救援中&#x27;</span>)<br>                <span class="hljs-title function_">setColor</span>(<span class="hljs-number">1</span>)<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//  未认领的救援</span><br>                <span class="hljs-title function_">setIfmine</span>(<span class="hljs-literal">false</span>)<br>                <span class="hljs-title class_">Fetch</span>(<br>                    <span class="hljs-string">&#x27;/rescue/targetinfo&#x27;</span>,<br>                    &#123;<br>                        <span class="hljs-string">&quot;rescue_target_id&quot;</span>: param.<span class="hljs-property">rescue_target_id</span>,<br>                    &#125;,<br>                    <span class="hljs-string">&#x27;POST&#x27;</span><br>                ).<span class="hljs-title function_">then</span>(<br>                    <span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>                        <span class="hljs-comment">//console.log(res)</span><br>                        <span class="hljs-title function_">setFinish</span>(status[res.<span class="hljs-property">data</span>.<span class="hljs-property">rescue_target_info</span>.<span class="hljs-property">status</span>])<br>                        <span class="hljs-title function_">setColor</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">rescue_target_info</span>.<span class="hljs-property">status</span>)<br>                    &#125;<br>                )<br>          &#125;&#125;<br>          <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//record</span><br>            <span class="hljs-title function_">setFlag</span>(<span class="hljs-string">&#x27;record&#x27;</span>)<br>            <span class="hljs-title function_">setFinish</span>(status[param.<span class="hljs-property">status</span>])<br>            <span class="hljs-title function_">setColor</span>(param.<span class="hljs-property">status</span>)<br>          &#125;<br>            <span class="hljs-title function_">setText</span>(param.<span class="hljs-property">text</span>)<br>            <span class="hljs-title function_">setArea</span>(param.<span class="hljs-property">area</span>)<br>            <span class="hljs-title function_">setLevel</span>(param.<span class="hljs-property">risk_level</span>)<br>            <span class="hljs-title function_">setData</span>(param.<span class="hljs-property">data</span>)<br>        &#125;,[param])<br>      <br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">toR_detail</span>(<span class="hljs-params"></span>)<br>        &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flag)<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-string">&#x27;alarm&#x27;</span>)<br>            <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">navigateTo</span>(&#123;<br>                <span class="hljs-attr">url</span>:<span class="hljs-string">`/moduleA/pages/Alarm/index?ifmine=<span class="hljs-subst">$&#123;ifmine&#125;</span>&amp;data=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(data)&#125;</span>&amp;finish=<span class="hljs-subst">$&#123;finish&#125;</span>&amp;color=<span class="hljs-subst">$&#123;color&#125;</span>`</span><br>            &#125;)<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;todetail&#x27;</span>)<br>                <span class="hljs-keyword">const</span> jiean = param.<span class="hljs-property">status</span>==<span class="hljs-number">1</span>?<span class="hljs-string">&#x27;未结案&#x27;</span>:<span class="hljs-string">&#x27;已结案&#x27;</span><br>                <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">navigateTo</span>(&#123;<br>                    <span class="hljs-attr">url</span>:<span class="hljs-string">`/moduleA/pages/Rescue_detail/index?finish=<span class="hljs-subst">$&#123;jiean&#125;</span>&amp;data=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(data)&#125;</span>&amp;teacher=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(param.teacher)&#125;</span>&amp;lap=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(param.lap)&#125;</span>`</span><br>                &#125;)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;noti-item column&#x27;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toR_detail&#125;</span> &gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;inline&#x27;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;state&#x27;</span><span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;backgroundColor:color</span>==<span class="hljs-string">2?</span>&#x27;#<span class="hljs-attr">76A9FF</span>&#x27;<span class="hljs-attr">:color</span>==<span class="hljs-string">1?</span>&#x27;#<span class="hljs-attr">f9a53e</span>&#x27;<span class="hljs-attr">:</span>&#x27;#<span class="hljs-attr">f57b70</span>&#x27;&#125;&#125;&gt;</span>&#123;finish&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;rescued_level&#x27;</span>&gt;</span></span><br><span class="language-xml">                    风险等级：&#123;level&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;rescued_info&#x27;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;row&#x27;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;border_l&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>微博内容：<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;demand&#x27;</span>&gt;</span>&#123;text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;rescued_city&#x27;</span>&gt;</span></span><br><span class="language-xml">                    地点：&#123;area&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">            &#123;/* <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;require&#x27;</span>&gt;</span>主要诉求：<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>感情受挫，家庭不和，和亲人有隔阂<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span> */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br>        )<br><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MsgItem</span>;<br></code></pre></td></tr></table></figure><p><strong>这是一段超级长的代码，有110行，一般我们组件超过70行就已经不是很优雅了（反正我看到超过70行的组件就头大🥺），因此，重构就应该提上日程</strong></p><p><em><strong>那问题来了，该如何下手呢？🤨</strong></em></p><ol><li><p>要重构一个组件，首先要清除在哪里会被用到，我这里找了它的几个用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// R_record.jsx </span><br><span class="hljs-comment">// 这里Ritem就是msgItem</span><br>&#123;list?list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>&#123;<br>                    <span class="hljs-keyword">return</span> (<br>                        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Ritem</span> &#123;<span class="hljs-attr">...item</span>&#125; <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;item&#125;</span> <span class="hljs-attr">teacher</span>=<span class="hljs-string">&#123;teacher&#125;</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&#123;status&#125;</span> <span class="hljs-attr">lap</span>=<span class="hljs-string">&#123;lap&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;rescue&#x27;</span> <span class="hljs-attr">flag</span>=<span class="hljs-string">&#x27;record&#x27;</span> /&gt;</span></span><br>                    )<br>                &#125;):<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;img&#x27;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Main.jsx</span><br>&#123;mine?mine.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>&#123;<br>                    <span class="hljs-keyword">return</span> (<br>                      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MsgItem</span> &#123;<span class="hljs-attr">...item</span>&#125; <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;item&#125;</span>  <span class="hljs-attr">ifmine</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;item&#x27;</span> <span class="hljs-attr">flag</span>=<span class="hljs-string">&#x27;main&#x27;</span> /&gt;</span></span><br>                    )<br>                  &#125;)<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//Search.jsx </span><br><span class="hljs-comment">// 这段是之前我写的，一坨💩</span><br> &#123;form &amp;&amp;<br>          form.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MsgItem</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;item&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            &#123;<span class="hljs-attr">...item</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">ifmine</span>=<span class="hljs-string">&#123;form.some(itm</span> =&gt;</span> JSON.stringify(item) === JSON.stringify(itm))&#125;</span><br><span class="language-xml">            key=&#x27;item&#x27;</span><br><span class="language-xml">            flag=&#x27;main&#x27;</span><br><span class="language-xml">          &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">MsgItem</span>&gt;</span></span>)&#125;<br></code></pre></td></tr></table></figure><p>在真正重构的过程中，一定要理解这些个组件有什么用，是干啥的，但是现在这个例子中，先不用管，因为这个东西有点子复杂的，我自己都看半天😁，只知道它接受啥参数就可以了。</p><blockquote><p>观察不难发现</p><ul><li><p>参数中有个<code>flag</code>和<code>key</code>，这俩名字一般是用来区分组件行为的，所以这个组件很可能会有两三个不同的功能</p></li><li><p><code>&#123;...item&#125;</code>和<code>data=&#123;item&#125;</code>这俩玩意传的一摸一样，也可以删去</p></li><li><p>还有一些<code>teacher</code> ,<code>status</code>等可传可不传的<code>props</code>,这些说明组件功能可能有较大差异，可能之后要把它分为多个组件；或者把参数取消，传回调函数，完全受控组件降低耦合度</p></li></ul></blockquote><p>分析完之后，发现任务很艰巨啊，开摆得了（bushi）</p></li><li><p>之后，面对这样艰巨的任务，我一般是先挑软柿子捏，啥事软柿子嘞？</p><p>就是<code>名称</code>，<code>目录结构</code>这些改了无伤大雅但是看着会很舒服的东西🐶</p><blockquote><p>《重构》的作者在书中说： <em><strong>如果有一个人在重构的过程中有一段时间代码无法运行，那他肯定不在重构</strong></em></p><p>因此，咱们重构要一步一步来。</p><p>从<code>名称</code>，<code>目录结构</code>这些“皮毛”的东西开始，保证能正常运行的情况下，一点点慢慢改😝</p></blockquote><p>这里目录结构没啥问题，改个名字就行了，我给它起了个响当当的大名： <code>RerscueInfoItem</code>,之后都用<code>RescueInfoItem</code>代替<code>MsgItem</code></p><p>之后扫一眼代码，发现</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> jiean = param.<span class="hljs-property">status</span>==<span class="hljs-number">1</span>?<span class="hljs-string">&#x27;未结案&#x27;</span>:<span class="hljs-string">&#x27;已结案&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">backgroundColor</span>:color==<span class="hljs-number">2</span>?<span class="hljs-string">&#x27;#76A9FF&#x27;</span>:color==<span class="hljs-number">1</span>?<span class="hljs-string">&#x27;#f9a53e&#x27;</span>:<span class="hljs-string">&#x27;#f57b70&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> status = [<br>            <span class="hljs-string">&#x27;未救援&#x27;</span>,<br>            <span class="hljs-string">&#x27;救援中&#x27;</span>,<br>            <span class="hljs-string">&#x27;已救援&#x27;</span><br>        ]<br><span class="hljs-title function_">setFinish</span>(status[res.<span class="hljs-property">data</span>.<span class="hljs-property">rescue_target_info</span>.<span class="hljs-property">status</span>])<br></code></pre></td></tr></table></figure><p>这种东西，完全可以把它们搞成一个<code>Map</code>,再拿到外边的<code>type</code>或<code>config</code>文件里面嘛</p><p>新开个文件咯,就叫<code>rescueMessageItemTypes</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// rescueMessageItemTypes.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> rescueStatusType = &#123;<br>  <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">rescueStatus</span>: rescueStatusType[] = [<br>  &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;未救援&#x27;</span>,<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#f57b70&#x27;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;救援中&#x27;</span>,<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#f9a53e&#x27;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;已救援&#x27;</span>,<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#76A9FF&#x27;</span>,<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><p>结案这种一下子就搞定而且非常易懂的事情，就不单独拎出来做变量了,改完之后<code>return</code>里就变成这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&lt;<span class="hljs-title class_">View</span> className=<span class="hljs-string">&quot;inline&quot;</span>&gt;<br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;state&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">           <span class="hljs-attr">backgroundColor:</span></span></span><br><span class="hljs-tag"><span class="language-xml">             <span class="hljs-attr">rescueStatus</span>[<span class="hljs-attr">targetInfo</span> ? <span class="hljs-attr">targetInfo.status</span> <span class="hljs-attr">:</span> <span class="hljs-attr">0</span>]<span class="hljs-attr">.color</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">         &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">       &gt;</span></span><br><span class="language-xml">         &#123;rescueStatus[targetInfo ? targetInfo.status : 0].text&#125;</span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;rescued_level&quot;</span>&gt;</span>风险等级：&#123;props.risk_level&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br>     &lt;/<span class="hljs-title class_">View</span>&gt;<br>     <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;rescued_info&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span></span><br><span class="language-xml">           <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;border_l&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>微博内容：</span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demand&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;rescued_city&quot;</span>&gt;</span>地点：&#123;props.area&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>还是聚焦于表面功夫，作为<code>props</code>传进的参数一堆，而且要<code>state</code>数量也不少,影响性能不说，反正是不好看</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [flag,setFlag]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>        <span class="hljs-keyword">const</span> [finish,setFinish]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;已救援&#x27;</span>)<br>      <span class="hljs-comment">//  const [jiean,setJiean]=useState(&#x27;&#x27;)</span><br>        <span class="hljs-keyword">const</span> [color,setColor]=<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">//0:#f57b70  1:#76A9FF 2:#f9a53e</span><br>       <span class="hljs-comment">// const [status,setStatus]=useState(0)</span><br>        <span class="hljs-keyword">const</span> [text,setText]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">const</span> [area,setArea]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">const</span> [level,setLevel]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">const</span> [data,setData]=<span class="hljs-title function_">useState</span>([])<br>        <span class="hljs-keyword">const</span> [ifmine,setIfmine] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)<br><br></code></pre></td></tr></table></figure><p>但是这里很多<code>state</code>只是跟<code>props</code>绑定，而<code>props</code>不会经常改变，因此完全可以去掉这些<code>state</code>，直接使用<code>props</code>,优化性能。</p><p>注意到跳转时传参很多，完全可以采用<code>redux</code>的方式，优化逻辑，把相似的变量和参数都提到外部 </p><p>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// rescueInfoSlice.ts</span><br><br><span class="hljs-keyword">import</span> &#123; createSlice, <span class="hljs-title class_">PayloadAction</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@reduxjs/toolkit&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">SingleRescueInfo</span>,<br>  <span class="hljs-title class_">RescueTargetInfoType</span>,<br>  <span class="hljs-title class_">RescueProcess</span>,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Service/fetchTypes&#x27;</span><br><span class="hljs-keyword">import</span> &#123; rescueInfoSliceType &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sliceTypes&#x27;</span><br><br><span class="hljs-keyword">const</span> rescueInfoSlice = <span class="hljs-title function_">createSlice</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rescueInfo&#x27;</span>,<br>  <span class="hljs-attr">initialState</span>: &#123;<br>    <span class="hljs-attr">rescueInfo</span>: &#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">SingleRescueInfo</span>,<br>    <span class="hljs-attr">targetInfo</span>: &#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">RescueTargetInfoType</span>,<br>    <span class="hljs-attr">process</span>: [],<br>    <span class="hljs-attr">eventID</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">targetID</span>: <span class="hljs-number">0</span>,<br>  &#125; <span class="hljs-keyword">as</span> rescueInfoSliceType,<br>  <span class="hljs-attr">reducers</span>: &#123;<br>    <span class="hljs-attr">updateRescueInfo</span>: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">      state: rescueInfoSliceType,</span></span><br><span class="hljs-params"><span class="hljs-function">      action: PayloadAction&lt;SingleRescueInfo&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    </span>) =&gt;</span> (&#123;<br>      ...state,<br>      <span class="hljs-attr">rescueInfo</span>: action.<span class="hljs-property">payload</span>,<br>      <span class="hljs-attr">eventID</span>: action.<span class="hljs-property">payload</span>.<span class="hljs-property">id</span>,<br>      <span class="hljs-attr">targetID</span>: action.<span class="hljs-property">payload</span>.<span class="hljs-property">rescue_target_id</span>,<br>    &#125;),<br>    <span class="hljs-attr">updateTargetInfo</span>: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">      state: rescueInfoSliceType,</span></span><br><span class="hljs-params"><span class="hljs-function">      action: PayloadAction&lt;RescueTargetInfoType&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    </span>) =&gt;</span> (&#123; ...state, <span class="hljs-attr">targetInfo</span>: action.<span class="hljs-property">payload</span> &#125;),<br>    <span class="hljs-attr">updateProcess</span>: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">      state: rescueInfoSliceType,</span></span><br><span class="hljs-params"><span class="hljs-function">      action: PayloadAction&lt;RescueProcess[]&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    </span>) =&gt;</span> (&#123; ...state, <span class="hljs-attr">process</span>: action.<span class="hljs-property">payload</span> &#125;),<br>  &#125;,<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rescueInfoSlice.<span class="hljs-property">reducer</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; updateTargetInfo, updateRescueInfo, updateProcess &#125; =<br>  rescueInfoSlice.<span class="hljs-property">actions</span><br><br></code></pre></td></tr></table></figure><blockquote><p>这里<code>redux</code>不理解不要紧，主要是理解抽出<code>state</code>的这个思路，减少传参，提升可维护性😊</p><p>现在，只需要一个变量：使用变量只需要从<code>store</code>中取出即可，也不需要另外传参给其余页面。</p></blockquote><p>同时，注意到<code>useEffect</code>中的调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-comment">/* console.log(param.flag) */</span><br>          <span class="hljs-comment">//  setStatus(param.status)//主页item</span><br>        <br>          <span class="hljs-keyword">if</span>(param.<span class="hljs-property">flag</span>==<span class="hljs-string">&#x27;main&#x27;</span>)  <span class="hljs-comment">//主页</span><br>          &#123;<br>            <span class="hljs-title function_">setFlag</span>(<span class="hljs-string">&#x27;alarm&#x27;</span>)<br>            <span class="hljs-keyword">if</span>(param.<span class="hljs-property">ifmine</span>)<br>            &#123;<br>                <span class="hljs-title function_">setIfmine</span>(<span class="hljs-literal">true</span>)<br>                <span class="hljs-title function_">setFinish</span>(<span class="hljs-string">&#x27;救援中&#x27;</span>)<br>                <span class="hljs-title function_">setColor</span>(<span class="hljs-number">1</span>)<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//  未认领的救援</span><br>                <span class="hljs-title function_">setIfmine</span>(<span class="hljs-literal">false</span>)<br>                <span class="hljs-title class_">Fetch</span>(<br>                    <span class="hljs-string">&#x27;/rescue/targetinfo&#x27;</span>,<br>                    &#123;<br>                        <span class="hljs-string">&quot;rescue_target_id&quot;</span>: param.<span class="hljs-property">rescue_target_id</span>,<br>                    &#125;,<br>                    <span class="hljs-string">&#x27;POST&#x27;</span><br>                ).<span class="hljs-title function_">then</span>(<br>                    <span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>                        <span class="hljs-comment">//console.log(res)</span><br>                        <span class="hljs-title function_">setFinish</span>(status[res.<span class="hljs-property">data</span>.<span class="hljs-property">rescue_target_info</span>.<span class="hljs-property">status</span>])<br>                        <span class="hljs-title function_">setColor</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">rescue_target_info</span>.<span class="hljs-property">status</span>)<br>                    &#125;<br>                )<br>          &#125;&#125;<br>          <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//record</span><br>            <span class="hljs-title function_">setFlag</span>(<span class="hljs-string">&#x27;record&#x27;</span>)<br>            <span class="hljs-title function_">setFinish</span>(status[param.<span class="hljs-property">status</span>])<br>            <span class="hljs-title function_">setColor</span>(param.<span class="hljs-property">status</span>)<br>          &#125;<br>            <span class="hljs-title function_">setText</span>(param.<span class="hljs-property">text</span>)<br>            <span class="hljs-title function_">setArea</span>(param.<span class="hljs-property">area</span>)<br>            <span class="hljs-title function_">setLevel</span>(param.<span class="hljs-property">risk_level</span>)<br>            <span class="hljs-title function_">setData</span>(param.<span class="hljs-property">data</span>)<br>        &#125;,[param])<br></code></pre></td></tr></table></figure><p>这些<code>setState</code>都可以省去，但是，很明显，这里逻辑很复杂, 需要重新组织一下逻辑</p><p>这个时候，尘封已久的大脑就要开始转动了：</p><blockquote><p>可以看到，主要是<code>flag</code>这个值是逻辑复杂的开始，根据注释可以知道，写的人当时也很挣扎🐶。</p><p>这可能是因为后端接口的问题，导致主页面上有未认领的任务，需要重新请求才能得到信息。</p><p>然而猛然一看，看到这段，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">if</span>(param.<span class="hljs-property">ifmine</span>)<br>            &#123;<br>                <span class="hljs-title function_">setIfmine</span>(<span class="hljs-literal">true</span>)<br>                <span class="hljs-title function_">setFinish</span>(<span class="hljs-string">&#x27;救援中&#x27;</span>)<br>                <span class="hljs-title function_">setColor</span>(<span class="hljs-number">1</span>)<br>            &#125;<br></code></pre></td></tr></table></figure><p>也没在干什么，所以就索性一视同仁，都发个请求呗</p></blockquote></li><li><p>这个时候，我是喜欢把请求这些东西放到外边去的，搞个<code>service</code>文件夹咯</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /service/fetchType.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">BaseResType</span>&lt;T&gt; = &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">data</span>: T<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> requestType = <span class="hljs-string">&#x27;GET&#x27;</span> | <span class="hljs-string">&#x27;POST&#x27;</span> | <span class="hljs-string">&#x27;PUT&#x27;</span> | <span class="hljs-string">&#x27;DELETE&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RescueTargetInfoResponse</span> &#123;<br>  <span class="hljs-attr">rescue_target_info</span>: <span class="hljs-title class_">RescueTargetInfoType</span><br>&#125;<br><br><span class="hljs-comment">// 这段直接从apifox上copy就行</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RescueTargetInfoType</span> &#123;<br>  <span class="hljs-attr">create_time</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援过程描述</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援结束时间</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">end_time</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 最终评价</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">evalutaion</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援对象id</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援对象昵称（按最新的救援信息数据）</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">nickname</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援老师1id</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">rescue_teacher1_id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援老师1姓名</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">rescue_teacher1_name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援老师1身份</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">rescue_teacher1_role</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援老师2id</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">rescue_teacher2_id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援老师2姓名</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">rescue_teacher2_name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援老师2身份</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">rescue_teacher2_role</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援老师3id</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">rescue_teacher3_id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援老师3姓名</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">rescue_teacher3_name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援老师3身份</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">rescue_teacher3_role</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援起始时间</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">start_time</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援状态（0-待救援 1-救援中 2-已救援）</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">status</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">update_time</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 救援对象微博地址（唯一标识）</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">weibo_address</span>: <span class="hljs-built_in">string</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /service/rescueInfoByID.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">FetchRescueTargetInfo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">targetID: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> data = &#123;<br>    <span class="hljs-attr">rescue_target_id</span>: targetID,<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Fetch</span>&lt;<span class="hljs-title class_">BaseResType</span>&lt;<span class="hljs-title class_">RescueTargetInfoResponse</span>&gt;&gt;(<br>    <span class="hljs-string">&#x27;/rescue/targetinfo&#x27;</span>,<br>    data,<br>    <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>根据它传进来的<code>props</code>,来请求<code>target_info</code>，并且变成<code>state</code>放起来</p><p>这个时候，文件已经开始变得清爽了：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">MsgItem</span>=(<span class="hljs-params">props</span>)=&gt;&#123;<br>  <span class="hljs-keyword">const</span> &#123; navURL, ...restProps &#125; = props<br>  <span class="hljs-keyword">const</span> [targetInfo, setTargetInfo] = useState&lt;<span class="hljs-title class_">RescueTargetInfoType</span>&gt;()<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">FetchRescueTargetInfo</span>(restProps.<span class="hljs-property">rescue_target_id</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setTargetInfo</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">rescue_target_info</span>)<br>    &#125;)<br>  &#125;, [])<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">toR_detail</span>(<span class="hljs-params"></span>)<br>        &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flag)<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-string">&#x27;alarm&#x27;</span>)<br>            <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">navigateTo</span>(&#123;<br>                <span class="hljs-attr">url</span>:<span class="hljs-string">`/moduleA/pages/Alarm/index?ifmine=<span class="hljs-subst">$&#123;ifmine&#125;</span>&amp;data=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(data)&#125;</span>&amp;finish=<span class="hljs-subst">$&#123;finish&#125;</span>&amp;color=<span class="hljs-subst">$&#123;color&#125;</span>`</span><br>            &#125;)<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;todetail&#x27;</span>)<br>                <span class="hljs-keyword">const</span> jiean = param.<span class="hljs-property">status</span>==<span class="hljs-number">1</span>?<span class="hljs-string">&#x27;未结案&#x27;</span>:<span class="hljs-string">&#x27;已结案&#x27;</span><br>                <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">navigateTo</span>(&#123;<br>                    <span class="hljs-attr">url</span>:<span class="hljs-string">`/moduleA/pages/Rescue_detail/index?finish=<span class="hljs-subst">$&#123;jiean&#125;</span>&amp;data=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(data)&#125;</span>&amp;teacher=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(param.teacher)&#125;</span>&amp;lap=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(param.lap)&#125;</span>`</span><br>                &#125;)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;noti-item column&#x27;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toR_detail&#125;</span> &gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;inline&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;state&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">backgroundColor:</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">rescueStatus</span>[<span class="hljs-attr">targetInfo</span> ? <span class="hljs-attr">targetInfo.status</span> <span class="hljs-attr">:</span> <span class="hljs-attr">0</span>]<span class="hljs-attr">.color</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">          &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span></span><br><span class="language-xml">          &#123;rescueStatus[targetInfo ? targetInfo.status : 0].text&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;rescued_level&quot;</span>&gt;</span>风险等级：&#123;props.risk_level&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;rescued_info&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;border_l&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>微博内容：</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demand&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;rescued_city&quot;</span>&gt;</span>地点：&#123;props.area&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br>        )<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来，就剩一个<code>toR_detail</code>函数要改咯，也是撒撒水啦,因为刚刚我们把state都放到外边去了，这里也不用通过传参来让其他页面访问咯，超级爽，略微改改，就这样咯，其中<code>Nav</code>是我封装的跳转函数，因为不想写那么多<code>Taro.navigateTo(&#123;url:&quot;......&quot;&#125;)</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Navi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> navURL_real = navURL || <span class="hljs-string">&#x27;/moduleA/pages/Alarm/index&#x27;</span><br>    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">updateRescueInfo</span>(restProps))<br>    targetInfo &amp;&amp; store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">updateTargetInfo</span>(targetInfo))<br>    <span class="hljs-title class_">Nav</span>(navURL_real)<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>这下就大功告成了，吗？还记得一开始的那些组件传的<code>props</code>吗?也该清清啦！，像什么<code>flag</code>,<code>ifmine</code>,都可以扔掉啦，只留下基本的msg信息就行</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// R_record.jsx </span><br><span class="hljs-comment">// 这里Ritem就是msgItem</span><br>&#123;list?list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Ritem</span> &#123;<span class="hljs-attr">...item</span>&#125; /&gt;</span></span>):<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;img&#x27;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// Main.jsx</span><br>&#123;mine?mine.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MsgItem</span> &#123;<span class="hljs-attr">...item</span>&#125;/&gt;</span></span>)<br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">//Search.jsx </span><br><span class="hljs-comment">// 这段是之前我写的，一坨💩</span><br> &#123;form &amp;&amp; form.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MsgItem</span> &#123;<span class="hljs-attr">...item</span>&#125; /&gt;</span></span>)&#125;<br></code></pre></td></tr></table></figure></li><li><p>现在回头看看我们重构后的组件的全貌吧：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">View</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tarojs/components&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.less&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">RescueMessageItemProps</span>,<br>  rescueStatus,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../types/rescueMessageItemTypes&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Nav</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../utils/taroFunctions&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FetchRescueTargetInfo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../Service/rescueInfoByID&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RescueTargetInfoType</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../Service/fetchTypes&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<br>  updateRescueInfo,<br>  updateTargetInfo,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../slices/rescueInfoSlice&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../store/store&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">RescueMessageItem</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">RescueMessageItemProps</span>&gt; = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; navURL, ...restProps &#125; = props<br>  <span class="hljs-keyword">const</span> [targetInfo, setTargetInfo] = useState&lt;<span class="hljs-title class_">RescueTargetInfoType</span>&gt;()<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">FetchRescueTargetInfo</span>(restProps.<span class="hljs-property">rescue_target_id</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setTargetInfo</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">rescue_target_info</span>)<br>    &#125;)<br>  &#125;, [])<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Navi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> navURL_real = navURL || <span class="hljs-string">&#x27;/moduleA/pages/Alarm/index&#x27;</span><br>    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">updateRescueInfo</span>(restProps))<br>    targetInfo &amp;&amp; store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">updateTargetInfo</span>(targetInfo))<br>    <span class="hljs-title class_">Nav</span>(navURL_real)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;noti-item column&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;Navi&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;inline&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;state&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">backgroundColor:</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">rescueStatus</span>[<span class="hljs-attr">targetInfo</span> ? <span class="hljs-attr">targetInfo.status</span> <span class="hljs-attr">:</span> <span class="hljs-attr">0</span>]<span class="hljs-attr">.color</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">          &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span></span><br><span class="language-xml">          &#123;rescueStatus[targetInfo ? targetInfo.status : 0].text&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;rescued_level&quot;</span>&gt;</span>风险等级：&#123;props.risk_level&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;rescued_info&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;border_l&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>微博内容：</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demand&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;rescued_city&quot;</span>&gt;</span>地点：&#123;props.area&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">RescueMessageItem</span><br><br></code></pre></td></tr></table></figure><p>一共是59行，是不是特别的一目了然，看到之后，心情都变好了，不枉我重构这么久🤗</p></li></ol><h2 id="五、总结⬇️"><a href="#五、总结⬇️" class="headerlink" title="五、总结⬇️"></a>五、总结⬇️</h2><p>在<code>《重构》</code>中，作者提到了<em><strong>营地法则</strong></em>，即<strong>要保证在你来之后，代码变得更好而不是更糟糕</strong>，而保证代码变得更好的秘诀，就是<strong>重构</strong>。这次通过一个小例子，来让大家知道把时间花在重构上并不可怕，经常重构并不见得是一件坏事，相反的，经常重构代表着你在积极思考，努力让代码变得更优秀；而不重构，只能是给未来的自己和同伴添堵咯。当然，过早过频繁的重构也是不提倡的，就比如：本来这个按钮只用负责跳转，你写着写着，突然想到以后要是要让他能点一下出来一个<code>ggbond</code>怎么办，你库库开始重构，重构完之后，一天就过去了。然而产品老板到最后也没有点一下出来一个<code>ggbond</code>的需求（虽然这真的很酷😝）。那这一天就是白费的。总之，重构就是一门艺术，过多过少都不提倡，要根据项目要求，灵活重构。不多说了，这些写多了自然就有感觉啦🤗</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微前端</title>
    <link href="/2024/03/03/micro/"/>
    <url>/2024/03/03/micro/</url>
    
    <content type="html"><![CDATA[<h1 id="微前端入门🍔"><a href="#微前端入门🍔" class="headerlink" title="微前端入门🍔"></a>微前端入门🍔</h1><h2 id="1-啥是微前端？🥰"><a href="#1-啥是微前端？🥰" class="headerlink" title="1. 啥是微前端？🥰"></a>1. 啥是微前端？🥰</h2><p>微前端这个 <code>idea</code> 其实和<code>router</code>一样，也是从后端那里偷过来的。</p><p>偷师的东西你们可能也听说过，就是大名鼎鼎的<code>微服务(micro web service)</code></p><p>那啥是微服务嘞？简单来说，就是把原来庞大的系统，拆成一个个细小的服务，放在<code>分布式系统</code>上边。</p><blockquote><p>举个🌰的话，就相当于你把一整块大列巴切开，然后放在不同的柜子里（大列巴好吃爱吃🥰）</p></blockquote><p>这么说是不是有点概念了，那好，<code>微服务</code>介绍好了，现在就看看咱们的<code>微前端</code>是咋个事咯：</p><ul><li>前边说了这么多，那一想肯定是得把工程拆开咯，现在一般是拆成两个大块：<ul><li>主应用：负责管理各个子应用的<code>生命周期</code>，<code>注册</code></li><li>子应用：具体实现各个页面</li></ul></li></ul><p>在主应用里，可以看到，要干的事情和<code>router</code>是极其类似的，实际上，个人感觉微前端就是<code>router-pro-max</code>，只不过要考虑的方面更加多更加全面，待会再细说</p><h2 id="2-那为啥要用微前端嘞，写一块不好吗？😶"><a href="#2-那为啥要用微前端嘞，写一块不好吗？😶" class="headerlink" title="2. 那为啥要用微前端嘞，写一块不好吗？😶"></a>2. 那为啥要用微前端嘞，写一块不好吗？😶</h2><blockquote><p>还是那个🌰，想一下，你把一块大列巴切开了放可能带来的好处：</p><ul><li>每个柜子的压力会变小</li><li>如果有一块大列巴坏了，其他的也不会受影响</li><li>如果有天想换个口味，那把其中一块大列巴换成土豆，也很方便呀</li></ul></blockquote><p>那就一条一条来看咯：</p><ul><li>把不同页面放到不同服务器上，单个服务器的压力肯定会减小（虽然主要压力不在这）</li><li>如果一个页面出现了问题，其他的页面不受影响，不会像传统单体那样<code>一挂全挂</code></li><li>各个页面独立，出了问题维护很方便</li><li>由于各个页面独立，因此项目可以选用不同的技术栈，比如<code>登录</code>用<code>react</code>写，<code>发帖</code>用<code>vue</code>写；不仅如此，还可以根据需求，灵活选择<code>ssr</code>还是<code>csr</code>，这真的很酷🐶</li></ul><p><strong>但是有优点，就会伴随着难点和缺点</strong></p><ul><li>不同页面如何通信？</li><li>每个页面都有一套依赖库，性能如何优化？如何共享依赖库？</li><li>如何确定应用边界？</li><li>……</li></ul><p>但是这些，今天都不讲😝</p><p>主要原因是我不会，次要原因是太复杂了，讲不完（或许主要原因是这个😙）</p><h2 id="3-目前微前端实现🤩"><a href="#3-目前微前端实现🤩" class="headerlink" title="3. 目前微前端实现🤩"></a>3. 目前微前端实现🤩</h2><p>微前端的实现方案有挺多，比如说：</p><ol><li><a href="https://github.com/umijs/qiankun">qiankun</a>，自己实现 JS 及样式隔离</li><li><a href="https://github.com/ice-lab/icestark">icestark</a>，iframe 方案，浏览器原生隔离，但存在一些问题</li><li><a href="https://github.com/efoxTeam/emp">emp</a>，Webpack 5 Module Federation（联邦模块）方案</li><li>WebComponent 等方案</li></ol><p>但是这么多实现方案解决的场景问题还是分为两类：</p><ul><li>单实例：当前页面只存在一个子应用，一般使用 qiankun 就行</li><li>多实例：当前页面存在多个子应用，可以使用浏览器原生隔离方案，比如 iframe 或者 WebComponent 这些</li></ul><p>当然了，并不是说单实例只能用 qiankun，浏览器原生隔离方案也是可行的，只要你接受它们带来的不足就行：</p><blockquote><p>iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。</p></blockquote><p>上述内容摘自<a href="https://www.yuque.com/kuitos/gky7yw/gesexv">Why Not Iframe</a>。</p><p>本文的实现方案和 qiankun 一致，但是其中涉及到的功能及原理方面的东西都是通用的，你换个实现方案也需要这些。</p><h2 id="4-话不多说，上手吧🥱"><a href="#4-话不多说，上手吧🥱" class="headerlink" title="4. 话不多说，上手吧🥱"></a>4. 话不多说，上手吧🥱</h2><blockquote><p><em><strong>讲讲思路先：</strong></em></p><p>不同页面在不同服务器上，我们通过<code>主应用</code>进入程序，那接下来访问子页面其实要干的事情就是<strong>向子应用的服务器发个请求，拿到它的html\css\js等文件，插入进来执行</strong></p><p>没别的，简单粗暴吧，开干咯</p></blockquote><h3 id="🤗首先，得有个主应用吧"><a href="#🤗首先，得有个主应用吧" class="headerlink" title="🤗首先，得有个主应用吧"></a>🤗首先，得有个主应用吧</h3><p>随随便便创一个得了，跑在<code>5173</code>这个默认口上。</p><p>再随随便便创一个子应用，（我这里子应用还是上次的<code>todo-list</code>），跑在<code>10086</code>端口</p><h3 id="🤔然后，就要动脑子啦，主页面该如何配置子页面呢？"><a href="#🤔然后，就要动脑子啦，主页面该如何配置子页面呢？" class="headerlink" title="🤔然后，就要动脑子啦，主页面该如何配置子页面呢？"></a>🤔然后，就要动脑子啦，主页面该如何配置子页面呢？</h3><p>咱们首先看看子页面需要什么功能咯，记得之前说过和<code>router</code>很相似吗，那就看看<code>router</code>有什么功能咯：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Route</span> exact path=<span class="hljs-string">&quot;/&quot;</span> component=&#123;<span class="hljs-title class_">Home</span>&#125; /&gt;  <br></code></pre></td></tr></table></figure><p>可以看到有: <code>path</code>， 和 <code>component</code>两个<code>prop</code>，</p><p>那在现在的话，就相当于<code>path</code>和<code>子页面服务器路径咯</code></p><blockquote><p>其实叫<code>path</code>有失偏颇，它其实是一个匹配规则，而不是简单的<code>path</code></p><p>所以我接下来采用<code>activateRule</code>代替<code>path</code></p></blockquote><p><em><strong>这就完了？怎么可能！</strong></em></p><p>挂载页面挂载到哪里还没考虑呢！所以还得加一个<code>container</code>属性存放挂载位置,</p><p>那现在我们就有了一个基本的<code>子页面配置</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AppInfo</span> &#123;<br>    <span class="hljs-attr">entry</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">container</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">activeRule</span>: <span class="hljs-built_in">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>这就完了？怎么可能！</strong></em></p><p>开动小脑瓜想想，除了<code>router</code>本身的特性，<code>component</code>也有自己的闪光点：<code>生命周期</code>，页面也是需要生命周期的，而且还要分为</p><ul><li><p>主体生命周期：组件挂载前、挂载完毕、卸载</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /types/type.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">MainLifeCycle</span> = &#123;<br>    beforeLoad?: <span class="hljs-title class_">LifeCycleFunc</span> | <span class="hljs-title class_">LifeCycleFunc</span>[],<br>    mounted?: <span class="hljs-title class_">LifeCycleFunc</span> | <span class="hljs-title class_">LifeCycleFunc</span>[],<br>    unmounted?: <span class="hljs-title class_">LifeCycleFunc</span> | <span class="hljs-title class_">LifeCycleFunc</span>[]<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">LifeCycleFunc</span> = <span class="hljs-function">(<span class="hljs-params">app: AppInfo</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>单独页面声明周期：这个就多了，想要几个要几个，这里图方便，写了三个，跟子页面其他属性混一起得了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /types/type.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChildAppInfo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppInfo</span> &#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-title class_">AppStatus</span>,<br>    bootstrap?: <span class="hljs-title class_">LifeCycleFunc</span>, <span class="hljs-comment">//构建中</span><br>    mount?: <span class="hljs-title class_">LifeCycleFunc</span>, <span class="hljs-comment">// 挂载完毕</span><br>    unmount?: <span class="hljs-title class_">LifeCycleFunc</span>, <span class="hljs-comment">// 卸载</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个<code>status</code>就是组件的详细状态咯，初始值为<code>AppStatus.NOT_LOADED</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /types/enum.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">AppStatus</span> &#123;<br>    <span class="hljs-variable constant_">NOT_LOADED</span> = <span class="hljs-string">&quot;NOT_LOADED&quot;</span>,<br>    <span class="hljs-variable constant_">LOADING</span> = <span class="hljs-string">&quot;LOADING&quot;</span>,<br>    <span class="hljs-variable constant_">LOADED</span> = <span class="hljs-string">&quot;LOADED&quot;</span>,<br>    <span class="hljs-variable constant_">BOOTSTRAPPING</span> = <span class="hljs-string">&quot;BOOTSTRAPPING&quot;</span>,<br>    <span class="hljs-variable constant_">NOT_MOUNTED</span> = <span class="hljs-string">&quot;NOT_MOUNTED&quot;</span>, <span class="hljs-comment">// bootstarp过后还未mount</span><br>    <span class="hljs-variable constant_">MOUNTING</span> = <span class="hljs-string">&quot;MOUNTING&quot;</span>,<br>    <span class="hljs-variable constant_">MOUNTED</span> = <span class="hljs-string">&quot;MOUNTED&quot;</span>,<br>    <span class="hljs-variable constant_">UNMOUNTING</span> = <span class="hljs-string">&quot;UNMOUNTING&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>每次挂载、卸载页面的时候，都要分别调用子页面和主体的的声明周期函数</strong></p><p>为此，封装了几个生命周期的执行函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /lifeCycle/index.ts</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">ChildAppInfo</span>, <span class="hljs-title class_">MainLifeCycle</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../types/type.ts&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">AppStatus</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../types/enum.ts&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;loadHTML&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../loader&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">lifeCycle</span>: <span class="hljs-title class_">MainLifeCycle</span> = &#123;&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">setLifeCycle</span> = (<span class="hljs-params">list: MainLifeCycle</span>) =&gt; &#123;<br>    lifeCycle = list;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">runBeforeLoad</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">app: ChildAppInfo</span>) =&gt; &#123;<br>    app.<span class="hljs-property">status</span> = <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">LOADING</span>;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">runLifeCycle</span>(<span class="hljs-string">&quot;beforeLoad&quot;</span>, app);<br><br>    app = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loadHTML</span>(app); <span class="hljs-comment">// 加载HTML文件的，马上讲</span><br>    app.<span class="hljs-property">status</span> = <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">LOADED</span>;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">runBoostrap</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">app: ChildAppInfo</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (app.<span class="hljs-property">status</span> !== <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">LOADED</span>) &#123;<br>        <span class="hljs-keyword">return</span> app;<br>    &#125;<br>    app.<span class="hljs-property">status</span> = <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">BOOTSTRAPPING</span>;<br>    <span class="hljs-keyword">await</span> app.<span class="hljs-property">bootstrap</span>?.(app);<br>    app.<span class="hljs-property">status</span> = <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">NOT_MOUNTED</span>;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">runMounted</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">app: ChildAppInfo</span>) =&gt; &#123;<br>    app.<span class="hljs-property">status</span> = <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">MOUNTING</span>;<br>    <span class="hljs-keyword">await</span> app.<span class="hljs-property">mount</span>?.(app);<br>    app.<span class="hljs-property">status</span> = <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">MOUNTED</span>;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">runLifeCycle</span>(<span class="hljs-string">&quot;mounted&quot;</span>, app);<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">runUnmounted</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">app: ChildAppInfo</span>) =&gt; &#123;<br>    app.<span class="hljs-property">status</span> = <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">UNMOUNTING</span>;<br>    <span class="hljs-keyword">await</span> app.<span class="hljs-property">unmount</span>?.(app);<br>    app.<span class="hljs-property">status</span> = <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">NOT_MOUNTED</span>;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">runLifeCycle</span>(<span class="hljs-string">&quot;unmounted&quot;</span>, app);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">runLifeCycle</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">name: keyof MainLifeCycle, app: ChildAppInfo</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> fn = lifeCycle[name];<br>    <span class="hljs-keyword">if</span> (fn <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(fn.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-title function_">item</span>(app)));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">await</span> fn?.(app);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>看似很长，其实就是改变<code>子页面</code>的状态，并执行相应的回调函数，再调用<code>主体声明周期</code></p><blockquote><p><strong>注意：</strong></p><p><code>beforeLoad</code>这个生命周期，是在页面挂载之前执行的，所以<code>beforeLoad</code>执行比页面本身生命周期还要前边，<strong>注意执行顺序</strong></p></blockquote><h3 id="相信大家也注意到那个loadHTML了，那就先来讲讲怎么loadHTML吧😏"><a href="#相信大家也注意到那个loadHTML了，那就先来讲讲怎么loadHTML吧😏" class="headerlink" title="相信大家也注意到那个loadHTML了，那就先来讲讲怎么loadHTML吧😏"></a>相信大家也注意到那个<code>loadHTML</code>了，那就先来讲讲怎么<code>loadHTML</code>吧😏</h3><p>其实相当简单，直接向服务器发个<code>fetch</code>就行了，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /loader/index.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadHTML</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">app: ChildAppInfo</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; container, entry &#125; = app<br>    <span class="hljs-keyword">const</span> htmlFile = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchResource</span>(entry)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(htmlFile)<br>    <span class="hljs-keyword">return</span> app<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /utils/fetchHTMlL.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchResource</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">async</span> (res) =&gt; <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">text</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>这就简单完成了一个fetch拿回HTML文件的功能咯，</p><p>那这个函数先放在这里好了，之后再给它丰富功能，比如解析执行js什么的</p><p><em><strong>别忘了解决跨域！！！</strong></em></p><h3 id="写完这么多函数，总得调用一下吧，但是先别急，先把页面啥的挂上去🤨"><a href="#写完这么多函数，总得调用一下吧，但是先别急，先把页面啥的挂上去🤨" class="headerlink" title="写完这么多函数，总得调用一下吧，但是先别急，先把页面啥的挂上去🤨"></a>写完这么多函数，总得调用一下吧，但是先别急，先把页面啥的挂上去🤨</h3><p>简简单单写一个<code>appList</code>，把子页面的配置信息都写里边，到时候<code>forEach</code>就好咯,注意要设置<code>status</code>默认值!</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /appList/index.ts</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">AppInfo</span>, <span class="hljs-title class_">ChildAppInfo</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../types/type.ts&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">AppStatus</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../types/enum.ts&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">appList</span>: <span class="hljs-title class_">AppInfo</span>[] = [];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">setAppList</span> = (<span class="hljs-params">list: AppInfo[]</span>) =&gt; &#123;<br>    appList = list;<br>    appList.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> &#123;<br>        (app <span class="hljs-keyword">as</span> <span class="hljs-title class_">ChildAppInfo</span>).<span class="hljs-property">status</span> = <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">NOT_LOADED</span><br>    &#125;)<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getAppList</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> appList;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后再写一个注册页面的函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /start.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">registerMicroApps</span> = (<span class="hljs-params">appList: AppInfo[], mainLifeCycle?: MainLifeCycle</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setAppList</span>(appList)<br>    mainLifeCycle &amp;&amp; <span class="hljs-title function_">setLifeCycle</span>(mainLifeCycle)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数跟大家想象的不太一样喔，他要在主页面里调用，也就是咱们的<code>react</code>文件中</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// /main.tsx</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.tsx&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span><br><span class="hljs-keyword">import</span> &#123;registerMicroApps, start&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./start.ts&quot;</span>;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)!).<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span>,<br>)<br><br><span class="hljs-keyword">const</span> appList = [<br>    &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;todo&#x27;</span>,<br>        <span class="hljs-attr">activeRule</span>: <span class="hljs-string">&#x27;/todo&#x27;</span>,<br>        <span class="hljs-attr">container</span>: <span class="hljs-string">&#x27;#micro-container&#x27;</span>,<br>        <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;http://localhost:10086&#x27;</span>,<br>    &#125;,<br>]<br><br><span class="hljs-title function_">registerMicroApps</span>(appList)<br></code></pre></td></tr></table></figure><p>到现在为止，咱们已经配置好咱们的子页面啦，现在跑跑看咯！当然什么都没有啦！页面还没挂上呢，声明周期也没加，文件也没获取，还有好长的路要走😣</p><h3 id="考虑一个问题，如何在appList中挑出要渲染的页面嘞？🥲"><a href="#考虑一个问题，如何在appList中挑出要渲染的页面嘞？🥲" class="headerlink" title="考虑一个问题，如何在appList中挑出要渲染的页面嘞？🥲"></a>考虑一个问题，如何在appList中挑出要渲染的页面嘞？🥲</h3><p>捋捋思路：</p><p>咱们的子页面配置里不是有<code>actiavteRule</code>这一项吗，就用它!</p><p>把<code>appList</code>遍历一遍，如果<code>activateRule</code>匹配当前路径的话，要做点什么；如果不匹配的话，可能也要做点什么（废话）</p><blockquote><p>仔细想想咯，当切换页面的时候，比如说从<code>/</code>切换到<code>/todo</code>，是不是要把原来的页面先<code>unmount</code>，再去<code>mount</code>新页面；那如何判断哪个页面是当前页面呢？或者说，如何匹配当前页面呢？</p><p>欸，<code>react-router-dom</code>使用了<a href="https://www.npmjs.com/package/path-to-regexp">path-to-regexp</a>这个库，看了下，相当好用,感兴趣的可以看看，但是我们现在只需要知道它的一个调用就行了：</p><p><img src="https://s2.loli.net/2024/03/03/78UYVOkJB6XxmHp.png" alt="别人博客偷的图"></p><p>再加上<code>location.href</code>，我们很容易能写出</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> isActive = <span class="hljs-title function_">match</span>(app.<span class="hljs-property">activeRule</span>, &#123; <span class="hljs-attr">end</span>: <span class="hljs-literal">false</span> &#125;)(location.<span class="hljs-property">pathname</span>)<br></code></pre></td></tr></table></figure><p>判断是否<code>active</code>，再根据页面当前状态，判断要做什么操作，是挂载还是卸载</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /utils/getAppStatus.ts</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">ChildAppInfo</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../types/type.ts&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;getAppList&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../appList&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">AppStatus</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../types/enum.ts&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;match&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path-to-regexp&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getAppListStatus</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">actives</span>: <span class="hljs-title class_">ChildAppInfo</span>[] = []<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">unmounts</span>: <span class="hljs-title class_">ChildAppInfo</span>[] = []<br>    <span class="hljs-keyword">const</span> list = <span class="hljs-title function_">getAppList</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">ChildAppInfo</span>[]<br>    list.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> isActive = <span class="hljs-title function_">match</span>(app.<span class="hljs-property">activeRule</span>, &#123; <span class="hljs-attr">end</span>: <span class="hljs-literal">false</span> &#125;)(location.<span class="hljs-property">pathname</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isActive, app)<br>        <span class="hljs-keyword">switch</span> (app.<span class="hljs-property">status</span>) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">NOT_LOADED</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">LOADING</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">LOADED</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">BOOTSTRAPPING</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">NOT_MOUNTED</span>:<br>                isActive &amp;&amp; actives.<span class="hljs-title function_">push</span>(app)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-title class_">AppStatus</span>.<span class="hljs-property">MOUNTED</span>:<br>                !isActive &amp;&amp; unmounts.<span class="hljs-title function_">push</span>(app)<br>                <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> &#123; actives, unmounts &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这个工具函数，我们就得到了<code>actives</code> 和<code>unmounts</code>这俩数组，之后对<code>unmounts</code>数组以此<code>unmount</code>，对<code>actives</code>依次执行一套声明周期就完事咯，用伪代码大概是这个样子，到时候把这个封装进函数就行咯</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> &#123; actives, unmounts &#125; = <span class="hljs-title function_">getAppListStatus</span>()<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>            unmounts<br>                .<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (<span class="hljs-attr">app</span>: <span class="hljs-title class_">ChildAppInfo</span>) =&gt; &#123;<br>                    <span class="hljs-keyword">await</span> <span class="hljs-title function_">runUnmounted</span>(app)<br>                &#125;)<br>                .<span class="hljs-title function_">concat</span>(<br>                    actives.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (<span class="hljs-attr">app</span>: <span class="hljs-title class_">ChildAppInfo</span>) =&gt; &#123;<br>                        <span class="hljs-keyword">await</span> <span class="hljs-title function_">runBeforeLoad</span>(app)<br>                        <span class="hljs-keyword">await</span> <span class="hljs-title function_">runBoostrap</span>(app)<br>                        <span class="hljs-keyword">await</span> <span class="hljs-title function_">runMounted</span>(app)<br>                    &#125;)<br>                )<br>        ).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// ...要做的操作</span><br>        &#125;)<br></code></pre></td></tr></table></figure><h3 id="别看现在形式一片大好，其实真正的难点还藏着呢🙄路由劫持来咯"><a href="#别看现在形式一片大好，其实真正的难点还藏着呢🙄路由劫持来咯" class="headerlink" title="别看现在形式一片大好，其实真正的难点还藏着呢🙄路由劫持来咯"></a>别看现在形式一片大好，其实真正的难点还藏着呢🙄路由劫持来咯</h3><p>其实这个难点就是最基础的–<strong>如何根据url加载和切换页面？</strong></p><p>嘿嘿，这就是另一个知识点咯</p><blockquote><p>想想<code>React-Router-Dom</code>中是不是有<code>BrowserRouter</code>和<code>HashRouter</code>，其实他俩就对应着 JS 中 的<code>HashRouter</code>和<code>History</code>，二者有些许差别。老web通常是<code>HashRouter</code>，新web基本都是<code>History</code>。二者api也有差异，我就不自己写了，以下内容摘自：<a href="https://juejin.cn/post/7044530785746944014">https://juejin.cn/post/7044530785746944014</a></p></blockquote><h3 id="reactRouter实现路由的两种模式"><a href="#reactRouter实现路由的两种模式" class="headerlink" title="reactRouter实现路由的两种模式"></a>reactRouter实现路由的两种模式</h3><ul><li><p>hash模式(对应HashRouter)</p><p><code>www.test.com/#/name</code> 就是 <code>Hash URL</code>，当 <code>#</code> 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 <code>hashchange</code> 事件来监听到 <code>URL</code> 的变化，从而进行跳转页面。</p></li><li><p>browser模式(对应BrowserRouter)</p><p><code>History</code>模式使用 HTML5 提供的 history API（pushState、replaceState 和 popstate 事件）来保持 UI 和 URL 的同步</p></li></ul><h3 id="两种实现方式的区别是什么？"><a href="#两种实现方式的区别是什么？" class="headerlink" title="两种实现方式的区别是什么？"></a>两种实现方式的区别是什么？</h3><ul><li><p>兼容性问题</p><p>一看到browser模式是html5新推出的功能，就可以知道区别主要是<code>兼容性</code>问题，browser模式主要是在高版本浏览器使用的，hash模式主要是在老版本浏览器使用的，</p></li><li><p>写法的不同</p><p>BrowserRouter 创建的 URL 格式：<a href="https://link.juejin.cn/?target=http://xxx.com/path">xxx.com&#x2F;path</a></p><p>HashRouter 创建的 URL 格式：<a href="https://link.juejin.cn/?target=http://xxx.com/%23/path">xxx.com&#x2F;#&#x2F;path</a></p></li></ul><h3 id="history中新增的方法"><a href="#history中新增的方法" class="headerlink" title="history中新增的方法"></a>history中新增的方法</h3><h4 id="pushState-state-title-url"><a href="#pushState-state-title-url" class="headerlink" title="pushState(state,title,url)"></a>pushState(state,title,url)</h4><p>该方法的作用是 在历史记录中新增一条记录，改变浏览器地址栏的url,<strong>但是，不刷新页面</strong>。</p><p>pushState对象接受三个参数，</p><ul><li>state：一个与添加的记录相关联的状态对象，主要用于popstate事件。该事件触发时，该对象会传入回调<a href="https://link.juejin.cn/?target=http://www.fly63.com/tag/%E5%87%BD%E6%95%B0">函数</a>。也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。如果不需要这个对象，此处可以填null。</li><li>title：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。</li><li>url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</li></ul><p>举个例子，假设当前网址是hello.com&#x2F;1.html,使用pushState()方法在浏览记录中添加一个新纪录</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp复制代码<span class="hljs-keyword">var</span> stateObj=&#123;foo:<span class="hljs-string">&#x27;bar&#x27;</span>&#125;<br>history.pushState(starteObj,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;2.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>添加新纪录后，浏览器的地址栏立刻显示&#96;hello.com&#x2F;2.html,但不会跳转到2.html,也不会检查2.html是否存在，它只是成为浏览历史中的最新记录。</p><p>总之，pushState()方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应，使用该方法后，就可以使用history.state属性读出状态对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp复制代码<span class="hljs-keyword">var</span> stateObj=&#123;foo:<span class="hljs-string">&#x27;bar&#x27;</span>&#125;<br>history.pushState(starteObj,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;2.html&#x27;</span>)<br>history.state <span class="hljs-comment">//=&gt; &#123;foo:&quot;bar&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>注意：如果pushState的URL参数设置了一个新的hash值，并不会触发hashchange事件。</p><h4 id="replaceState-state-title-url"><a href="#replaceState-state-title-url" class="headerlink" title="replaceState(state,title,url)"></a>replaceState(state,title,url)</h4><p>replaceState方法的作用是替换当前的历史记录，其他的都与pushState()方法一模一样。</p><p>假定当前网页是example.com&#x2F;example.html。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ruby">ruby复制代码history.pushState(&#123;<span class="hljs-symbol">page:</span> <span class="hljs-number">1</span>&#125;, <span class="hljs-string">&#x27;title 1&#x27;</span>, <span class="hljs-string">&#x27;?page=1&#x27;</span>)<br>/<span class="hljs-regexp">/ URL 显示为 http:/</span><span class="hljs-regexp">/example.com/example</span>.html?page=<span class="hljs-number">1</span><br><br>history.pushState(&#123;<span class="hljs-symbol">page:</span> <span class="hljs-number">2</span>&#125;, <span class="hljs-string">&#x27;title 2&#x27;</span>, <span class="hljs-string">&#x27;?page=2&#x27;</span>);<br><span class="hljs-regexp">//</span> <span class="hljs-variable constant_">URL</span> 显示为 <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/example.com/example</span>.html?page=<span class="hljs-number">2</span><br><br>history.replaceState(&#123;<span class="hljs-symbol">page:</span> <span class="hljs-number">3</span>&#125;, <span class="hljs-string">&#x27;title 3&#x27;</span>, <span class="hljs-string">&#x27;?page=3&#x27;</span>);<br><span class="hljs-regexp">//</span> <span class="hljs-variable constant_">URL</span> 显示为 <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/example.com/example</span>.html?page=<span class="hljs-number">3</span><br><br>history.back()<br>/<span class="hljs-regexp">/ URL 显示为 http:/</span><span class="hljs-regexp">/example.com/example</span>.html?page=<span class="hljs-number">1</span><br><br>history.back()<br>/<span class="hljs-regexp">/ URL 显示为 http:/</span><span class="hljs-regexp">/example.com/example</span>.html<br><br>history.go(<span class="hljs-number">2</span>)<br>/<span class="hljs-regexp">/ URL 显示为 http:/</span><span class="hljs-regexp">/example.com/example</span>.html?page=<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="popstate事件"><a href="#popstate事件" class="headerlink" title="popstate事件"></a>popstate事件</h4><blockquote><p>popstate事件是window对象上的事件，配合pushState()和replaceState()方法使用。当同一个文档(可以理解为同一个网页，不能跳转，跳转了就不是同一个网页了)的浏览历史出现变化时，就会触发popstate事件。</p></blockquote><p>上面我们说过，调用pushState()或者replaceState()方法都会改变当前的历史记录，仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件，另外一个条件是用户必须点击浏览器的倒退按钮或者前进按钮，或者使用<a href="https://link.juejin.cn/?target=https://www.fly63.com/tag/js">js</a>调用history.back()或者history.forward()等方法。</p><p>所以，记住popstate事件触发的条件</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 处在同一个文档(同一个html页面)<br><span class="hljs-bullet">2.</span> 文档的浏览历史(即history对象)发生改变<br></code></pre></td></tr></table></figure><p>只要符合这两个条件，popstate事件就会触发</p><p>具体例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">//index.html<br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onpopstate</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;location &#x27;</span>+<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>+<span class="hljs-string">&#x27;,state &#x27;</span>+jsON.<span class="hljs-title function_">stringify</span>(event.<span class="hljs-property">state</span>))</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--第二步 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;window.history.back()&quot;</span>&gt;</span>后退<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;window.history.forward()&quot;</span>&gt;</span>前进<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--第一步 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;window.history.pushState(null,&#x27;&#x27;,&#x27;1.html&#x27;)&quot;</span>&gt;</span>pushState<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>先点击pushState按钮，在点击后退按钮，就会触发popstate事件</p><p>再来一个例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">//index.html<br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onpopstate</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;location &#x27;</span>+<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>+<span class="hljs-string">&#x27;,state &#x27;</span>+<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(event.<span class="hljs-property">state</span>))</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#one&quot;</span>&gt;</span>#one<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>   <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>直接点击a标签,也可以触发popstate事件</p><blockquote><p>OK,我来总结一下，老版<code>hashRouter</code>只拥有<code>hashChange</code>这一个监听，而在<code>history</code>中，把这个监听拆成了两部分：</p><ul><li><code>(push | replace)State</code>:负责切换路由，但不重新渲染</li><li><code>popState</code>: 触发事件</li></ul><p>所以我们要干的，就是让我们<code>pushState</code>的时候，触发<code>popState</code>或者<code>hashChange</code>,调用我们自己的函数: 把子页面拉过来，也就是重写这几个函数，他有个响亮的名字： <strong>路由劫持</strong></p></blockquote><p>那既然要重写listener，那肯定就都得自己维护一个队列咯，大概就长这样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /route/index.ts</span><br><span class="hljs-keyword">const</span> listenedRouterChange : <span class="hljs-title class_">Record</span>&lt;listenedType, <span class="hljs-title class_">Function</span>[]&gt; = &#123;<br>    <span class="hljs-attr">hashchange</span>: [],<br>    <span class="hljs-attr">popstate</span>:[]<br>&#125;<br></code></pre></td></tr></table></figure><p>那每次<code>pushState</code>或者<code>replaceState</code>就得触发<code>popState</code>，就要监听<code>popState</code>往这加东西咯，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /route/index.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">Route</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-property">pushState</span> = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>        originalPush.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>, args)<br>        historyEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PopStateEvent</span>(<span class="hljs-string">&#x27;popstate&#x27;</span>)<br>        args[<span class="hljs-number">2</span>] &amp;&amp; <span class="hljs-title function_">reroute</span>(args[<span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>) <span class="hljs-comment">// args[2]就是传入的url</span><br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-property">replaceState</span> = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>        originalReplace.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>, args)<br>        historyEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PopStateEvent</span>(<span class="hljs-string">&#x27;popstate&#x27;</span>)<br>        args[<span class="hljs-number">2</span>] &amp;&amp; <span class="hljs-title function_">reroute</span>(args[<span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>)<br>    &#125;<br><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;hashchange&quot;</span>, handleUrlChange)<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;popstate&quot;</span>, handleUrlChange)<br><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">addEventListener</span> = <span class="hljs-title class_">EventListener</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">addEventListener</span>)<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">removeEventListener</span> = <span class="hljs-title class_">EventListener</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">removeEventListener</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>因为要重新监听<code>hashChange</code>和<code>popState</code>，我们重新定义<code>EventListener</code>,让这俩事件触发时，往<code>listendRouterChange</code>里加点料</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /route/index.ts</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">hasListener</span> = (<span class="hljs-params">name: listenedType, fn: <span class="hljs-built_in">Function</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> listenedRouterChange[name].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item === fn).<span class="hljs-property">length</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventListener</span> = (<span class="hljs-attr">fn</span>: <span class="hljs-title class_">Function</span>): <span class="hljs-function"><span class="hljs-params">any</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">name: <span class="hljs-built_in">string</span>, func: <span class="hljs-built_in">Function</span></span>) &#123;<br>        <span class="hljs-keyword">if</span>(name === <span class="hljs-string">&quot;popstate&quot;</span> || name === <span class="hljs-string">&quot;hashchange&quot;</span>) &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">hasListener</span>(name, func)) &#123;<br>                listenedRouterChange[name <span class="hljs-keyword">as</span> listenedType].<span class="hljs-title function_">push</span>(func)<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <br><br>        &#125;<br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">window</span>, <span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，<code>pushState</code>的时候要挂载页面，可以看到，这里用的是<code>reroute</code>这个函数，记得之前的页面挂载函数吗,实现一下咯</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /route/index.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">reroute</span> = (<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (url !== lastUrl) &#123;<br>        <span class="hljs-keyword">const</span> &#123; actives, unmounts &#125; = <span class="hljs-title function_">getAppListStatus</span>()<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>            unmounts<br>                .<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (<span class="hljs-attr">app</span>: <span class="hljs-title class_">ChildAppInfo</span>) =&gt; &#123;<br>                    <span class="hljs-keyword">await</span> <span class="hljs-title function_">runUnmounted</span>(app)<br>                &#125;)<br>                .<span class="hljs-title function_">concat</span>(<br>                    actives.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (<span class="hljs-attr">app</span>: <span class="hljs-title class_">ChildAppInfo</span>) =&gt; &#123;<br>                        <span class="hljs-keyword">await</span> <span class="hljs-title function_">runBeforeLoad</span>(app)<br>                        <span class="hljs-keyword">await</span> <span class="hljs-title function_">runBoostrap</span>(app)<br>                        <span class="hljs-keyword">await</span> <span class="hljs-title function_">runMounted</span>(app)<br>                    &#125;)<br>                )<br>        ).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">callCapturedListeners</span>() <span class="hljs-comment">//挂上之后执行回调</span><br>        &#125;)<br>    &#125;<br>    lastUrl = url || location.<span class="hljs-property">href</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callCapturedListeners</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (historyEvent) &#123;<br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(listenedRouterChange).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">eventName</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> listeners = listenedRouterChange[eventName <span class="hljs-keyword">as</span> listenedType]<br>            <span class="hljs-keyword">if</span> (listeners.<span class="hljs-property">length</span>) &#123;<br>                listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">listener</span>) =&gt;</span> &#123;<br>                    listener.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, historyEvent)<br>                &#125;)<br>            &#125;<br>        &#125;)<br>        historyEvent = <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="最后，来看看文件加载吧，快结束咯😏"><a href="#最后，来看看文件加载吧，快结束咯😏" class="headerlink" title="最后，来看看文件加载吧，快结束咯😏"></a>最后，来看看文件加载吧，快结束咯😏</h3><p><strong>首先的首先，就是跨域问题</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-react&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:10086&quot;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&quot;&quot;</span>),<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;)<br><br></code></pre></td></tr></table></figure><p><strong>之后又要动脑咯，资源怎么加载嘞？</strong></p><p>首先，咱们上边提到的的<code>html</code>文件中肯定有引入的文件需要加载，可能是图片，也可能是<code>css</code>、 <code>js</code>,这里就要做一个判断：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/loader/parse.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">parseHTML</span> = (<span class="hljs-params">parent: HTMLElement, app: IInternalAppInfo</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> children = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(parent.<span class="hljs-property">children</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>[]<br>  children.<span class="hljs-property">length</span> &amp;&amp; children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-title function_">parseHTML</span>(item, app))<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dom <span class="hljs-keyword">of</span> children) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(link)$/i</span>.<span class="hljs-title function_">test</span>(dom.<span class="hljs-property">tagName</span>)) &#123;<br>      <span class="hljs-comment">// 处理 link</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(script)$/i</span>.<span class="hljs-title function_">test</span>(dom.<span class="hljs-property">tagName</span>)) &#123;<br>      <span class="hljs-comment">// 处理 script</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(img)$/i</span>.<span class="hljs-title function_">test</span>(dom.<span class="hljs-property">tagName</span>) &amp;&amp; dom.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>)) &#123;<br>      <span class="hljs-comment">// 处理图片，毕竟图片资源用相对路径肯定也 404 了</span><br>      dom.<span class="hljs-title function_">setAttribute</span>(<br>        <span class="hljs-string">&#x27;src&#x27;</span>,<br>        <span class="hljs-title function_">getCompletionURL</span>(dom.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>)!, app.<span class="hljs-property">entry</span>)!<br>      )<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>对于<code>link</code>文件，它可能是外部引入，也可能是本地引用</p><ul><li><p>对于本地引用：要把相对路径转为绝对路径</p></li><li><p>对于外部引入：不变</p><p>就这样⬇️</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">parseLink</span> = (<span class="hljs-params"></span><br><span class="hljs-params">    link: HTMLElement,</span><br><span class="hljs-params">    parent: HTMLElement,</span><br><span class="hljs-params">    app: ChildAppInfo</span><br><span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> rel = link.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;rel&#x27;</span>)<br>    <span class="hljs-keyword">const</span> href = link.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (rel === <span class="hljs-string">&#x27;stylesheet&#x27;</span> &amp;&amp; href) &#123;<br>        parent.<span class="hljs-title function_">appendChild</span>(link)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getCompletionURL</span>(href, app.<span class="hljs-property">entry</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (href) &#123;<br>        link.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-title function_">getCompletionURL</span>(href, app.<span class="hljs-property">entry</span>)!)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /utils/concatUrl.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCompletionURL</span>(<span class="hljs-params">src: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>, baseURI: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!src) <span class="hljs-keyword">return</span> src<br>    <span class="hljs-comment">// 如果 URL 已经是协议开头就直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(https|http)/</span>.<span class="hljs-title function_">test</span>(src)) <span class="hljs-keyword">return</span> src<br>    <span class="hljs-comment">// 通过原生方法拼接 URL</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(src, <span class="hljs-title function_">getCompletionBaseURL</span>(baseURI)).<span class="hljs-title function_">toString</span>()<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCompletionBaseURL</span>(<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> url.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;//&#x27;</span>) ? <span class="hljs-string">`<span class="hljs-subst">$&#123;location.protocol&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span> : url<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>对于<code>script</code>文件，也有两种情况，外部引入的话还要额外<code>fetch</code>一次，这里用<code>url</code>表示外联，<code>text</code>如果有那就是内联</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">parseScript</span> = (<span class="hljs-params"></span><br><span class="hljs-params">    script: HTMLElement,</span><br><span class="hljs-params">    parent: HTMLElement,</span><br><span class="hljs-params">    app: ChildAppInfo</span><br><span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> src = script.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>)<br>    parent.<span class="hljs-title function_">appendChild</span>(script)<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">url</span>: <span class="hljs-title function_">getCompletionURL</span>(src, app.<span class="hljs-property">entry</span>), <span class="hljs-attr">text</span>: script.<span class="hljs-property">innerHTML</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>合并起来就是这样咯：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">scripts</span>: <span class="hljs-built_in">string</span>[] = []<br><span class="hljs-keyword">const</span> <span class="hljs-attr">links</span>: <span class="hljs-built_in">string</span>[] = []<br><span class="hljs-keyword">const</span> <span class="hljs-attr">inlineScript</span>: <span class="hljs-built_in">string</span>[] = []<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">parseHTML</span> = (<span class="hljs-params">parent: HTMLElement, app: ChildAppInfo</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> children = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(parent.<span class="hljs-property">children</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>[]<br>    children.<span class="hljs-property">length</span> &amp;&amp; children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-title function_">parseHTML</span>(item, app))<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dom <span class="hljs-keyword">of</span> children) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(link)$/i</span>.<span class="hljs-title function_">test</span>(dom.<span class="hljs-property">tagName</span>)) &#123;<br>            <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">parseLink</span>(dom, parent, app)<br>            data &amp;&amp; links.<span class="hljs-title function_">push</span>(data)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(script)$/i</span>.<span class="hljs-title function_">test</span>(dom.<span class="hljs-property">tagName</span>)) &#123;<br>            <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">parseScript</span>(dom, parent, app)<br>            data.<span class="hljs-property">text</span> &amp;&amp; inlineScript.<span class="hljs-title function_">push</span>(data.<span class="hljs-property">text</span>)<br>            data.<span class="hljs-property">url</span> &amp;&amp; scripts.<span class="hljs-title function_">push</span>(data.<span class="hljs-property">url</span>)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(img)$/i</span>.<span class="hljs-title function_">test</span>(dom.<span class="hljs-property">tagName</span>) &amp;&amp; dom.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>)) &#123;<br>            dom.<span class="hljs-title function_">setAttribute</span>(<br>                <span class="hljs-string">&#x27;src&#x27;</span>,<br>                <span class="hljs-title function_">getCompletionURL</span>(dom.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>)!, app.<span class="hljs-property">entry</span>)!<br>            )<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123; scripts, links, inlineScript &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，前端就是轮子多，这些其实都不用自己写的，有个<a href="https://www.npmjs.com/package/import-html-entry">import-html-entry</a>库可以直接用，嘎嘎爽</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> &#123; template, getExternalScripts, getExternalStyleSheets &#125; =<br>   <span class="hljs-keyword">await</span> importEntry(entry)<br></code></pre></td></tr></table></figure><h3 id="文件加载完，就要运行js咯，这回是真快了！😝"><a href="#文件加载完，就要运行js咯，这回是真快了！😝" class="headerlink" title="文件加载完，就要运行js咯，这回是真快了！😝"></a>文件加载完，就要运行js咯，这回是真快了！😝</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// /loader/index.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadHTML</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">app: ChildAppInfo</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; container, entry &#125; = app<br>    <span class="hljs-keyword">const</span> &#123; template, getExternalScripts, getExternalStyleSheets &#125; =<br>        <span class="hljs-keyword">await</span> importEntry(entry)<br>    <span class="hljs-keyword">const</span> dom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(container)<br><br>    <span class="hljs-keyword">if</span> (!dom) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;容器不存在&#x27;</span>)<br>    &#125;<br><br>    dom.<span class="hljs-property">innerHTML</span> = template<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dom.<span class="hljs-property">innerHTML</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">getExternalStyleSheets</span>()<br>    <span class="hljs-keyword">const</span> jsCode = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getExternalScripts</span>()<br><br>    jsCode.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">script</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> lifeCycle = <span class="hljs-title function_">runJS</span>(script, app)<br>        <span class="hljs-keyword">if</span> (lifeCycle) &#123;<br>            app.<span class="hljs-property">bootstrap</span> = lifeCycle.<span class="hljs-property">bootstrap</span><br>            app.<span class="hljs-property">mount</span> = lifeCycle.<span class="hljs-property">mount</span><br>            app.<span class="hljs-property">unmount</span> = lifeCycle.<span class="hljs-property">unmount</span><br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> app<br>&#125;<br></code></pre></td></tr></table></figure><p>本来打算这么跑的，但是没跑成，晚上回去看看咋个事，反正就是把js拿出来执行，就这个意思</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redux</title>
    <link href="/2024/02/04/redux/"/>
    <url>/2024/02/04/redux/</url>
    
    <content type="html"><![CDATA[<h1 id="Redux-和-useReducer-😍"><a href="#Redux-和-useReducer-😍" class="headerlink" title="Redux 和 useReducer 😍"></a>Redux 和 useReducer 😍</h1><h2 id="一、Redux-的来头🤡"><a href="#一、Redux-的来头🤡" class="headerlink" title="一、Redux 的来头🤡"></a>一、Redux 的来头🤡</h2><p>相信大家在写这个 <code>todoList</code> 的时候，发现这个玩意要比其他的难写，为什么嘞？</p><p>![大家应该都是这样简单拆分组件的吧(❁´◡&#96;❁)](<a href="https://i2.100024.xyz/2024/02/04/kgsr53.webp">https://i2.100024.xyz/2024/02/04/kgsr53.webp</a>)</p><p>可以看到，这个组件<em><strong>视觉上</strong></em>分为三个部分，但是这三个部分会<em><strong>相互影响</strong></em>, 这就导致如果设计不好的话，状态满天飞，组件间通信来通信去是个大问题。</p><p>看大家基本都想到把状态提升到全局来解决这个问题，这<strong>确实挺不错</strong>的😍</p><p>这其实就有一点类似于<code>redux</code>的理念了： <em><strong>找个地方专门管理状态，让组件内部逻辑更清晰</strong></em>，这在大工程里会相当相当有用</p><p>是不是不敢想象在组件外的状态会有多酷？🤩继续往下看吧</p><blockquote><p><img src="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" alt="Redux 理念:"></p></blockquote><h2 id="二、-Redux下载😊"><a href="#二、-Redux下载😊" class="headerlink" title="二、 Redux下载😊"></a>二、 Redux下载😊</h2><p>还是老样子，npm梭哈</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install redux<br></code></pre></td></tr></table></figure><blockquote><p>其实这个包可以不要的，这个包超级麻烦👽</p><p><code>redux</code>官方也注意到这个问题，于是就出了一个小甜甜： <code>@reduxjs/toolkit</code>来取代这位牛夫人</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install @reduxjs/toolkit<br></code></pre></td></tr></table></figure><p>现在更推荐这个哇🐶</p></blockquote><p>如果要在咱的<code>react</code>项目中用，还得下一个<code>react-redux</code>包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install react-redux<br></code></pre></td></tr></table></figure><h2 id="三、Redux文件结构👾"><a href="#三、Redux文件结构👾" class="headerlink" title="三、Redux文件结构👾"></a>三、Redux文件结构👾</h2><p>传统<code>Redux</code>结构</p><blockquote><p>src&#x2F;<br>|– actions&#x2F;<br>|   |– counterActions.js<br>|– reducers&#x2F;<br>|   |– counterReducer.js<br>|– store&#x2F;<br>|   |– configureStore.js<br>|– components&#x2F;<br>|   |– Counter.js<br>|   |– App.js<br>|– index.js</p></blockquote><p>都什么年代了，还在玩传统<code>redux</code>?😓</p><p>有了<code>redux-toolkit</code>之后，那可是变了天了</p><blockquote><p>src&#x2F;<br>|– slices&#x2F;<br>|   |– counterSlice.js<br>|– store&#x2F;<br>|   |– configureStore.js<br>|– components&#x2F;<br>|   |– Counter.js<br>|   |– App.js<br>|– index.js</p></blockquote><p>可以看到，多出来一个<code>slices</code>，少掉了<code>reducer</code>和<code>action</code>，这是因为<code>toolkit</code>中的<code>slices</code>把这两个功能自动搞好了，这样我们写起来也超级方便，超级爱😍</p><h2 id="四、redux用法💩"><a href="#四、redux用法💩" class="headerlink" title="四、redux用法💩"></a>四、<code>redux</code>用法💩</h2><ol><li><p>首先，使用<code>createSlice</code>方法，创建一个<code>slice</code>， 包括它的</p><ul><li>名称<code>name</code>，</li><li>初始状态<code>initialState</code>,</li><li><code>action</code>的创建函数<code>reducers</code>（不知道为啥要叫<code>reducer</code>根本就不沾一点边😡）</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123;createSlice, <span class="hljs-title class_">PayloadAction</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;itemType&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../pages/listType.ts&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;autoKey&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../utils/geneKeys.ts&quot;</span>;<br><br><span class="hljs-keyword">const</span> listInfoSlice = <span class="hljs-title function_">createSlice</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;listInfo&#x27;</span>,<br>    <span class="hljs-attr">initialState</span>: [] <span class="hljs-keyword">as</span> itemType[],<br>    <span class="hljs-attr">reducers</span>: &#123;<br>        <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">state: itemType[], action: PayloadAction&lt;<span class="hljs-built_in">string</span>&gt;</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> state.<span class="hljs-title function_">concat</span>(&#123;<br>                <span class="hljs-attr">value</span>: action.<span class="hljs-property">payload</span>,<br>                <span class="hljs-attr">key</span>: autoKey.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>,<br>                <span class="hljs-attr">isCompleted</span>: <span class="hljs-literal">false</span>,<br>            &#125;);<br>        &#125;,<br>        <span class="hljs-attr">dele</span>: <span class="hljs-function">(<span class="hljs-params">state: itemType[], action: PayloadAction&lt;<span class="hljs-built_in">number</span>&gt;</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> state.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">key</span> != action.<span class="hljs-property">payload</span>)<br>        &#125;,<br>        ...<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> listActions = listInfoSlice.<span class="hljs-property">actions</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> listInfoSlice.<span class="hljs-property">reducer</span><br></code></pre></td></tr></table></figure><blockquote><p>传参数可以看到是通过 <code>action</code>传递的，可以指定参数类型，相当不错</p></blockquote></li><li><p>然后，通过<code>configureStore</code>创建一个<code>store</code>来管理存储这个<code>state</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;configureStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;<br><span class="hljs-keyword">import</span> listInfoReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../slices/listInfoSlice.ts&quot;</span>;<br><span class="hljs-keyword">import</span> displayReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../slices/displaySlice.ts&quot;</span>;<br><br><span class="hljs-keyword">const</span> todoStore = <span class="hljs-title function_">configureStore</span>(&#123;<br>    <span class="hljs-attr">reducer</span>: &#123;<br>        <span class="hljs-attr">listReducer</span>: listInfoReducer,<br>        <span class="hljs-attr">displayReducer</span>: displayReducer<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> todoStore<br></code></pre></td></tr></table></figure></li><li><p>什么，你问我之后？🤕之后就直接开耍了啊,给你们摘一段</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// listItem.tsx</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ListItem</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;listItemProps&gt; = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> [edit, setEdit] = useState&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">const</span> &#123;key, value, isCompleted&#125; = props.<span class="hljs-property">itemInfo</span>;<br>    <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleCheck</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">dispatch</span>(listActions.<span class="hljs-title function_">toggle</span>(key))<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDelete</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">dispatch</span>(listActions.<span class="hljs-title function_">dele</span>(key))<br>    &#125;<br>    <span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/ban-ts-comment</span><br>    <span class="hljs-comment">// @ts-expect-error</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleEdit</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>        <span class="hljs-keyword">if</span>(e.<span class="hljs-property">keyCode</span> === <span class="hljs-number">13</span>) &#123;<br>            <span class="hljs-title function_">dispatch</span>(listActions.<span class="hljs-title function_">edit</span>([key, e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>]))<br>            e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span><br>            <span class="hljs-title function_">setEdit</span>(<span class="hljs-literal">false</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleBlur</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setEdit</span>(<span class="hljs-literal">false</span>)<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDoubleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setEdit</span>(<span class="hljs-literal">true</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;isCompleted?</span>&#x27;<span class="hljs-attr">completed</span>&#x27;<span class="hljs-attr">:</span>&#x27;<span class="hljs-attr">active</span>&#x27;&#125; <span class="hljs-attr">onDoubleClick</span>=<span class="hljs-string">&#123;handleDoubleClick&#125;</span>&gt;</span></span><br><span class="language-xml">                &#123;!edit</span><br><span class="language-xml">                    ? <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span></span><br><span class="language-xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;toggle&quot;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> null&#125; type=&quot;checkbox&quot; checked=&#123;isCompleted&#125;  onInput=&#123;handleCheck&#125;/&gt;</span><br><span class="language-xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;destroy&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleDelete&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                    : <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-attr">onKeyDown</span>=<span class="hljs-string">&#123;handleEdit&#125;</span> <span class="hljs-attr">onBlur</span>=<span class="hljs-string">&#123;handleBlur&#125;</span> <span class="hljs-attr">autoFocus</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;new-todo&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="language-xml">                &#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="五、常用hook🤣"><a href="#五、常用hook🤣" class="headerlink" title="五、常用hook🤣"></a>五、常用<code>hook</code>🤣</h2><h3 id="1-useDispatch"><a href="#1-useDispatch" class="headerlink" title="1. useDispatch"></a>1. useDispatch</h3><p>在上边的也看到了，就是一个分配工作的小包工头</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">dispatch</span>(listActions.<span class="hljs-title function_">toggle</span>(key))<br></code></pre></td></tr></table></figure><p>通过<code>dispatch</code>,把<code>action</code>传递给<code>store</code>，更新<code>state</code></p><h3 id="2-useSelector"><a href="#2-useSelector" class="headerlink" title="2. useSelector"></a>2. useSelector</h3><p>这位更是重量级,负责摘出<code>store</code>中对应的<code>state</code></p><p>比如这是我们的<code>store</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">todoStore</span> = <span class="hljs-title function_ invoke__">configureStore</span>(&#123;<br>    <span class="hljs-attr">reducer</span>: &#123;<br>        <span class="hljs-attr">listReducer</span>: listInfoReducer,<br>        <span class="hljs-attr">displayReducer</span>: displayReducer<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们可以这样拿到<code>list</code>的值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state: storeType</span>) =&gt;</span> state.<span class="hljs-property">listReducer</span>)<br></code></pre></td></tr></table></figure><p>不过之所以说它重量级是因为它不太搞得懂<code>ts</code>，所以经常要自己去创建类型喂给她，比如这里：<code>storeType</code>就是自己定义的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;displayState, itemType&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../pages/listType.ts&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> storeType &#123;<br>    <span class="hljs-attr">listReducer</span>: itemType[],<br>    <span class="hljs-attr">displayReducer</span>: displayState<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、useReducer🥳"><a href="#六、useReducer🥳" class="headerlink" title="六、useReducer🥳"></a>六、<code>useReducer</code>🥳</h2><p>这玩意就是<code>react</code>看到<code>redux</code>的成功，模仿出来的一个<code>hook</code>，可以理解为<code>redux</code>青春版, 听完<code>redux</code>之后这个就是小<code>case</code>啦</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-comment">// reducer函数接受当前的state和一个action，返回新的state</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state, action</span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DECREMENT&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Counter</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// useReducer返回一个当前state和dispatch函数的数组</span><br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125;&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;DECREMENT&#x27; &#125;)&#125;&gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Counter</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>react进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>react进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canvas简介</title>
    <link href="/2024/01/24/canvas/"/>
    <url>/2024/01/24/canvas/</url>
    
    <content type="html"><![CDATA[<h2 id="canvas简介"><a href="#canvas简介" class="headerlink" title="canvas简介"></a>canvas简介</h2><p>canvas，顾名思义就是画布。用于绘制各种图形图片。</p><p>HTML5 canvas 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.canvas标签只是图形容器，您必须使用脚本来绘制图形。<br>你可以通过多种方法使用 canvas 绘制路径,盒、圆、字符以及添加图像。</p><p>特点：canvas绘制出来的图像是单纯的像素点（svg图是矢量图，也是dom元素），所画的内容与dom元素不同，canvas是一个dom元素，对其方法是对挂在canvas上对内容的操作。</p><h2 id="canvas基本操作"><a href="#canvas基本操作" class="headerlink" title="canvas基本操作"></a>canvas基本操作</h2><p>由于canvas是h5新增的标签，为了防止有人用古董版本浏览器，一般会这么写，canvas出不来时就让用户升级浏览器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;mycanvas&#x27;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br>    当前的浏览器版本不支持，请升级浏览器<br><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p>然后就要用js对canvas进行操作，基本的画线、矩形、圆形、文字都有对应的方法，只需要弄懂其中的参数含义即可（不用背，写的时候翻一翻就可以）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 得到canvas的画布</span><br><span class="hljs-keyword">const</span> myCanvas= <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;mycanvas&quot;</span>)<br><span class="hljs-comment">// 得到画布的上下文，上下文有两个，2d的上下文和3d的上下文</span><br><span class="hljs-comment">// 所有的图像绘制都是通过ctx属性或者是方法进行设置的，和canvas标签没有关系了</span><br><span class="hljs-keyword">const</span> ctx = myCanvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>)<br><br><span class="hljs-keyword">if</span>(ctx !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 设置颜色</span><br>    ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&#x27;green&#x27;</span><br>    <span class="hljs-comment">// 绘制矩形</span><br>    ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">50</span>) <br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一些具体的方法：<br>(注意：canvas中的坐标都是以左上方为原点，坐标向下向右增大)</p><h4 id="绘制矩形："><a href="#绘制矩形：" class="headerlink" title="绘制矩形："></a>绘制矩形：</h4><ul><li>fillRect(x, y, width, height)<br>绘制一个填充的矩形</li><li>strokeRect(x, y, width, height)<br>绘制一个矩形的边框</li><li>clearRect(x, y, width, height)<br>清除指定矩形区域，让清除部分完全透明。</li></ul><h4 id="绘制路径与笔触："><a href="#绘制路径与笔触：" class="headerlink" title="绘制路径与笔触："></a>绘制路径与笔触：</h4><p>绘制路径中我们要有一个画笔的概念，画笔有一个位置</p><ul><li>moveto(x,y)<br>画笔移动到某处</li><li>lineTo(x, y)画一条到某处的线</li><li>beginPath()<br>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</li><li>closePath()<br>闭合路径之后图形绘制命令又重新指向到上下文中。</li><li>stroke()<br>通过线条来绘制图形轮廓。</li><li>fill()<br>通过填充路径的内容区域生成实心的图形。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//一个画出三角形填色的例子</span><br>ctx.<span class="hljs-title function_">beginPath</span>();<br>    ctx.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">75</span>, <span class="hljs-number">50</span>);<br>    ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">100</span>, <span class="hljs-number">75</span>);<br>    ctx.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">100</span>, <span class="hljs-number">25</span>);<br>    ctx.<span class="hljs-title function_">fill</span>();<br></code></pre></td></tr></table></figure></li></ul><h4 id="绘制颜色："><a href="#绘制颜色：" class="headerlink" title="绘制颜色："></a>绘制颜色：</h4><p>canvas中的画笔颜色修改（实际开发中容易被之前的颜色干扰，所以封装每一个绘制函数时可以再开头修改成需要的颜色）</p><ul><li>fillStyle &#x3D; color<br>设置图形的填充颜色。</li><li>strokeStyle &#x3D; color<br>设置图形轮廓的颜色。</li></ul><h4 id="绘制文本："><a href="#绘制文本：" class="headerlink" title="绘制文本："></a>绘制文本：</h4><ul><li>fillText(text, x, y [, maxWidth])<br>在指定的 (x,y) 位置填充指定的文本，绘制的最大宽度是可选的。</li><li>strokeText(text, x, y [, maxWidth])<br>在指定的 (x,y) 位置绘制文本边框，绘制的最大宽度是可选的。</li><li>文本样式：<br>font &#x3D; value<br>当前我们用来绘制文本的样式。这个字符串使用和 CSS font 属性相同的语法。默认的字体是 10px sans-serif。</li></ul><p>除了以上，还有渐变色、透明度、线条转边样式等。需要的时候都可以一下查到而且用起来很简单，所以不必背下来，只用知道什么是可以做的和在哪里查到就可以了。</p><h3 id="图片绘制："><a href="#图片绘制：" class="headerlink" title="图片绘制："></a>图片绘制：</h3><p>这个是重点。实际开发中不可能让自己画三角形矩形圆形再填色一堆内容，更多的时候是用设计给好的图片，就是把图片画到画布上去。<br><code>drawImage</code><br>其中 image 是 image 或者 canvas 对象。<br>（注意这里的image是一个Image对象或者一个dom获取的img标签）</p><p><code>drawImage</code>的参数设置有点让人晕头转向。我们一步一步来看。</p><ul><li><code>drawImage(image,x,y)</code>x,y是图片的坐标，图片的左上角点坐标为（x,y）,此时图片的宽高皆为其像素默认宽高</li><li><code>drawImage(image, x, y, width, height)</code>这个方法多了 2 个参数：width 和 height，这两个参数用来控制 当向 canvas 画入时应该缩放的大小。此时图片的宽高为width、height。</li><li><code>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</code><br>前 4 个是定义图像源的切片位置和大小，后 4 个则是定义切片的目标显示位置和大小。可以对照下图理解一下。<img src='canvas_drawimage.jpg'></li></ul><h3 id="状态保存与回复"><a href="#状态保存与回复" class="headerlink" title="状态保存与回复"></a>状态保存与回复</h3><ul><li><code>save()</code><br>保存画布 (canvas) 的所有状态</li><li><code>restore()</code><br>save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</li><li>你可以调用任意多次 save方法。每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。</li></ul><h2 id="canvas实现动画"><a href="#canvas实现动画" class="headerlink" title="canvas实现动画"></a>canvas实现动画</h2><p>我们用canvas绘制了一个图形，一旦绘制成功了，canvas就像素化了他们。canvas没有能力，从画布上再次得到这个图形，也就是我们没有能力去修改已经在画布上的内容，这个就是canvas比较轻量的原因，Flash重的原因之一就有它可以通过对应的api得到已经上“画布”的内容然后再次绘制。</p><p>所以我们得到了canvas的动画的流程：画-&gt;更新数据内容-&gt;清除画布内容-&gt;重新画</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置颜色</span><br>ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;blue&quot;</span><br><span class="hljs-comment">// 初始信号量</span><br><span class="hljs-keyword">let</span> left = -<span class="hljs-number">200</span><br><span class="hljs-comment">// 动画过程</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-comment">// 清除画布,0,0代表从什么位置开始,600,600代表清除的宽度和高度</span><br>   ctx.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">600</span>,<span class="hljs-number">600</span>)<br>   <span class="hljs-comment">// 更新信号量</span><br>   left++<br>   <span class="hljs-comment">// 如果已经走出画布，则更新信号量为初始位置</span><br>   <span class="hljs-keyword">if</span>(left &gt; <span class="hljs-number">600</span>) &#123;<br>       left = -<span class="hljs-number">200</span><br>   &#125;<br>   ctx.<span class="hljs-title function_">fillRect</span>(left, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>)<br>&#125;,<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>看看上面这个例子，setInterval不断的调用它第一个参数函数的内容。函数中清除再更新方块的位置再渲染。</p><p>setInterval间隔一段时间不断调用函数的特性让我们可以用它来重绘。当然间隔一段固定的时间也有其弊端，这个时候可以用raf动画，这里不展开说明。</p><p>上面的例子中只有一个简单的图形和一个简单的left坐标，写起来很简单。但是在实际开发中，一个画布中会有很多不同的内容在动，如果为每一个内容添加其变量属性再写一堆绘制函数的话，整个代码就会先得很乱。所以我们将每一种类型的图形封装成对应的类，每一个内容是该类的对象，将该对象的数据内容存在对象中不要放在全局里，每个对象有其更新数据和绘制的方法。再在setInterval中一起调用全部对象的更新与绘制函数。</p><p>如果有兴趣还可看看看下面的文章：<br><a href="https://www.cnblogs.com/bleaka/p/16143470.html">https://www.cnblogs.com/bleaka/p/16143470.html</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reflect &amp; Proxy</title>
    <link href="/2023/12/17/Reflect/"/>
    <url>/2023/12/17/Reflect/</url>
    
    <content type="html"><![CDATA[<h1 id="Reflect和Proxy-🥳"><a href="#Reflect和Proxy-🥳" class="headerlink" title="Reflect和Proxy 🥳"></a>Reflect和Proxy 🥳</h1><h2 id="1-Proxy-🕶️"><a href="#1-Proxy-🕶️" class="headerlink" title="1. Proxy 🕶️"></a>1. Proxy 🕶️</h2><h3 id="1-1-语法🤡"><a href="#1-1-语法🤡" class="headerlink" title="1.1 语法🤡"></a>1.1 语法🤡</h3><p>我们可以使用 <code>Proxy()</code> 构造器来创建一个新的 <code>Proxy</code> 对象。构造器接收两个主要参数：</p><ul><li><code>target</code> 被代理的对象</li><li><code>handler</code> 被代理对象上的自定义行为</li></ul><p>像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br></code></pre></td></tr></table></figure><p>一个空的 <code>handler</code> 参数将会创建一个与被代理对象行为几乎完全相同的代理对象。通过在 <code>handler</code> 对象上定义一组处理函数，你可以自定义被代理对象的一些特定行为。例如，通过定义 <code>get()</code> 你就可以自定义被代理对象的属性访问器。</p><h3 id="1-2-handler们😱"><a href="#1-2-handler们😱" class="headerlink" title="1.2 handler们😱"></a>1.2 handler们😱</h3><table><thead><tr><th>名字</th><th>功能</th></tr></thead><tbody><tr><td>handler.apply()</td><td>函数调用劫持</td></tr><tr><td>handler.construct()</td><td><code>new</code> 操作符劫持</td></tr><tr><td>handler.defineProperty()</td><td><code>Object.defineProperty</code>调用劫持</td></tr><tr><td>handler.deleteProperty()</td><td><code>delete</code> 操作符劫持</td></tr><tr><td>handler.get()</td><td>获取属性值劫持</td></tr><tr><td>handler.getOwnPropertyDescriptor()</td><td><code>Object.getOwnPropertyDescriptor</code> 调用劫持</td></tr><tr><td>handler.getPrototypeOf()</td><td><code>Object.getPrototypeOf</code>调用劫持</td></tr><tr><td>handler.has()</td><td><code>in</code>操作符劫持</td></tr><tr><td>handler.isExtensible()</td><td><code>Object.isExtensible</code>调用劫持</td></tr><tr><td>handler.ownKeys()</td><td><code>Object.getOwnPropertyNames</code>和<code>Object.getOwnPropertySymbols</code>调用劫持。</td></tr><tr><td>handler.preventExtensions()</td><td><code>Object.preventExtensions</code>调用劫持</td></tr><tr><td>handler.set()</td><td>设置属性值劫持</td></tr><tr><td>handler.setPrototypeOf()</td><td><code>Object.setPrototypeOf</code>调用劫持</td></tr></tbody></table><blockquote><p>因为是对对象功能的劫持，所以功能差不多与<code>Object</code>的方法名一一对应🫨</p></blockquote><h3 id="1-3-示例💩"><a href="#1-3-示例💩" class="headerlink" title="1.3 示例💩"></a>1.3 示例💩</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cs = &#123;<br>    <span class="hljs-title class_">Ak47</span>: <span class="hljs-number">2700</span>,<br>    <span class="hljs-attr">AWP</span>: <span class="hljs-number">4750</span>,<br>    <span class="hljs-attr">amor</span>: <span class="hljs-number">650</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> valorantHandler = &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop, receiver</span>) &#123;<br>        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&quot;AWP&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4700</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(cs, valorantHandler);<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(proxy).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy[key])<br>&#125;)<br></code></pre></td></tr></table></figure><p>🤪猜猜会输出什么嘞</p><p>🤪打瓦的闭嘴</p><blockquote><p><code>Proxy</code>第一个参数都是<code>target</code>,指定代理的对象；</p><p>第二个参数<code>prop</code>指定代理属性名；</p><p>第三个参数<code>receiver</code>用于指定<code>this</code>指向，如果不加上可能会导致<code>this</code>不会正确配置（不太懂，没找到例子🤔）</p></blockquote><h3 id="1-4-有getter和setter了，为什么还要有个proxy嘞🦢"><a href="#1-4-有getter和setter了，为什么还要有个proxy嘞🦢" class="headerlink" title="1.4 有getter和setter了，为什么还要有个proxy嘞🦢"></a>1.4 有<code>getter</code>和<code>setter</code>了，为什么还要有个<code>proxy</code>嘞🦢</h3><p>虽然 <code>Getter</code> 和 <code>Setter</code> 提供了对单个属性操作的控制，但它们不能直接应用于整个对象或拦截其他类型的操作。<code>Proxy</code> 提供了<em><strong>对整个对象操作的完全控制</strong></em>，可以拦截和自定义几乎所有对对象的操作。这使得 Proxy 在进行复杂操作或创建高级抽象时非常有用。</p><p>还是那段代码，想想看要是想动态加上一个属性<code>m4</code>,不管输入什么最后都打印出0<code>。用</code>getter<code>或者</code>setter<code>怎么写？显然是不可能的，因为</code>getter<code>和</code>setter<code>管不到</code>defineProperties<code>, 但是要换成</code>proxy&#96;就很简单了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cs = &#123;<br>    <span class="hljs-title class_">Ak47</span>: <span class="hljs-number">2700</span>,<br>    <span class="hljs-attr">AWP</span>: <span class="hljs-number">4750</span>,<br>    <span class="hljs-attr">amor</span>: <span class="hljs-number">650</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> valorantHandler = &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop, receiver</span>) &#123;<br>        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&quot;AWP&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4700</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;,<br>    <span class="hljs-title function_">defineProperty</span>(<span class="hljs-params">target, prop, descriptor</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Defining property: <span class="hljs-subst">$&#123;prop&#125;</span>`</span>);<br>        <span class="hljs-keyword">if</span>(prop === <span class="hljs-string">&#x27;usp&#x27;</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(target, prop, descriptor);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(cs, valorantHandler);<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(proxy,<span class="hljs-string">&quot;usp&quot;</span>, &#123;<br>    <span class="hljs-attr">value</span>:<span class="hljs-number">8848</span>,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125;)<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(proxy).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, proxy[key])<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>但是<code>proxy</code>相对于原生<code>object</code>处理速度会慢很多，所以也不能大量使用<code>proxy</code>，会严重影响性能👽</p></blockquote><h2 id="2-Reflect🤕"><a href="#2-Reflect🤕" class="headerlink" title="2. Reflect🤕"></a>2. Reflect🤕</h2><blockquote><p><strong>Reflect</strong> 是一个内置的对象，它提供<em><strong>拦截 JavaScript</strong></em> 操作的方法。这些方法与 <code>proxy </code>的方法相同。<code>Reflect</code> 不是一个函数对象，因此它是<em><strong>不可构造</strong></em>的。</p></blockquote><h3 id="2-1-属性表"><a href="#2-1-属性表" class="headerlink" title="2.1 属性表"></a>2.1 属性表</h3><table><thead><tr><th>名字</th><th>功能</th></tr></thead><tbody><tr><td>Reflect.apply(target, thisArgument, argumentsList)</td><td>对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 <code>Function.prototype.apply()</code> 功能类似。</td></tr><tr><td>Reflect.construct(target, argumentsList[, newTarget])</td><td>对构造函数进行 <code>new</code>操作，相当于执行 <code>new target(...args)</code></td></tr><tr><td>Reflect.defineProperty(target, propertyKey, attributes)</td><td>和 <code>Object.defineProperty()</code> 类似。如果设置成功就会返回 <code>true</code></td></tr><tr><td>Reflect.deleteProperty(target, propertyKey)</td><td>作为函数的<code>delete</code>操作符，相当于执行 <code>delete target[name]</code></td></tr><tr><td>Reflect.get(target, propertyKey[, receiver])</td><td>获取对象身上某个属性的值，类似于 <code>target[name]</code>。</td></tr><tr><td>Reflect.getOwnPropertyDescriptor(target, propertyKey)</td><td>类似于 <code>Object.getOwnPropertyDescriptor()</code>如果对象中存在该属性，则返回对应的属性描述符，否则返回 <code>undefined</code>。</td></tr><tr><td>Reflect.getPrototypeOf(target)</td><td>类似于 <code>Object.getPrototypeOf()</code></td></tr><tr><td>Reflect.has(target, propertyKey)</td><td>判断一个对象是否存在某个属性，和 <code>in</code> 运算符 的功能完全相同</td></tr><tr><td>Reflect.isExtensible(target)</td><td>类似于 <code>Object.isExtensible()</code>.</td></tr><tr><td>Reflect.ownKeys(target)</td><td>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <code>Object.keys()</code>, 但不会受<code>enumerable</code> 影响).</td></tr><tr><td>Reflect.preventExtensions(target)</td><td>类似于 <code>Object.preventExtensions()</code>返回一个<code>Boolean</code></td></tr><tr><td>Reflect.set(target, propertyKey, value[, receiver])</td><td>将值分配给属性的函数。返回一个<code>Boolean</code>，如果更新成功，则返回<code>true</code>。</td></tr><tr><td>Reflect.setPrototypeOf(target, prototype)</td><td>设置对象原型的函数。返回一个 <code>Boolean</code>，如果更新成功，则返回 <code>true</code>。</td></tr></tbody></table><p>悉心观察可以发现，这上方的所有属性，都来自<code>Object</code>，那么就有问题了，为什么<code>Object</code>上有的属性，还要单拿出来呢？</p><h3 id="2-2-为什么要用Reflect，Object不好吗？😟"><a href="#2-2-为什么要用Reflect，Object不好吗？😟" class="headerlink" title="2.2 为什么要用Reflect，Object不好吗？😟"></a>2.2 为什么要用<code>Reflect</code>，<code>Object</code>不好吗？😟</h3><p>这就又要提到<code>js</code>独有的抽象了🤪</p><p>要知道<code>js</code>可是一门花了整整<em><strong>10天</strong></em>才诞生的语言🤡，那也难免会有抽象的事情发生</p><blockquote><p>点名批评<code>undefined</code>以及<code>arguments</code>😓，一个BYD不是关键字，一个传进去了还能改，属于是抽象巅峰了🤪</p></blockquote><p><code>Object</code>也不例外，有些方法会有<em><strong>局限性</strong></em>以及<em><strong>与标准实现不一致的地方</strong></em> </p><blockquote><p>例如， <code>Object.defineProperty()</code> 用于定义一个新的属性，在成功时返回 <code>true</code>，但在失败时会抛出一个错误。成功失败返回类型不一致，而且还会报错，这很令人恼火😡</p></blockquote><p>那咋办呢？</p><p>ECMA选择了和解决上面的<code>arguments</code>bug一样的解决方法——再写一套不就完了？？？🤣</p><p>于是就有了咱们的<code>Reflect</code></p><p>其实还有一个更重要的原因，也是我把<code>Reflect</code>和<code>Proxy</code>放一起讲的理由： <em><strong><code>Proxy</code> 处理程序的方法与 <code>Reflect</code> 的方法一一对应，这意味着可以在 <code>Proxy</code> 的拦截器函数中直接使用 <code>Reflect</code> 的方法。这使得在创建复杂的代理行为时，能够轻松地维护默认行为，同时添加或修改某些特定的行为。</strong></em></p><h2 id="3-总结🤩"><a href="#3-总结🤩" class="headerlink" title="3. 总结🤩"></a>3. 总结🤩</h2><p><code>proxy</code>和<code>reflect</code>都是很强大的工具，两者结合可以轻松地维护默认行为，同时添加或修改某些特定的行为，实现更高自由度的编程，真的很酷好吗😏</p><p>如果想继续深入了解 <code>Reflect</code>以及<code>Proxy</code>， 可以去MDN上逛逛：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy">Proxy</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Service Worker</title>
    <link href="/2023/12/01/serviceWorker/"/>
    <url>/2023/12/01/serviceWorker/</url>
    
    <content type="html"><![CDATA[<h1 id="Service-Worker🐳"><a href="#Service-Worker🐳" class="headerlink" title="Service Worker🐳"></a>Service Worker🐳</h1><blockquote><p><code> Web Worker</code>大家已经很熟悉了吧，那我今天来讲讲它的好兄弟 <code>Service Worker</code>。</p><p>哥们也是最近两天才知道这个玩意，这几天玩下来感觉这玩意要比 <code>Web Worker</code> 实用一万倍</p></blockquote><h2 id="1-啥是Service-Worker-👹"><a href="#1-啥是Service-Worker-👹" class="headerlink" title="1. 啥是Service Worker?👹"></a>1. 啥是<code>Service Worker</code>?👹</h2><blockquote><p>以下内容来自<code>MDN</code>: </p><ul><li>Service worker 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会 **拦截网络请求 **并根据网络是否可用来采取适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。</li></ul></blockquote><p>说了这么一大堆，个人觉得最核心的还是: <code>拦截网络请求</code>😶‍🌫️。</p><p>如果大家用过<code>axios</code>的<code>interceptor</code>，那会感觉这俩玩意是出奇的相似🙊，（而且好像真能用<code>ServiceWorker</code>模拟<code>interceptor</code>?虽然很邪门就是了）</p><h2 id="2-会拦截网络请求，有什么用？🦄"><a href="#2-会拦截网络请求，有什么用？🦄" class="headerlink" title="2.会拦截网络请求，有什么用？🦄"></a>2.会拦截网络请求，有什么用？🦄</h2><ul><li><strong>请求封装</strong>：首先，正如上面所说的，它可以像<code>interceptor</code>一样工作，那就可以给咱们每个请求都自动的加上<code>token</code>之类的，虽然其他方法也能做，但这样真的很酷😎,当然，这也不是人家的主要业务</li><li><strong>拦截网络请求</strong>：当没有网或者网络很差的时候，可以选择<strong>不发送网路请求，直接采用缓存内容</strong>，保证用户看到的不是一片惨白或者是只小恐龙🦖</li><li><strong>导航预加载</strong>：当用户选择跳转页面的时候，也可以利用它率先<code>preLoad</code>下一个页面，或者直接采用预设好的页面，这有个响亮的名字： <strong>导航预加载</strong></li><li><strong>推送通知</strong>：<code>Service Worker</code> 能够接收来自服务器的推送通知，并在应用不在前台运行时向用户显示这些通知。这对于保持用户参与度和及时传递信息非常有用。（有<code>api</code>）</li><li><strong>网络请求代理</strong>：<code>Service Worker </code> 可以代理网络请求，实现如数据压缩、图片优化、安全策略加强等功能。</li></ul><h2 id="3-Service-Worker工作流程👻"><a href="#3-Service-Worker工作流程👻" class="headerlink" title="3. Service Worker工作流程👻"></a>3. Service Worker工作流程👻</h2><ol><li>获取 service worker 代码，然后使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer/register"><code>serviceWorkerContainer.register()</code></a> 来注册。如果成功，service worker 将在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerGlobalScope"><code>ServiceWorkerGlobalScope</code></a> 中执行；这本质上是一种特殊的上下文，在主脚本执行线程之外运行，没有访问 DOM 的权限。Service Worker 现在已为处理事件做好准备。</li><li>安装完成。<code>install</code> 事件始终是发送给 service worker 的第一个事件（这可用于启动填充 IndexedDB 和缓存站点资源的过程）。在此步骤期间，应用程序正在为离线可用做准备。</li><li>当 <code>install</code> 程序处理完成时，service worker 被视为已安装。此时，service worker 的先前版本可能处于激活的状态并控制着打开的页面。由于我们不希望同一 service worker 的两个不同版本同时运行，因此新版本尚未激活。</li><li>一旦 service worker 的旧版本控制的页面都已关闭，就可以安全地停用旧版本，并且新安装的 service worker 将收到 <code>activate</code> 事件。<code>activate</code> 的主要用途是去清理 service worker 之前版本使用的资源。新的 service worker 可以调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting"><code>skipWaiting()</code></a> 要求立即激活，而无需要求打开的页面关闭。然后，新的 service worker 将立即收到 <code>activate</code> 事件，并将接管任何打开的页面。</li><li>激活后，service worker 将立即控制页面，但是只会控制那些在 <code>register()</code> 成功后打开的页面。换句话说，文档必须重新加载才能真正的受到控制，因为文档在有或者没有 service worker 的情况下开始存在，并在其生命周期内维护它。为了覆盖次默认行为并在页面打开的情况下，service worker 可以调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clients/claim"><code>clients.claim()</code></a> 方法。</li><li>每当获取新版本的 service worker 时，都会再次发生此循环，并在新版本的激活期间清理上一个版本的残留。</li></ol><blockquote><p>同一个worker的不同版本:</p><p>这不能说是<code>Service Worker</code>的特性，反而是<code>Cache</code>的特性。 下面会讲到， <code>Cache</code>是<code>Service Worker</code>的好哥们，<code>Cache</code>可以用<code>Open(version)</code>来选择使用哪个版本的缓存，而<code>Service Worker</code>也会根据这个衍生出不同版本，而我们不想要多个版本的 worker 同时存在，因此 <code>worker</code> 的生命周期也比较特别 🤯</p></blockquote><h2 id="4-来看看如何用它提升用户体验吧🤣"><a href="#4-来看看如何用它提升用户体验吧🤣" class="headerlink" title="4. 来看看如何用它提升用户体验吧🤣"></a>4. 来看看如何用它提升用户体验吧🤣</h2><blockquote><p>其实主要也就一点：</p><ul><li>当缓存里有数据时，不应该再次请求，而是直接使用缓存内容，加快页面响应速度</li></ul></blockquote><p>而提到缓存，大家首先想到的是什么？可能是<code>indexDB</code>,也可能是<code>localStorage</code>,但是<code>Service Worker</code>用的是另一种叫做<code>cache</code>的缓存</p><blockquote><p><code>Cache</code>:</p><p><code>cache</code>是<code>web api</code>的一部分，虽然也可以在<code>Service Worker</code>外使用，但是它的主要优势还是缓存重要资源，比如图片、文件，因此经常和<code>Service Worker</code>成对出现，或者说，就是为<code>Service Worker</code>量身打造的api。</p><p>关于<code>cache</code>，这里不再过多介绍，可以去：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache">cache详解</a> 看看</p></blockquote><p>好，话不多说，咱们开干！⛽</p><hr><p>哥们的文件目录（忽略webworker）：</p><p><img src="https://s2.loli.net/2023/12/01/cBsw52A3C8n7yiQ.png" alt="文件目录"></p><ol><li><p>跟<code>Web Worker</code>一样，都得在<code>主js</code>中注册<code>worker</code>，同样的，它也有<code>messageChannel</code>，用于和主线程通信</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">registerServiceWorker</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;serviceWorker&quot;</span> <span class="hljs-keyword">in</span> navigator) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> serviceWorkerRegistration = <span class="hljs-keyword">await</span> navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&quot;../serviceWorker.js&quot;</span>, &#123;<br>                <span class="hljs-attr">scope</span>: <span class="hljs-string">&quot;/webworker/public/&quot;</span><br>            &#125;);<br>            <span class="hljs-keyword">const</span> statusGroup = [<span class="hljs-string">&quot;installing&quot;</span>, <span class="hljs-string">&quot;waiting&quot;</span>, <span class="hljs-string">&quot;active&quot;</span>];<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">&quot;status&quot;</span>)<br>            statusGroup.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>                serviceWorkerRegistration[item] &amp;&amp; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>            &#125;)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>()<br>        &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`registration failed: <span class="hljs-subst">$&#123;err&#125;</span>`</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;service worker is forbidden&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-title function_">registerServiceWorker</span>();<br></code></pre></td></tr></table></figure><blockquote><p>哦对了，它和<code>Web Worker</code>很大的不同就是它没得自己的构造函数，它只是一个挂载在<code>navigation</code>下面的小特性🤐而且只有<code>https</code>或者<code>localhost</code>才能使用它，因为它实在强的有点离谱.因此，可以看到我们用<code>try</code> <code>catch</code>包裹注册事件，保证即使不是<code>https</code>协议也可以正常访问网站</p><p>之所以不用<code>http</code>是因为，万一哪天这玩意被劫持了，后果不堪设想🙈</p></blockquote></li><li><p>根据你上面填的路径，搞个<code>serviceWorker.js</code>出来😇😇</p><p>我喜欢把这个<code>serviceWorker.js</code>当成纯纯的入口文件，当然，你们要全写在这一个文件里也不是不行，但是那样我觉得不清晰。以下是我的<code>serviceWorker.js</code>，里面主要是监听事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">importScripts(<span class="hljs-string">&quot;./workers/installServiceWorker.js&quot;</span>)<br>importScripts(<span class="hljs-string">&quot;./workers/cacheServiceWorker.js&quot;</span>)<br><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;install&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    event.<span class="hljs-title function_">waitUntil</span>(<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>            <span class="hljs-title function_">addResourcesToCache</span>([<br>                <span class="hljs-string">&quot;/webworker/public/html/index.html&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/css/index.css&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/js/serviceWorker.js&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/workers/installServiceWorker.js&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/workers/cacheServiceWorker.js&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/assets/3.jpg&quot;</span>,<br>            ]),<br>            self.<span class="hljs-property">registration</span>.<span class="hljs-property">navigationPreload</span>.<span class="hljs-title function_">enable</span>()<br>        ])<br>    );<br>&#125;);<br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;fetch&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    event.<span class="hljs-title function_">respondWith</span>(<br>        <span class="hljs-title function_">cacheFirstWithFallback</span>(&#123;<br>            <span class="hljs-attr">request</span>: event.<span class="hljs-property">request</span>,<br>            <span class="hljs-attr">preloadResponsePromise</span>: event.<span class="hljs-property">preloadResponse</span>,<br>            <span class="hljs-attr">fallbackUrl</span>: <span class="hljs-string">&quot;/webworker/public/assets/3.jpg&quot;</span>,<br>        &#125;),<br>    );<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>大家有空也可以看看 <em>Martin Fowler</em> 的 <em>重构：改善既有代码的设计</em>(超级好看🤪)，哥们的这种方式也是他的设计理念</p></blockquote><blockquote><p><strong><code>Service Worker</code>也是有管理范围的！</strong></p><p><strong>可以通过<code>scope</code>指定范围</strong>，但是它的范围只能是跟自己同级或者下级的文件，自己的上级文件就搞不到了，因此我们把<code>serviceWorker.js</code>放在根目录里，也就是为什么第一点的路径是”..&#x2F;serviceWorker.js”</p></blockquote></li><li><p>然后创建一个<code>installServiceWorker.js</code>，用于存放跟<code>install</code>相关的函数和配置，大致如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">addResourcesToCache</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">resources</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;v1&quot;</span>);<br>    <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">addAll</span>(resources)<br>&#125;<br><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;install&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    event.<span class="hljs-title function_">waitUntil</span>(<br>            <span class="hljs-title function_">addResourcesToCache</span>([<br>                <span class="hljs-string">&quot;/webworker/public/html/index.html&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/css/index.css&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/js/serviceWorker.js&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/workers/installServiceWorker.js&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/workers/cacheServiceWorker.js&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/workers/3.jpg&quot;</span>,<br>            ]),<br>    );<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>其中<code>cache.addAll</code>是<code>Cache</code>的一个方法，接受一个数组参数，通常是<code>url数组</code>，并把它们全部存储到<code>cache</code>的<code>v1</code>中</p></blockquote><blockquote><p><code>waitUntil</code>的作用是<code>Service Worker</code>必须在该函数的Promise执行完之后才能继续，接下来会详细介绍，霸道！！</p></blockquote><blockquote><p><strong>路径一定要写全！</strong>🙃</p></blockquote><p>到现在，咱们已经完成了<code>Service Worker</code>的挂载和缓存的下载了,咱们可以点开控制台，看看<code>application</code>里的<code>缓存空间</code>或者<code>存储</code>，有没有缓存🤩</p><p>如果顺利的话，应该可以看到如下条目：</p><p><img src="https://s2.loli.net/2023/12/02/vrYXuh9pIwEiHl7.png" alt="存储"></p></li><li><p>存储搞定了，那接下来就是如何运用存储了，在这里，我在<code>workers</code>中新建了<code>cacheServiceWorker.js</code>来处理利用缓存相关的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">cacheFirst</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">request</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> cachedResponse = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">match</span>(request);<br>    <span class="hljs-keyword">if</span>(cachedResponse) &#123;<br>        <span class="hljs-keyword">return</span> cachedResponse<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(request);<br>&#125;<br><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;fetch&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event)<br>    event.<span class="hljs-title function_">respondWith</span>(<br>        <span class="hljs-title function_">cacheFirst</span>(event.<span class="hljs-property">request</span>),<br>    );<br>&#125;);<br></code></pre></td></tr></table></figure><p>逻辑很简单对吧，就是首先在<code>caches</code>中寻找有无缓存过的条目，如果有，就直接返回缓存，如果没有，就返回<code>fetch(request)</code>的结果</p><blockquote><p>顺便提一嘴，<code>cacheFirst</code>的<code>request</code>是<code>Request</code>类的实例，也就是咱们平时发请求带的对象。<code>fetch</code>会自动把我们传的参数转换成这个对象，也可以直接传一个<code>request</code>给<code>fetch</code>，因此这里可以直接<code>fetch(request)</code>👽</p><p>而下面<code>eventListener</code>中的<code>event</code>属于<code>FetchEvent</code>对象，<code>Service Worker</code>对象专属的<code>api</code>，继承于<code>Event</code></p><p>（如果对<code>Event</code>不是很了解可以去看我的上一篇：<a href="https://konodioda727.github.io/2023/11/26/addEventListener1/%EF%BC%89">https://konodioda727.github.io/2023/11/26/addEventListener1/）</a></p><p>它只在监听<code>fetch</code>事件时会产生，它有以下三大特性（包括我们上面讲的<code>waitUntil</code>)：</p><ul><li><strong>event.request</strong>：这是一个 <code>Request</code> 对象，包含了被拦截的网络请求的详细信息，如请求的 URL、请求头、请求方法等。</li><li>**event.respondWith()**：这个方法允许你提供一个用于生成响应的 Promise。这是控制网络响应行为的关键方法。通过这个方法，你可以返回缓存中的响应、生成一个新的响应或者直接调用 <code>fetch</code> 来获取网络上的资源。</li><li>**event.waitUntil()**：这个方法用于延长事件的生命周期。它对于执行一些额外的异步处理（如缓存更新）很有用。</li></ul></blockquote><p>那来试试看是什么效果嘞，<strong>刷新页面</strong>，打开控制台-&gt;网络，看到如下红框中的<code>(Service Worker)</code>就算成功啦！</p><p><img src="https://s2.loli.net/2023/12/02/wruMQzWOVN69Dpv.png" alt="网络"></p></li><li><p>这样已经初具人形啦🤫，但是实际中还有许多异步加载的场景，我们要异步加载也能缓存下来，那就得使用更复杂的策略，我们<strong>不仅可以从网络中请求资源，还可以将其保存到缓存中</strong>，以便稍后对该资源的请求也可以离线检索🙀,做法其实也很简单，就在咱们刚才的基础上<strong>让经过请求得到的资源也存入<code>Cache</code>中即可</strong>，为此，我新加了<code>putInCache</code>函数，并对<code>cacheFirst</code>函数稍加修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">putInCache</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">request, response</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;v1&quot;</span>);<br>    <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">put</span>(request, response);<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">cacheFirst</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">request</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> cachedResponse = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">match</span>(request);<br>    <span class="hljs-keyword">if</span>(cachedResponse) &#123;<br>        <span class="hljs-keyword">return</span> cachedResponse<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">NetworkResponse</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(request);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">putInCache</span>(request, <span class="hljs-title class_">NetworkResponse</span>.<span class="hljs-title function_">clone</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NetworkResponse</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>现在已经非常不错啦👾，但还需要思考一个问题： <strong>没网怎么办？</strong>，初听可能会觉得很恼火😡，浏览器没网怎么玩？但是这也是<code>Service Worker</code>存在的原因之一，为了能让用户在没网的时候也有点东西看，我们就只能再次打磨<code>cacheFirst</code>函数，让它在请求失败的时候，也能有一个<code>fallback</code>可以使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">cacheFirst</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">&#123; request, fallbackUrl &#125;</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 首先，尝试从缓存中获取资源</span><br>  <span class="hljs-keyword">const</span> responseFromCache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">match</span>(request);<br>  <span class="hljs-keyword">if</span> (responseFromCache) &#123;<br>    <span class="hljs-keyword">return</span> responseFromCache;<br>  &#125;<br><br>  <span class="hljs-comment">// 然后尝试从网络中获取资源</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> responseFromNetwork = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(request);<br>    <span class="hljs-comment">// 响应可能会被使用</span><br>    <span class="hljs-comment">// 我们需要将它的拷贝放入缓存</span><br>    <span class="hljs-comment">// 然后再返回该响应</span><br>    <span class="hljs-title function_">putInCache</span>(request, responseFromNetwork.<span class="hljs-title function_">clone</span>());<br>    <span class="hljs-keyword">return</span> responseFromNetwork;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">const</span> fallbackResponse = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">match</span>(fallbackUrl);<br>    <span class="hljs-keyword">if</span> (fallbackResponse) &#123;<br>      <span class="hljs-keyword">return</span> fallbackResponse;<br>    &#125;<br>    <span class="hljs-comment">// 当回落的响应也不可用时，</span><br>    <span class="hljs-comment">// 我们便无能为力了，但我们始终需要</span><br>    <span class="hljs-comment">// 返回 Response 对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&quot;Network error happened&quot;</span>, &#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-number">408</span>,<br>      <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span> &#125;,<br>    &#125;);<br>  &#125;<br>&#125;;<br><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;fetch&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">respondWith</span>(<br>    <span class="hljs-title function_">cacheFirst</span>(&#123;<br>      <span class="hljs-attr">request</span>: event.<span class="hljs-property">request</span>,<br>      <span class="hljs-attr">fallbackUrl</span>: <span class="hljs-string">&quot;/webworker/public/assets/3.jpg&quot;</span>,<br>    &#125;),<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>好了，这下彻底圆满了🤣，当我们打开控制台，关闭网络时，现在也不会有太多的变化，我们的目的也就达到了，当然，实际过程中肯定还要为不同情况搞不同的<code>fallback</code>，但这里意思意思就差不多了💩</p></li></ol><h2 id="5-导航预加载🥸"><a href="#5-导航预加载🥸" class="headerlink" title="5. 导航预加载🥸"></a>5. 导航预加载🥸</h2><p>如果启用了<strong>导航预加载</strong>功能，其将在发出 fetch 请求后，立即开始下载资源，并同时激活 service worker。<strong>这确保了在导航到一个页面时，立即开始下载，而不是等到 service worker 被激活。</strong></p><blockquote><p>当用户导航到一个新页面时，浏览器可以立即开始加载页面资源，而不需要等待<code> Service Worker</code> 启动和激活。正常情况下，如果一个 <code>Service Worker </code>控制着网站，当用户点击链接或进行页面跳转时，浏览器首先需要启动并激活 <code>Service Worker</code>，然后 <code>Service Worker</code> 才会处理页面的网络请求。这可能会引入一些延迟</p></blockquote><p>这种延迟发生的次数相对较少，但是一旦发生就不可避免，而且可能很重要。</p><p>首先，必须在 service worker 激活期间使用 <code>registration.navigationPreload.enable()</code> 来启用该功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;activate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(self.<span class="hljs-property">registration</span>?.<span class="hljs-property">navigationPreload</span>.<span class="hljs-title function_">enable</span>());<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p><code>MDN</code>上说必须在<code>activate</code>里激活，但是哥们实测<code>install</code>也可以，毕竟<code>install</code>是第一个事件，理论上<code>activate</code>中干的在它里边一样可以.</p><p>因此，我在<code>installServiceWorker.js</code>中写了如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;install&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    event.<span class="hljs-title function_">waitUntil</span>(<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>            <span class="hljs-title function_">addResourcesToCache</span>([<br>                <span class="hljs-string">&quot;/webworker/public/html/index.html&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/css/index.css&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/js/serviceWorker.js&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/workers/installServiceWorker.js&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/workers/cacheServiceWorker.js&quot;</span>,<br>                <span class="hljs-string">&quot;/webworker/public/assets/3.jpg&quot;</span>,<br>            ]),<br>            self.<span class="hljs-property">registration</span>.<span class="hljs-property">navigationPreload</span>.<span class="hljs-title function_">enable</span>()<br>        ])<br>    );<br>&#125;);<br></code></pre></td></tr></table></figure><p>只是增加了<code>Promise.all()</code>，跟原来的变化不大</p></blockquote><p>然后使用 <code>event.preloadResponse</code> 等待预加载的资源在 <code>fetch</code> 事件处理程序中完成下载。</p><p>继续前几节的示例，我们插入代码，以便在缓存检查后等待预加载的资源，如果失败，则再从网络中获取。</p><p>新流程是：</p><ol><li>检查缓存</li><li>等待 <code>event.preloadResponse</code>，它作为 <code>preloadResponsePromise</code> 传递给 <code>cacheFirst()</code> 函数。如果返回结果，则缓存它。</li><li>如果两者均没有结果，那么我们就通过<code>Service Worker</code>从网络中获取。</li></ol><blockquote><p><code>preload</code>主要处理的是<strong>导航请求</strong>，其过程完全由浏览器操纵，不必担心，原理就是当遇到导航请求时，会不等待<code>Service Worker</code>，绕过<code>Service Worker</code>发送请求，接收到请求就返回到<code>preloadResponse</code>中</p></blockquote><p>再对着<code>cacheFirstWithFallback</code>缝缝补补，加上<code>preload</code>的逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">cacheFirstWithFallback</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">&#123;request, fallbackUrl, preloadResponsePromise&#125;</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> cachedResponse = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">match</span>(request);<br>    <span class="hljs-keyword">if</span>(cachedResponse) &#123;<br>        <span class="hljs-keyword">return</span> cachedResponse<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> preloadResponse = <span class="hljs-keyword">await</span> preloadResponsePromise;<br>    <span class="hljs-keyword">if</span> (preloadResponse) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;using preload response&quot;</span>, preloadResponse);<br>        <span class="hljs-title function_">putInCache</span>(request, preloadResponse.<span class="hljs-title function_">clone</span>());<br>        <span class="hljs-keyword">return</span> preloadResponse;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title class_">NetworkResponse</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(request);<br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">putInCache</span>(request, <span class="hljs-title class_">NetworkResponse</span>.<span class="hljs-title function_">clone</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">NetworkResponse</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">const</span> fallbackResponse = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">match</span>(fallbackUrl);<br>        <span class="hljs-keyword">if</span> (fallbackResponse) &#123;<br>            <span class="hljs-keyword">return</span> fallbackResponse;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&quot;Network error happened&quot;</span>, &#123;<br>            <span class="hljs-attr">status</span>: <span class="hljs-number">408</span>,<br>            <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span> &#125;,<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-更新Service-Worker🥳"><a href="#6-更新Service-Worker🥳" class="headerlink" title="6. 更新Service Worker🥳"></a>6. 更新<code>Service Worker</code>🥳</h2><p>之前提到过，浏览器不允许**不同版本的相同<code>Service Worker</code>**同时运行，为此，<code>Service Worker</code>的生命周期就显得很奇怪：</p><ul><li>如果你的<code> service worker</code> 已经被安装，但是刷新页面时有一个新版本的可用，新版的<code> service worker</code>会在后台安装，但是仍然不会被激活。当不再有任何已加载的页面在使用旧版的 <code> service worker</code> 的时候，新版本才会激活。一旦再也没有这样的已加载的页面，新的<code> service worker</code>就会被激活。</li></ul><p>如果我把cache的版本改成<code>v2</code>，那么这个<code>service worker</code>跟之前的就不一样了，这时，在<code>install</code>中后台会默默下载这个<code>v2</code>的worker，<strong>当没有页面在使用之前的版本的时候，这个新的 service worker 就会激活并开始响应请求。</strong>🫨</p><hr><p>当你更新 service worker 到一个新的版本，你将在它的 <code>install</code> 事件处理程序中创建一个新的缓存。在仍有由上一个 worker 的版本控制的打开的页面，你就需要同时保留这两个版本的缓存，因为之前的版本需要它缓存的版本。你可以使用 <code>activate</code> 事件从之前的缓存中移除数据。</p><p>传给 <code>waitUntil()</code> 的 promise 会阻塞其他的事件，直到它完成，因此你可以放心，当你在新的 service worker 中得到你的第一个 <code>fetch</code> 事件时，你的清理操作已经完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">deleteCache</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">key</span>) =&gt; &#123;<br>  <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">delete</span>(key);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">deleteOldCaches</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> cacheKeepList = [<span class="hljs-string">&quot;v2&quot;</span>];<br>  <span class="hljs-keyword">const</span> keyList = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">keys</span>();<br>  <span class="hljs-keyword">const</span> cachesToDelete = keyList.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> !cacheKeepList.<span class="hljs-title function_">includes</span>(key));<br>  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(cachesToDelete.<span class="hljs-title function_">map</span>(deleteCache));<br>&#125;;<br><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;activate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<span class="hljs-title function_">deleteOldCaches</span>());<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="7-如何处理过期资源？😓"><a href="#7-如何处理过期资源？😓" class="headerlink" title="7.如何处理过期资源？😓"></a>7.如何处理过期资源？😓</h2><p>遗憾的是，<code>Service Worker</code>并没有检测过期资源的<code>api</code>，那就只能靠咱们自己手搓了，我的想法就是给<code>cache</code>加一条<code>timeStamp</code>，或者<code>maxAge</code>,</p><p>如果缓存时间大于<code>maxAge</code>就清除资源并重新请求缓存(这不就http吗？)</p><p>还是老规矩，再对<code>cacheServiceWorker</code>缝缝补补，这次修改的日志：</p><ul><li>新增了一个用于删除过期资源的<code>deleteCache</code>函数</li><li>新增了一个用于判断是否过期的<code>isResourceExpired</code>函数</li><li>对<code>putInCache</code>以及<code>cacheServiceWorker</code>添加了删除过期缓存的逻辑</li></ul><p>修改完毕后大概长这样🤔：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cacheName = <span class="hljs-string">&quot;v1&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">putInCache</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">request, response</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(cacheName);<br>    <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">put</span>(request, response);<br>    <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">put</span>(request.<span class="hljs-property">url</span> + <span class="hljs-string">&#x27;-timestamp&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>().<span class="hljs-title function_">toString</span>()));<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">deleteCache</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">request</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(cacheName);<br>    cache.<span class="hljs-title function_">delete</span>(request)<br>    cache.<span class="hljs-title function_">delete</span>(request.<span class="hljs-property">url</span> + <span class="hljs-string">&#x27;-timestamp&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isResourceExpired</span>(<span class="hljs-params">request, maxAge</span>) &#123;<br>    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(cacheName);<br>    <span class="hljs-keyword">const</span> timestampResponse = <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">match</span>(request.<span class="hljs-property">url</span> + <span class="hljs-string">&#x27;-timestamp&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (timestampResponse) &#123;<br>        <span class="hljs-keyword">const</span> timestamp = <span class="hljs-keyword">await</span> timestampResponse.<span class="hljs-title function_">text</span>();<br>        <span class="hljs-keyword">const</span> age = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - <span class="hljs-built_in">parseInt</span>(timestamp, <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> age &gt; maxAge;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">cacheFirstWithFallback</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">&#123;request, fallbackUrl, preloadResponsePromise, maxAge=<span class="hljs-number">60</span>&#125;</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> cachedResponse = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">match</span>(request);<br>    <span class="hljs-keyword">if</span>(cachedResponse &amp;&amp; !(<span class="hljs-keyword">await</span> <span class="hljs-title function_">isResourceExpired</span>(request, maxAge))) &#123;<br>        <span class="hljs-keyword">return</span> cachedResponse<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">isResourceExpired</span>(request, maxAge)) &#123;<br>        <span class="hljs-title function_">deleteCache</span>(request)<br>    &#125;<br>    <span class="hljs-keyword">const</span> preloadResponse = <span class="hljs-keyword">await</span> preloadResponsePromise;<br>    <span class="hljs-keyword">if</span> (preloadResponse) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;using preload response&quot;</span>, preloadResponse);<br>        <span class="hljs-title function_">putInCache</span>(request, preloadResponse.<span class="hljs-title function_">clone</span>());<br>        <span class="hljs-keyword">return</span> preloadResponse;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title class_">NetworkResponse</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(request);<br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">putInCache</span>(request, <span class="hljs-title class_">NetworkResponse</span>.<span class="hljs-title function_">clone</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">NetworkResponse</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">const</span> fallbackResponse = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">match</span>(fallbackUrl);<br>        <span class="hljs-keyword">if</span> (fallbackResponse) &#123;<br>            <span class="hljs-keyword">return</span> fallbackResponse;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&quot;Network error happened&quot;</span>, &#123;<br>            <span class="hljs-attr">status</span>: <span class="hljs-number">408</span>,<br>            <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span> &#125;,<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-终于差不多了🥳"><a href="#8-终于差不多了🥳" class="headerlink" title="8.终于差不多了🥳"></a>8.终于差不多了🥳</h2><p>到这里，<code>Service Worker</code>的基本内容已经结束了，但还有些<code>worker</code>共有的属性或者方法，比如: <code>messageChannel</code>（超级好用，还可以用来组件间通信）因为太懒就没有讲，之后可能还会有<code>Web Worker</code>的文章？可能到那时候再讲讲好了🦖。</p><p>能写这么多哥们也要累死了😓</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>addEventListener-Event</title>
    <link href="/2023/11/26/addEventListener1/"/>
    <url>/2023/11/26/addEventListener1/</url>
    
    <content type="html"><![CDATA[<h1 id="addEventListener复刻之Event😈"><a href="#addEventListener复刻之Event😈" class="headerlink" title="addEventListener复刻之Event😈"></a>addEventListener复刻之Event😈</h1><blockquote><p>在写这篇文章之前，哥们一直以为<code>eventListener</code>是轮询出来的🐖,没想到它居然是用队列实现的，感觉挺新奇的。</p><p>东西好多，分两篇博客，本篇主攻<code>Event</code>（虽然基本上都是别人的文章内容，但哥们好歹也是精简过的嗷，不能说我纯copy😜）</p></blockquote><h3 id="1-Event🐲"><a href="#1-Event🐲" class="headerlink" title="1. Event🐲"></a>1. Event🐲</h3><blockquote><p>监听事件总得有个<code>事件</code>吧，欸，你还别说，js还真搞了一个事件对象 <code>Event</code>, 来看看吧</p><p>(以下内容均来自于博客：<a href="https://developer.aliyun.com/article/875782%EF%BC%8C">https://developer.aliyun.com/article/875782，</a> 实在太多了，写不完直接copy现成的🤢）</p></blockquote><p><strong>事件发生以后，会产生一个事件对象，作为参数传给监听函数</strong>。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p><p><strong><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(type, options);<span class="hljs-comment">// 参数一，事件名称； 参数二，事件对象的配置对象</span><br></code></pre></td></tr></table></figure><p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p><ul><li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象<strong>是否冒泡</strong>。</li><li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件<strong>是否可以被取消</strong>，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>( <span class="hljs-comment">// 创建一个新的事件实例</span><br>  <span class="hljs-string">&#x27;look&#x27;</span>, <span class="hljs-comment">// 事件名称</span><br>  &#123; <span class="hljs-comment">// 事件配置</span><br>    <span class="hljs-string">&#x27;bubbles&#x27;</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 事件是否冒泡</span><br>    <span class="hljs-string">&#x27;cancelable&#x27;</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 事件是否可以被取消</span><br>  &#125;<br>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">dispatchEvent</span>(ev); <span class="hljs-comment">// 触发ev实例，该实例是look事件</span><br></code></pre></td></tr></table></figure><p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p><p>注意，如果不是显式指定<code>bubbles</code>属性为<code>true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// HTML 代码为</span><br><span class="hljs-comment">// &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span><br><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">let</span> tag = event.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">tagName</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Tag: &#x27;</span> + tag); <span class="hljs-comment">// 没有任何输出</span><br>&#125;<br><br>div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, callback, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 该事件是在冒泡阶段监听函数</span><br><br><span class="hljs-keyword">let</span> click = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">&#x27;click&#x27;</span>); <br>p.<span class="hljs-title function_">dispatchEvent</span>(click); <span class="hljs-comment">// 给p发出一个click事件，该事件默认不会冒泡，因此不会触发父元素div的click事件</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener(&#39;click&#39;, callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p><p>另一方面，如果这个事件在<code>div</code>元素上触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">div.<span class="hljs-title function_">dispatchEvent</span>(click);<br></code></pre></td></tr></table></figure><p>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</p><h3 id="2-Event的实例属性🙈"><a href="#2-Event的实例属性🙈" class="headerlink" title="2. Event的实例属性🙈"></a>2. Event的实例属性🙈</h3><h4 id="2-1-Event-bubbles-是否会冒泡-只读-，Event-eventPhase-返回整数，表示事件所处阶段-只读"><a href="#2-1-Event-bubbles-是否会冒泡-只读-，Event-eventPhase-返回整数，表示事件所处阶段-只读" class="headerlink" title="2.1 Event.bubbles 是否会冒泡(只读)，Event.eventPhase 返回整数，表示事件所处阶段(只读)"></a>2.1 Event.bubbles 是否会冒泡(<em>只读</em>)，Event.eventPhase 返回整数，表示事件所处阶段(只读)</h4><p><code>Event.bubbles</code>属性<strong>返回一个布尔值，表示当前事件是否会冒泡</strong>。该属性为<strong>只读</strong>属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code>Event</code>构造函数生成的事件，默认是不冒泡的。</p><p><code>Event.eventPhase</code>属性<strong>返回一个整数常量，表示事件目前所处的阶段。该属性只读</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> phase = event.<span class="hljs-property">eventPhase</span>;<br></code></pre></td></tr></table></figure><p><code>Event.eventPhase</code>的返回值有四种可能。</p><ul><li>0，事件目前<strong>没有发生</strong>。</li><li>1，事件目前处于<strong>捕获阶段</strong>，即处于从祖先节点向目标节点的传播过程中。</li><li>2，事件<strong>到达目标节点</strong>，即<code>Event.target</code>属性指向的那个节点。</li><li>3，事件处于<strong>冒泡阶段</strong>，即处于从目标节点向祖先节点的反向传播过程中。</li></ul><h4 id="2-2-Event-cancelable-是否可取消默认行为，Event-cancelBubble是否阻止冒泡，event-defaultPrevented-是否调用过取消默认行为方法"><a href="#2-2-Event-cancelable-是否可取消默认行为，Event-cancelBubble是否阻止冒泡，event-defaultPrevented-是否调用过取消默认行为方法" class="headerlink" title="2.2 Event.cancelable 是否可取消默认行为，Event.cancelBubble是否阻止冒泡，event.defaultPrevented 是否调用过取消默认行为方法"></a>2.2 Event.cancelable 是否可取消默认行为，Event.cancelBubble是否阻止冒泡，event.defaultPrevented 是否调用过取消默认行为方法</h4><p><code>Event.cancelable</code>属性<strong>返回一个布尔值，表示事件是否可以取消</strong>。该属性为<strong>只读</strong>属性，一般用来了解 Event 实例的特性。</p><p><strong>大多数浏览器的原生事件是可以取消的</strong>。比如，取消<code>click</code>事件，点击链接将无效。但是除非显式声明，<code>Event</code>构造函数生成的事件，<strong>默认是不可以取消的</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> evt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>evt.<span class="hljs-property">cancelable</span>  <span class="hljs-comment">// false 默认不可取消</span><br></code></pre></td></tr></table></figure><p>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p><p>如果事件不能取消，调用<code>Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code>Event.cancelable</code>属性判断一下是否可以取消。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">preventEvent</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">cancelable</span>) &#123;<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;This event couldn\&#x27;t be canceled.&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(event);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Event.cancelBubble</code>属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以<strong>阻止事件的传播。</strong></p><p><code>Event.defaultPrevented</code>属性返回一个布尔值，表示该事件<strong>是否调用过<code>Event.preventDefault</code>方法。该属性只读。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (event.<span class="hljs-property">defaultPrevented</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;该事件已经取消了&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-Event-currentTarget当前正在通过的节点，Event-target目标节点"><a href="#2-3-Event-currentTarget当前正在通过的节点，Event-target目标节点" class="headerlink" title="2.3 Event.currentTarget当前正在通过的节点，Event.target目标节点"></a>2.3 Event.currentTarget当前正在通过的节点，Event.target目标节点</h4><p>事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意时点都有两个与事件相关的节点，一个是事件的<strong>原始触发节点</strong>（<code>Event.target</code>），另一个是事件<strong>当前正在通过的节点</strong>（<code>Event.currentTarget</code>）。<strong>前者通常是后者的后代节点</strong>。</p><p><code>Event.currentTarget</code>属性返回事件<strong>当前所在的节点</strong>，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。<strong>随着事件的传播，这个属性的值会变</strong>。</p><p><code>Event.target</code>属性返回<strong>原始触发事件的那个节点</strong>，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</p><p>事件传播过程中，不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// HTML 代码为</span><br><span class="hljs-comment">// &lt;p id=&quot;para&quot;&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/p&gt;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hide</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// 不管点击 Hello 或 World，总是返回 true</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === e.<span class="hljs-property">currentTarget</span>);<br><br>  <span class="hljs-comment">// 点击 Hello，返回 true</span><br>  <span class="hljs-comment">// 点击 World，返回 false</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === e.<span class="hljs-property">target</span>);<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;para&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, hide, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>&lt;em&gt;</code>是<code>&lt;p&gt;</code>的子节点，点击<code>&lt;em&gt;</code>或者点击<code>&lt;p&gt;</code>，都会导致监听函数执行。这时，<code>e.target</code>总是指向原始点击位置的那个节点，而<code>e.currentTarget</code>指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以<code>e.currentTarget</code>总是等同于监听函数内部的<code>this</code>。</p><h4 id="2-4-Event-type-事件类型（如：’click’）"><a href="#2-4-Event-type-事件类型（如：’click’）" class="headerlink" title="2.4 Event.type 事件类型（如：’click’）"></a>2.4 Event.type 事件类型（如：’click’）</h4><p><code>Event.type</code>属性<strong>返回一个字符串，表示事件类型</strong>。事件的类型是在生成事件的时候指定的。该属性只读。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> evt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>evt.<span class="hljs-property">type</span> <span class="hljs-comment">// &quot;foo&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-5-Event-isTrusted-是否由真实用户行为产生的事件"><a href="#2-5-Event-isTrusted-是否由真实用户行为产生的事件" class="headerlink" title="2.5 Event.isTrusted 是否由真实用户行为产生的事件"></a>2.5 Event.isTrusted 是否由真实用户行为产生的事件</h4><p><code>Event.isTrusted</code>属性返回一个<strong>布尔值</strong>，表示<strong>该事件是否由真实的用户行为产生</strong>。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> evt = <span class="hljs-keyword">new</span> <span class="hljs-type">Event</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>evt.isTrusted <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>evt</code>对象是脚本产生的，所以<code>isTrusted</code>属性返回<code>false</code>。</p><h4 id="2-6-Event-detail-事件的细节（单击or双击等）"><a href="#2-6-Event-detail-事件的细节（单击or双击等）" class="headerlink" title="2.6 Event.detail 事件的细节（单击or双击等）"></a>2.6 Event.detail 事件的细节（单击or双击等）</h4><p><code>Event.detail</code>属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于<code>click</code>和<code>dblclick</code>事件，<code>Event.detail</code>是鼠标按下的次数（<code>1</code>表示单击，<code>2</code>表示双击，<code>3</code>表示三击）；对于鼠标滚轮事件，<code>Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// HTML 代码如下</span><br><span class="hljs-comment">// &lt;p&gt;Hello&lt;/p&gt;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">giveDetails</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(e.detail); <span class="hljs-comment">// 快速点击的次数</span><br>&#125;<br><br>document.querySelector(<span class="hljs-string">&#x27;p&#x27;</span>).onclick = giveDetails;<br></code></pre></td></tr></table></figure><h3 id="3、实例方法👹"><a href="#3、实例方法👹" class="headerlink" title="3、实例方法👹"></a>3、实例方法👹</h3><h4 id="3-1-Event-preventDefault-取消浏览器对当前事件的默认行为"><a href="#3-1-Event-preventDefault-取消浏览器对当前事件的默认行为" class="headerlink" title="3.1 Event.preventDefault() 取消浏览器对当前事件的默认行为"></a>3.1 Event.preventDefault() 取消浏览器对当前事件的默认行为</h4><p><code>Event.preventDefault</code>方法<strong>取消浏览器对当前事件的默认行为</strong>。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</p><p><strong>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播</strong>。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada">// HTML 代码为<br>// &lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> id=<span class="hljs-string">&quot;my-checkbox&quot;</span> /&gt;<br>var cb = document.getElementById(<span class="hljs-symbol">&#x27;my</span>-checkbox&#x27;);<br><br>cb.addEventListener(<br>  <span class="hljs-symbol">&#x27;click</span>&#x27;,<br>  <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(e)&#123; e.preventDefault(); &#125;,<br>  <span class="hljs-literal">false</span><br>);<br></code></pre></td></tr></table></figure><p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p><p>利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。</p><h6 id="例子：只能输入字母的输入框"><a href="#例子：只能输入字母的输入框" class="headerlink" title="例子：只能输入字母的输入框"></a>例子：只能输入字母的输入框</h6><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">// HTML 代码为<br>// &lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;my-input&quot;</span> /&gt;<br>var <span class="hljs-built_in">input</span> = document.getElementById(<span class="hljs-string">&#x27;my-input&#x27;</span>);<br><span class="hljs-built_in">input</span>.addEventListener(<span class="hljs-string">&#x27;keypress&#x27;</span>, checkName, <span class="hljs-literal">false</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkName</span><span class="hljs-params">(e)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (e.charCode &lt; <span class="hljs-number">97</span> || e.charCode &gt; <span class="hljs-number">122</span>) &#123;<br>    e.preventDefault();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码为文本框的<code>keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p><h4 id="3-2-Event-stopPropagation-阻止事件传播"><a href="#3-2-Event-stopPropagation-阻止事件传播" class="headerlink" title="3.2 Event.stopPropagation() 阻止事件传播"></a>3.2 Event.stopPropagation() 阻止事件传播</h4><p><code>stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">stopEvent</span><span class="hljs-params">(e)</span> &#123;<br>  e.stopPropagation(); <span class="hljs-comment">// 阻止事件冒泡</span><br>&#125;<br><br>el.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, stopEvent, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>click</code>事件将不会进一步冒泡到<code>el</code>节点的父节点。</p><h4 id="3-3-Event-stopImmediatePropagation-阻止同一个事件的其他监听函数被调用"><a href="#3-3-Event-stopImmediatePropagation-阻止同一个事件的其他监听函数被调用" class="headerlink" title="3.3 Event.stopImmediatePropagation() 阻止同一个事件的其他监听函数被调用"></a>3.3 Event.stopImmediatePropagation() 阻止同一个事件的其他监听函数被调用</h4><p><code>Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p><p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">l1</span>(<span class="hljs-params">e</span>)&#123;<br>  e.stopImmediatePropagation();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">l2</span>(<span class="hljs-params">e</span>)&#123; <span class="hljs-comment">// 不会被调用</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>&#125;<br><br>el.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, l1, <span class="hljs-literal">false</span>);<br>el.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, l2, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>上面代码在<code>el</code>节点上，为<code>click</code>事件添加了两个监听函数<code>l1</code>和<code>l2</code>。由于<code>l1</code>调用了<code>event.stopImmediatePropagation</code>方法，所以<code>l2</code>不会被调用。</p><h4 id="3-4-Event-composedPath-数组，目标和冒泡的节点"><a href="#3-4-Event-composedPath-数组，目标和冒泡的节点" class="headerlink" title="3.4 Event.composedPath() 数组，目标和冒泡的节点"></a>3.4 Event.composedPath() 数组，目标和冒泡的节点</h4><p><code>Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// HTML 代码如下</span><br><span class="hljs-comment">// &lt;div&gt;</span><br><span class="hljs-comment">//   &lt;p&gt;Hello&lt;/p&gt;</span><br><span class="hljs-comment">// &lt;/div&gt;</span><br><span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">var</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br>div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-title function_">composedPath</span>());<br>&#125;, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// [p, div, body, html, document, Window]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>click</code>事件的最底层节点是<code>p</code>，向上依次是<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>Window</code>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reconciler</title>
    <link href="/2023/11/17/reconciler/"/>
    <url>/2023/11/17/reconciler/</url>
    
    <content type="html"><![CDATA[<h1 id="Reconciler"><a href="#Reconciler" class="headerlink" title="Reconciler"></a>Reconciler</h1><h2 id="1-Reconciler主要功能"><a href="#1-Reconciler主要功能" class="headerlink" title="1. Reconciler主要功能"></a>1. Reconciler主要功能</h2><ol><li>输入: 暴露<code>api</code>函数(如: <code>scheduleUpdateOnFiber</code>), 供给其他包(如<code>react</code>包)调用.</li><li>注册调度任务: 与调度中心(<code>scheduler</code>包)交互, 注册调度任务<code>task</code>, 等待任务回调.</li><li>执行任务回调: 在内存中构造出<code>fiber树</code>, 同时与与渲染器(<code>react-dom</code>)交互, 在内存中创建出与<code>fiber</code>对应的<code>DOM</code>节点.</li><li>输出: 与渲染器(<code>react-dom</code>)交互, 渲染<code>DOM</code>节点.</li></ol><p>以上这些功能可以汇集到一张图中：</p><p><img src="https://s2.loli.net/2023/11/17/vfPgm4BpGcZt3UK.png" alt="reconciler功能图"></p><h2 id="2-步骤分解"><a href="#2-步骤分解" class="headerlink" title="2. 步骤分解"></a>2. 步骤分解</h2><h3 id="输入🤗"><a href="#输入🤗" class="headerlink" title="输入🤗"></a>输入🤗</h3><p> 在<code>react-reconciler</code>对外暴露的 api 函数中, 只要涉及到需要改变 fiber 的操作(无论是<code>首次渲染</code>或<code>后续更新</code>操作), 最后都会间接调用<code>scheduleUpdateOnFiber</code>, 所以<code>scheduleUpdateOnFiber</code>函数是输入链路中的<code>必经之路</code>.</p><p>逻辑进入到<code>scheduleUpdateOnFiber</code>之后, 后面有 2 种可能:</p><ol><li>不经过调度, 直接进行<code>fiber构造</code>.</li><li>注册调度任务, 经过<code>Scheduler</code>包的调度, 间接进行<code>fiber构造</code>.</li></ol><blockquote><p><code>直接进行fiber构造</code>通常是在面对高优先级任务，例如<code>用户点击事件</code> 或者是<code>同步更新事件</code>（不允许被中断，因此也就不需要<code>scheduler</code>进行控制，可以理解为急诊）才会进行.</p><p>而面对低优先级的任务，react会先去<code>scheduler</code>注册调度任务（可以理解为先去取号），之后由<code>scheduler</code>进行调度执行渲染。在浏览器繁忙的时候，<code>scheduler</code>会优先暂停这些任务从而执行更重要的任务（可以理解为医生人手不足, 优先保证急诊运转）</p></blockquote><hr><h3 id="注册调度事件🌟"><a href="#注册调度事件🌟" class="headerlink" title="注册调度事件🌟"></a>注册调度事件🌟</h3><p>与<code>输入</code>环节紧密相连, <code>scheduleUpdateOnFiber</code>函数之后, 立即进入<code>ensureRootIsScheduled</code>函数（如果要注册事件的话）</p><blockquote><p><code>ensureRootIsScheduled</code>主要逻辑：</p><ol><li><strong>检查当前工作</strong>：函数首先检查是否已经有工作正在进行。React 保持了当前正在进行的工作的状态，以避免不必要的重复工作。（<strong>如果有低优先级的任务在执行，可以打断低优先级的任务，如果有相同任务在执行，可以减少一次重复工作</strong>）</li><li><strong>确定更新优先级</strong>：根据当前的更新（如状态改变、props 更新等）确定更新的优先级。React 使用不同的优先级来处理不同类型的更新，例如用户交互会被视为高优先级。</li><li><strong>安排更新任务</strong>：一旦确定了更新的优先级，<code>ensureRootIsScheduled</code> 会使用 React 的 <code>Scheduler</code> 安排一个新的更新任务。并且会把<code>performSyncWorkOnRoot</code>等函数封装到回调中，交给<code>Scheduler</code> 。</li></ol></blockquote><hr><h3 id="执行回调🐶"><a href="#执行回调🐶" class="headerlink" title="执行回调🐶"></a>执行回调🐶</h3><p><code>performSyncWorkOnRoot</code>的逻辑很清晰, 分为 3 部分:</p><ol><li>fiber 树构造</li><li>异常处理: 有可能 fiber 构造过程中出现异常</li><li>调用输出（<code>commitRoot</code>）</li></ol><p>在退出前，还会检测有无其他更新，是否需要发起新调度请求</p><p><code>performConcurrentWorkOnRoot</code>的逻辑与<code>performSyncWorkOnRoot</code>的不同之处在于, 对于<code>可中断渲染</code>的支持:</p><ol><li>调用<code>performConcurrentWorkOnRoot</code>函数时, 首先检查是否处于<code>render</code>过程中, 是否需要恢复上一次渲染.</li><li>如果本次渲染被中断, 最后返回一个新的 <code>performConcurrentWorkOnRoot</code> 函数, 等待下一次调用</li></ol><hr><h3 id="输出😁"><a href="#输出😁" class="headerlink" title="输出😁"></a>输出😁</h3><p>在输出阶段,<code>commitRoot</code>的实现逻辑是在<code>commitRootImpl</code>函数中, 其主要逻辑是处理副作用队列, 将最新的 fiber 树结构反映到 DOM 上.</p><p>核心逻辑分为 3 个步骤:</p><ol><li><p><code>commitBeforeMutationEffects</code></p><ul><li>dom 变更之前, 主要处理副作用队列中带有<code>Snapshot</code>,<code>Passive</code>标记的<code>fiber</code>节点.</li></ul></li><li><p><code>commitMutationEffects</code></p><ul><li>dom 变更, 界面得到更新. 主要处理副作用队列中带有<code>Placement</code>, <code>Update</code>, <code>Deletion</code>, <code>Hydrating</code>标记的<code>fiber</code>节点.</li></ul></li><li><p><code>commitLayoutEffects</code></p><ul><li>dom 变更后, 主要处理副作用队列中带有<code>Update | Callback</code>标记的<code>fiber</code>节点.</li></ul></li></ol><blockquote><p>React会给每次更新的内容打上标签，上面说的<code>Snapshot</code>,<code>Passvie</code>等就是标签的几个种类，这些标签大多和<code>渲染副作用</code>相关</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>react进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>react进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型链</title>
    <link href="/2023/11/17/proto/"/>
    <url>/2023/11/17/proto/</url>
    
    <content type="html"><![CDATA[<h1 id="原型链🤔"><a href="#原型链🤔" class="headerlink" title="原型链🤔"></a>原型链🤔</h1><h2 id="1-原型链的形成"><a href="#1-原型链的形成" class="headerlink" title="1. 原型链的形成"></a>1. 原型链的形成</h2><p><code>原型链</code> 是 <code>js</code> 实现继承的重要方式，也是 <code>js</code> 与其他语言与众不同的地方之一， <code>js</code> 中，原型链的形成方式如下：</p><blockquote><ol><li><code>js</code>中每个函数都有一个 <code>原型对象</code>, 这个对象只能在 <code>new</code> 构造时才能使用，当作为普通函数时，访问这个对象将会得到 <code>undefined</code>🪨</li><li>每个原型对象中包含着 <code>指向上一个原型对象的指针</code>, 当自身对象没有这个属性时， 会根据这个指针寻找上一层对象的相应属性 ，于是就形成了 <code>链式结构</code></li></ol></blockquote><h2 id="2-原型对象的组成🤐"><a href="#2-原型对象的组成🤐" class="headerlink" title="2. 原型对象的组成🤐"></a>2. 原型对象的组成🤐</h2><p>可能看完上面的解释大家还有些迷糊，没关系，在这一小节，我会跟大家详细介绍 <code>原型对象</code> 这个玩意。</p><p>初始的<code>原型对象</code>中有三种属性： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">GGBond</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">GGBond</span>,<br>    <span class="hljs-attr">super_bang_bang_tang</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;超级棒棒糖&quot;</span>);<br>    &#125;<br>    <span class="hljs-attr">fei_fei_gong_zhu</span>: <span class="hljs-string">&#x27;wife&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>一种叫做 <code>__proto__</code>， 这个就是刚刚所说指向上级的指针，当自身的<code>prototype</code>找不到相应属性时，就要顺着这个指针寻找上一级里的属性🤣</p><blockquote><p><code>__proto__</code>是个很有意思的变量，如果你尝试打印它:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">GGBond</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>);<br></code></pre></td></tr></table></figure><p>你将会得到 <code>&#123;&#125;</code>，但它实际上并不为空对象，如果你尝试以下比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">GGBond</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><p>那你会惊奇的发现它会返回 <code>true</code>😍, 这是因为<code>__proto__</code>是一个内部属性，所以某些时候会被限制显示。</p><p>因此，在 <code>ES6</code>中，更推荐使用新增的 <code>Object.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>方法而不是直接访问<code>__proto__</code></p><p>有意思的是，<code>__proto__</code> 这个属性本来就不是 <code>ES </code>的规范，直到 <code>ES6 </code>才被正式引入，但是官方在 <code>ES6</code> 又给出了它的替代方案（实际上就是封装了一小下😡），属于是生不逢时了</p></blockquote></li><li><p>一种叫做<code>constructor</code>，它指向自身，主要是用来判别是否为某个构造函数的实例，但是个人感觉它的功能快被某个<code>Symbol</code>替代了，还记得是哪个吗😏，不记得了记得去看看我之前的文章。</p><blockquote><p>个人感觉网上所说的它是<code>维护原型链的方法</code>不是很贴切😵，他们所说的<code>维护原型链</code>,也就是让继承更规范，类型识别更加方便。实际上<code>constructor</code>根本不会影响继承，也不会影响原型链上下的东西，感觉叫做<code>类型标识</code>也比<code>维护原型链</code>更好一些🤐</p></blockquote></li><li><p>最后就是咱们挂载到原型对象上的属性和方法了，在上面， 就是<code>super_bang_bang_tang</code>和<code>fei_fei_gong_zhu</code></p><blockquote><p><strong>注意：</strong></p><p>有些属性并不会被挂载到原型链上，也就是说，原型链上不会有所有的属性。🐶具体哪些不能在之后会有介绍</p></blockquote></li></ul><p>有没有感觉这个过程很像咱们亲爱的 <code>闭包</code> 😏</p><h2 id="3-原型对象最后去哪了？"><a href="#3-原型对象最后去哪了？" class="headerlink" title="3. 原型对象最后去哪了？"></a>3. 原型对象最后去哪了？</h2><p>由上面，咱们可以知道，<code>原型对象</code>是函数上才有的对象，那么如果咱们构造一个对象，那构造函数的<code>原型对象</code>会去哪里呢？🤔</p><p>还是以 <code>GGBond</code> 为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dead_pig = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GGBond</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> dead_pig) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>假设所有属性都是<code>可枚举</code>的，那么上面的输出会变成:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">constructor</span><br>super_bang_bang_tang<br>fei_fei_gong_zhu<br></code></pre></td></tr></table></figure><p><code>__proto__</code>为什么不在，看看上边，写了好长一段嘞😵</p><p>由此可见，<code>原型对象</code>在构建成对象之后，会自动散开<code>constructor</code>和<code>__proto__</code>，变成对象的两个属性，而其他则被舍弃，这时候，如果你要访问某个当前对象没有的属性，那么他就会顺着<code>__proto__</code>上溯去找咯</p><blockquote><p><strong>注意：</strong></p><p>这里有 <code>fei_fei_gong_zhu</code>和<code>super_bang_bang_tang</code>是因为并没有把他们挂载到原型链上，而是挂载到实例上，原型链上的属性并不会被散开到对象中</p></blockquote><h2 id="4-你已经学会原型链了，来试试写出ES6的class吧😎"><a href="#4-你已经学会原型链了，来试试写出ES6的class吧😎" class="headerlink" title="4.你已经学会原型链了，来试试写出ES6的class吧😎"></a>4.你已经学会原型链了，来试试写出ES6的class吧😎</h2><p><code>ES6</code>的<code>class</code>其实就是一个语法糖，是对原型链操作的简单封装，接下来，让我们简单实现以下 <code>class</code> 中 <code>extends</code> 操作吧：</p><p>还是以<code>GGBond</code>为例，先简单定义一个<code>DeadPig</code>构造函数和一个<code>GGBond</code>构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DeadPig</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">category</span> = <span class="hljs-string">&quot;pig&quot;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">food</span> = <span class="hljs-string">&quot;vegetable&quot;</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">GGBond</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;GGBond&quot;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">food</span> = <span class="hljs-string">&quot;超级棒棒糖&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，要让<code>GGBond</code>构造函数继承<code>DeadPig</code>函数，该怎么办呢😏</p><hr><p>那肯定是要修改<code>GGBond</code>的<code>prototype</code>为<code>DeadPig</code>对不对，开干！</p><p>且慢，咱们要想实现继承，首先要解决两个问题：</p><ul><li>子类要有父类定义的共用属性</li><li>子类的改动不影响父类</li></ul><p>要想实现这两点，就肯定不能用父类的直接引用，而要用间接引用，而什么是间接引用呢？<code>构造出来的实例</code>就是一个不错的选择，这样主要有两个好处：</p><ul><li>子类不会影响父类</li><li>子类实例上的某些方法也会被带进来，范围更广</li></ul><p>于是就有了下面的操作:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">GGBond</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadPig</span>();<br></code></pre></td></tr></table></figure><p>让我们来看看这个操作究竟都做了什么：</p><p>首先是创建了一个<code>DeadPig</code>对象，大概张这样： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">DeadPig</span>,<br>    <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;pig&quot;</span>,<br>    <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;vegetable&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后把这个对象赋值给 <code>GGBond.prototype</code>,这时<code>GGBond</code>大概长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-attr">prototype</span>: &#123;<br>        <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,<br>        <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">DeadPig</span>,<br>        <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;pig&quot;</span>,<br>        <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;vegetable&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候就已经基本完成继承了，但是还有个小问题，就是<code>GGBond</code>的<code>constructor</code>还是<code>DeadPig</code>，这很让人恼火.😡</p><p>如果别人访问<code>GGBond</code>实例的<code>constructor</code>，就会得到<code>DeadPig</code>,这还不是最烦人的，更重要的是**如果<code>GGBond</code>也被继承，那么它的子类的<code>constructor</code>**也会是<code>DeadPig</code>，来看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//如果GGBond也有实例，那应该长这样</span><br>&#123;<br>    <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">DeadPig</span>,<br>    <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;超级棒棒糖&quot;</span>, <br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;GGBond&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>如果它再被继承，那么被继承的构造函数应该长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-attr">prototype</span>: &#123;<br>        <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,<br>        <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">DeadPig</span>,<br>        <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;超级棒棒糖&quot;</span>, <br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;GGBond&quot;</span>,<br>    &#125;<br>    <span class="hljs-comment">// ...其他乱七八糟的属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那它的<code>constructor</code>自然而然的也是<code>DeadPig</code></p><p>那么如何修改<code>constructor</code>呢？很简单，暴力修改就行了😡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">GGBond</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;<br>    <span class="hljs-attr">enumberable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-title class_">GGBond</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这下就圆满咯🤣但还有一些小细节要搞</p><h2 id="5-深入理解构造函数和Class"><a href="#5-深入理解构造函数和Class" class="headerlink" title="5.深入理解构造函数和Class"></a>5.深入理解构造函数和Class</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">GGBond</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;ggb&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>name</code> 属性是挂载到 <code>实例</code> 上的，而非原型链。因此上面的示例中：</p><p><img src="https://s2.loli.net/2023/11/17/kjg4xGHlWOPoybh.png" alt="image1"></p><p>可以看到<code>GGBond.prototype</code>内并没有自身的属性,如果想让属性存到原型链中，可以使用： <code>Object.defineProperty(GGBond.prototype, &#39;name&#39;, &#123;value: value&#125;)</code> 或者 <code>GGBond.prototype[name] = value </code>来实现</p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GGBond</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-title function_">getValue</span>(<span class="hljs-params"></span>) &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是</strong>如果到了<code>Class</code>中, <code>name</code>这种属性还是挂载到示例上，而<code>getValue</code>这种方法，则会<strong>直接挂载到原型链上</strong></p><hr><p>还有一件很有意思的事情：</p><p>如果你修改<code>prototype</code>的一部分，并没有完全修改的话，那么在修改之前创建的实例会<code>随之一起变动</code></p><p>但如果完全修改，那么在<strong>修改之前创建的实例会像<code>闭包</code>一样不受影响</strong></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ggb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GGBond</span>();<br><span class="hljs-title class_">GGBond</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;dead&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ggb.<span class="hljs-property">status</span>)<br><span class="hljs-comment">// &gt; dead</span><br><br><span class="hljs-title class_">GGBond</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;alive&quot;</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ggb.<span class="hljs-property">status</span>)<br><span class="hljs-comment">// &gt; dead</span><br></code></pre></td></tr></table></figure><blockquote><p>出现这种情况是因为当修改一部分属性的时候，构造函数的<code>原型引用</code>仍未改变，只是修改了引用上的几个方法或属性，而<code>js</code>又是动态查找，所以会同步到所有构造出的对象。而一旦修改了整个<code>prrototype</code>，则会导致构造函数的<code>原型引用</code>整个更改，而<strong>之前构造的对象仍保持之前的引用</strong>，因此不会改变</p></blockquote><p>怎么样，是不是和<code>闭包</code>极其的相似😏</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react两大循环</title>
    <link href="/2023/11/12/loopInReact/"/>
    <url>/2023/11/12/loopInReact/</url>
    
    <content type="html"><![CDATA[<h1 id="React两大循环"><a href="#React两大循环" class="headerlink" title="React两大循环"></a>React两大循环</h1><h2 id="一、事件调度循环"><a href="#一、事件调度循环" class="headerlink" title="一、事件调度循环"></a>一、事件调度循环</h2><p>负责<code>任务调度</code>，是整个<code>React</code>工作的核心，它需要循环调用，来保证所有<code>task</code>的调度。</p><blockquote><p>前文提到<code>scheduler</code>主要接受来自<code>reconciler</code>的回调函数，并调用(<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>,还记得吗？😀)，并且根据回调生成<code>task</code>。当 <code>task</code>生成完毕之后，<code>事件调度循环</code>会按照<code>优先级</code>调度每个任务，并且生成回调，传给<code>reconciler</code></p></blockquote><p><img src="https://s2.loli.net/2023/11/12/7aUPfbwRgTpSQrq.png"></p><blockquote><p><strong>注意：</strong></p><p>其实<code>scheduler</code>的部分不止图中这些，比如上面提到的<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>也大概是<code>scheduler</code>的一部分，分别负责<code>同步事件处理</code>和<code>并发事件处理</code>,只不过在这两个函数是<code>ensureRootIsScheduled</code>封装到回调函数<code>scheduleCallback</code>中再被<code>scheduler</code>独立调用的，所以把他们放在了外边。同样的，下图中的<code>schedulerWithReactIntergration</code>也属于scheduler的范畴（看名字也看得出来🐶）</p></blockquote><h2 id="二、fiber构造循环-ReactFiberWorkLoop"><a href="#二、fiber构造循环-ReactFiberWorkLoop" class="headerlink" title="二、fiber构造循环(ReactFiberWorkLoop)"></a>二、fiber构造循环(ReactFiberWorkLoop)</h2><p>只负责<code>fiber树</code>的构造，是上面<code>事件调度循环</code>的后续（应该可以这么说？😏）部分</p><p>每次<code>reconciler</code>接收到更新请求时，会向<code>scheduler</code>注册一个任务,进入到上面⬆️图片的流程（右边两个粉粉的箭头来源就是<code>reconciler</code>）,<code>scheduler</code>通过<code>事件调度循环</code>把这事安排了，返回回调</p><blockquote><p><strong>注意：</strong></p><p>由于<code>事件调度循环</code>会根据优先级安排任务，所以接收到更新请求后不一定立即执行该任务，就像是学生事务大厅😵</p></blockquote><p>这时候还没到咱们的<code>fiber构造循环</code>呢,别着急</p><p><img src="https://s2.loli.net/2023/11/12/fy3hNnuvwm5K7ac.png"></p><p>看到没，在决定完何时执行<code>performSyncWorkOnRoot</code>或<code>performCocurrentWorkOnRoot</code>之后，<code>scheduler</code>把皮球（就是<code>task</code>啦🤐）踢给了<code>reconciler</code>，<code>reconciler</code>立即执行这俩函数，调用<code>ReactFiberWorkLoop</code>构建新的<code>fiber tree</code>, 构造完之后，就会执行最后操作–<code>commitRoot</code>，把最新的<code>fiber tree</code>渲染到页面上。</p><p>但那就是另一个故事咯😍</p><h2 id="三、二者联系和区别"><a href="#三、二者联系和区别" class="headerlink" title="三、二者联系和区别"></a>三、二者联系和区别</h2><ol><li>区别<ul><li><code>任务调度循环</code>是以<code>二叉堆</code>为数据结构, 循环执行<code>堆</code>的顶点, 直到<code>堆</code>被清空.</li><li><code>任务调度循环</code>的逻辑偏向宏观, 它调度的是每一个任务(<code>task</code>), 而不关心这个任务具体是干什么的(甚至可以将<code>Scheduler</code>包脱离<code>react</code>使用), 具体任务其实就是执行回调函数<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>.</li><li><code>fiber构造循环</code>是以<code>树</code>为数据结构, 从上至下执行深度优先遍历</li><li><code>fiber构造循环</code>的逻辑偏向具体实现, 它只是任务(<code>task</code>)的一部分(如<code>performSyncWorkOnRoot</code>包括: <code>fiber</code>树的构造, <code>DOM</code>渲染, 调度检测), 只负责<code>fiber</code>树的构造.</li></ul></li><li>联系<ul><li><code>fiber构造循环</code>是<code>任务调度循环</code>中的任务(<code>task</code>)的一部分. 它们是从属关系, 每个任务都会重新构造一个<code>fiber</code>树.</li></ul></li></ol><h2 id="四、好奇宝宝"><a href="#四、好奇宝宝" class="headerlink" title="四、好奇宝宝"></a>四、好奇宝宝</h2><p>好啦，看到这里，两个基本循环就已经差不多啦，但是不知道各位有没有跟我一样的疑惑，就是 <strong>构建个破<code>fiber tree</code>要什么循环呢？</strong>😡</p><p>为此，我去问了GPT大人, 以下是它的回答：</p><blockquote><p>在Fiber架构之前，React的更新过程是<strong>递归的且不能中断</strong>，这意味着一旦开始更新过程，就必须一直运行到结束，即使它可能阻塞主线程，导致用户界面变得无响应。</p><p>Fiber架构通过引入工作循环和Fiber树来解决这些问题：</p><ol><li><strong>增量渲染</strong>：<ul><li>通过将渲染工作分解成小的单元，React可以在需要时暂停和恢复工作。这种方式被称为增量渲染（Incremental Rendering）。</li></ul></li><li><strong>任务可中断</strong>：<ul><li>工作循环允许React的渲染过程可以被中断。当浏览器需要执行高优先级的任务，如处理用户输入，React可以中断正在进行的渲染，先去响应用户的操作。</li></ul></li><li><strong>任务优先级</strong>：<ul><li>不同的更新可以有不同的优先级。React可以决定哪些更新是紧急的，哪些可以稍后再处理。</li></ul></li><li><strong>更好的资源管理</strong>：<ul><li>使用工作循环，React可以根据浏览器的帧率和其他指标来调整工作负载，这有助于避免掉帧，使得应用看起来更平滑。</li></ul></li><li><strong>并发模式</strong>：<ul><li>Fiber架构是React并发模式（Concurrent Mode）的基础。在这种模式下，React可以同时处理多个更新，而且可以根据更新的重要性来调整它们的完成顺序。</li></ul></li></ol><p>在构建Fiber树时使用工作循环使得React能够更加灵活和高效地处理更新，这是一个在保持应用性能和用户体验方面都有重大改进的架构决策。通过工作循环，React可以更智能地利用浏览器的主线程，避免长时间占用导致的用户界面卡顿，从而提供了更好的用户体验。</p></blockquote><p>看来这是<code>渲染</code>和<code>scheduler</code>的一场宫斗大戏啊🤣，原来的<code>渲染</code>是老大，谁都动不了他，之后<code>schduler</code>被宠幸，地位上去了，渲染就被打入<code>ReactFiberWorkLoop</code>这个冷宫🥶，任<code>scheduler</code>摆布</p><p>虽然如此，还是支持<code>fiber loop</code>正义薄纱， 毕竟用户才是唯一正宫🤣</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>react进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>react进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react基本包</title>
    <link href="/2023/11/05/ReactBasePackage/"/>
    <url>/2023/11/05/ReactBasePackage/</url>
    
    <content type="html"><![CDATA[<h1 id="React-应用的宏观包结构-web-开发"><a href="#React-应用的宏观包结构-web-开发" class="headerlink" title="React 应用的宏观包结构(web 开发)"></a>React 应用的宏观包结构(web 开发)</h1><blockquote><p>React 工程目录的 packages 下包含 35 个包(<a href="https://github.com/facebook/react/tree/v17.0.2"><code>@17.0.2</code>版本</a>).<br>其中与<code>web</code>开发相关的核心包共有 4 个</p></blockquote><h2 id="基础包结构"><a href="#基础包结构" class="headerlink" title="基础包结构"></a>基础包结构</h2><ol><li><p>react</p><blockquote><p>react 基础包, 只提供定义 react 组件(<code>ReactElement</code>)的必要函数, 一般来说需要和渲染器(<code>react-dom</code>,<code>react-native</code>)一同使用. 在编写<code>react</code>应用的代码时, 大部分都是调用此包的 api.</p></blockquote></li><li><p>react-dom</p><blockquote><p>react 渲染器之一, 是 react 与 web 平台连接的桥梁(可以在浏览器和 nodejs 环境中使用), 将<code>react-reconciler</code>中的运行结果输出到 web 界面上. 在编写<code>react</code>应用的代码时,大多数场景下, 能用到此包的就是一个入口函数<code>ReactDOM.render(&lt;App/&gt;, document.getElementById(&#39;root&#39;))</code>, 其余使用的 api, 基本是<code>react</code>包提供的.</p></blockquote></li><li><p>react-reconciler</p><blockquote><p>react 得以运行的核心包(综合协调<code>react-dom</code>,<code>react</code>,<code>scheduler</code>各包之间的调用与配合).<br>管理 react 应用状态的输入和结果的输出. 将输入信号最终转换成输出信号传递给渲染器.</p></blockquote><ul><li>接受输入(<code>scheduleUpdateOnFiber</code>), 将<code>fiber</code>树生成逻辑封装到一个回调函数中(涉及<code>fiber</code>树形结构, <code>fiber.updateQueue</code>队列, 调和算法等),</li><li>把此回调函数(<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>)送入<code>scheduler</code>进行调度</li><li><code>scheduler</code>会控制回调函数执行的时机, 回调函数执行完成后得到全新的 fiber 树</li><li>再调用渲染器(如<code>react-dom</code>, <code>react-native</code>等)将 fiber 树形结构最终反映到界面上</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">主要职责是处理组件树的更新。这包括比较旧的组件树与新的组件树（由组件的状态或属性变化触发）,也就是diff算法，并决定需要进行哪些DOM更新。Reconciler 还决定更新的优先级，并为这些更新生成工作单元（即Fibers）。`performSyncWorkOnRoot` 是在这个过程中被调用，用于处理那些被标记为同步的更新任务<br></code></pre></td></tr></table></figure></li><li><p>scheduler</p><blockquote><p>调度机制的核心实现, 控制由<code>react-reconciler</code>送入的回调函数的执行时机, 在<code>concurrent</code>模式下可以实现任务分片. 在编写<code>react</code>应用的代码时, 同样几乎不会直接用到此包提供的 api.</p></blockquote><ul><li>核心任务就是执行回调(回调函数由<code>react-reconciler</code>提供)</li><li>通过控制回调函数的执行时机, 来达到任务分片的目的, 实现可中断渲染(<code>concurrent</code>模式下才有此特性)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">个人理解，它就像是个将军，负责指挥之后的任务，后边的小弟都得听他的<br></code></pre></td></tr></table></figure></li></ol><h2 id="宏观总览"><a href="#宏观总览" class="headerlink" title="宏观总览"></a>宏观总览</h2><h3 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h3><p>为了便于理解, 可将 react 应用整体结构分为接口层(<code>api</code>)和内核层(<code>core</code>)2 个部分</p><ol><li><p>接口层(api)<br><code>react</code>包, 平时在开发过程中使用的绝大部分<code>api</code>均来自此包(不是所有). 在<code>react</code>启动之后, 正常可以改变渲染的基本操作有 3 个.</p><ul><li>class 组件中使用<code>setState()</code></li><li>function 组件里面使用 hook,并发起<code>dispatchAction</code>去改变 hook 对象</li><li>改变 context(其实也需要<code>setState</code>或<code>dispatchAction</code>的辅助才能改变)</li></ul><p>以上<code>setState</code>和<code>dispatchAction</code>都由<code>react</code>包直接暴露. 所以要想 react 工作, 基本上是调用<code>react</code>包的 api 去与其他包进行交互.</p></li><li><p>内核层(core)<br>整个内核部分, 由 3 部分构成:</p><ol><li>调度器<br><code>scheduler</code>包, 核心职责只有 1 个, 就是执行回调.<ul><li>把<code>react-reconciler</code>提供的回调函数, 包装到一个任务对象中.</li><li>在内部维护一个任务队列, 优先级高的排在最前面.</li><li>循环消费任务队列, 直到队列清空.</li></ul></li><li>构造器<br><code>react-reconciler</code>包, 有 3 个核心职责:<ol><li>装载渲染器, 渲染器必须实现<a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/README.md#practical-examples"><code>HostConfig</code>协议</a>(如: <code>react-dom</code>), 保证在需要的时候, 能够正确调用渲染器的 api, 生成实际节点(如: <code>dom</code>节点).</li><li>接收<code>react-dom</code>包(初次<code>render</code>)和<code>react</code>包(后续更新<code>setState</code>)发起的更新请求.</li><li>将<code>fiber</code>树的构造过程包装在一个回调函数中, 并将此回调函数传入到<code>scheduler</code>包等待调度.</li></ol></li><li>渲染器<br><code>react-dom</code>包, 有 2 个核心职责:<ol><li>引导<code>react</code>应用的启动(通过<code>ReactDOM.render</code>).</li><li>实现<a href="https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/README.md#practical-examples"><code>HostConfig</code>协议</a>, 能够将<code>react-reconciler</code>包构造出来的<code>fiber</code>树表现出来, 生成 dom 节点(浏览器中), 生成字符串(ssr).</li></ol></li></ol></li></ol><h3 id="内核关系"><a href="#内核关系" class="headerlink" title="内核关系"></a>内核关系</h3><p>现将内核 3 个包的主要职责和调用关系, 绘制到一张概览图上:</p><p><img src="https://s2.loli.net/2023/11/05/fPF5V7rGqxmtkjw.png"></p><p>注意:</p><ul><li>红色方块代表入口函数, 绿色方块代表出口函数.</li><li>package 之间的调用脉络就是通过板块间的入口和出口函数连接起来的.</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>react进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>react进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Symbol公认符号</title>
    <link href="/2023/10/29/Symbol/"/>
    <url>/2023/10/29/Symbol/</url>
    
    <content type="html"><![CDATA[<h2 id="Symbol的公认符号"><a href="#Symbol的公认符号" class="headerlink" title="Symbol的公认符号"></a>Symbol的公认符号</h2><h3 id="经典面试题起手😀"><a href="#经典面试题起手😀" class="headerlink" title="经典面试题起手😀"></a>经典面试题起手😀</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">let <span class="hljs-attr">girlfriend</span><span class="hljs-operator">=</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    name:</span>’肖鹿😍’,<br><span class="hljs-symbol">    age:</span><span class="hljs-number">18</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>要实现以下效果：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>([...pro]) <br><span class="hljs-comment">// 输出 [&#x27;肖鹿😍&#x27;, 18]</span><br></code></pre></td></tr></table></figure><p>咱们知道 <code>[...arg]</code> 这种展开方法只能对 <code>可迭代对象</code> 使用，然而可迭代对象只包括 <code>Map, Set, Array, WeakMap</code>，那么如何让一个普通对象变得可迭代呢？这就要用到咱们今天说的公认符号啦☑️</p><hr><h3 id="1-趁热打铁，Symbol-iterator-和-Symbol-asyncIterator😏"><a href="#1-趁热打铁，Symbol-iterator-和-Symbol-asyncIterator😏" class="headerlink" title="1. 趁热打铁，Symbol.iterator 和 Symbol.asyncIterator😏"></a>1. 趁热打铁，Symbol.iterator 和 Symbol.asyncIterator😏</h3><p>这一刻也没有为可迭代对象哀悼，即将赶到战场的是 <code>Symbol.iterator</code>, 它的作用就是让一个普通对象转变为一个可迭代对象， 让我们来看看它是怎么实现的吧🤩</p><p>就比如说咱们最熟悉的 <code>map</code> 方法，当我们 <code>map</code> 的时候，<code>iterator</code>起到了什么作用呢？ 让我们来模拟一个简单的 <code>map</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">map</span>(<span class="hljs-params">ite, f</span>) &#123;<br>    <span class="hljs-comment">// 生成迭代器</span><br>    <span class="hljs-keyword">let</span> iterator = ite[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-comment">// 迭代器自身也迭代，更符合逻辑</span><br>        [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>        &#125;<br>        <span class="hljs-comment">// 迭代器必须有一个next()方法</span><br>        <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">let</span> res = iterator.<span class="hljs-title function_">next</span>()<br>            <span class="hljs-keyword">if</span>(res.<span class="hljs-property">done</span>) &#123;<br>                <span class="hljs-keyword">return</span> res<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: <span class="hljs-title function_">f</span>(res.<span class="hljs-property">value</span>)&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">在 `f<span class="hljs-literal">or</span>/of` 循环里，会先调用 `symbol.iterator` 生成迭代器，之后一直调用 `next()` 方法，直到返回的 `done` 为 `true`😎<br></code></pre></td></tr></table></figure><p>现在再看那道面试题，是不是就迎刃而解了😗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> girlfriend= &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;肖鹿😍&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span><br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">return</span> count &lt; <span class="hljs-number">2</span> ? &#123;<span class="hljs-attr">value</span>:that[<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(that)[count++]]&#125; : &#123;<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;<br>            &#125;,<br>            [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>&#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...girlfriend])<br><br></code></pre></td></tr></table></figure><p>这样其实还有点麻烦，可以和生成器结合😏， 由于生成器也是一个特殊的迭代器，所以可以将上面的代码简化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> girlfriend=&#123;<br>    <span class="hljs-attr">name</span>:’肖鹿😍’,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span><br>    *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()&#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当时我看到这个的时候确实被震撼到了，原来还可以这么玩🌟</p><h4 id="async版本的iterator功能更强大，可以异步控制迭代器的输出，但是这不是咱们今天的重点，感兴趣的话可以去看看🦏书的第12章末尾，有一个异步可迭代队列的例子"><a href="#async版本的iterator功能更强大，可以异步控制迭代器的输出，但是这不是咱们今天的重点，感兴趣的话可以去看看🦏书的第12章末尾，有一个异步可迭代队列的例子" class="headerlink" title="async版本的iterator功能更强大，可以异步控制迭代器的输出，但是这不是咱们今天的重点，感兴趣的话可以去看看🦏书的第12章末尾，有一个异步可迭代队列的例子"></a>async版本的iterator功能更强大，可以异步控制迭代器的输出，但是这不是咱们今天的重点，感兴趣的话可以去看看🦏书的第12章末尾，有一个异步可迭代队列的例子</h4><hr><h3 id="2-定形数组的爹，Symbol-hasInstance😀"><a href="#2-定形数组的爹，Symbol-hasInstance😀" class="headerlink" title="2. 定形数组的爹，Symbol.hasInstance😀"></a>2. 定形数组的爹，Symbol.hasInstance😀</h3><p>在 <strong>ES6</strong> 中，当我们使用 <code>instanceof </code> 的时候，会先调用<code> [Symbol.hasInstance]</code>这个方法， 如果没有这个方法，则会采用 <strong>ES5</strong> 的方法，从原型链上查找它的prototype</p><p><strong>这就可以自定义instanceof啦！</strong></p><p>来看🌰：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> uint8 = &#123;<br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>]() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(x) &amp;&amp; x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= <span class="hljs-number">256</span><br>    &#125;<br>&#125;<br><br><span class="hljs-number">128</span> <span class="hljs-keyword">instanceof</span> uint8<br><br></code></pre></td></tr></table></figure><h3 id="3-Symbol-toStringTag"><a href="#3-Symbol-toStringTag" class="headerlink" title="3. Symbol.toStringTag"></a>3. Symbol.toStringTag</h3><p>这个就厉害了， 在 <code>ES6</code>中， toString方法会先调用<code>Symbol.toStringTag</code>, 如果没有， 那就是经典的 <code>[Object, Object]</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">girlfriend</span> &#123;<br>    [<span class="hljs-built_in">Symbol</span>.toStringTag]= <span class="hljs-string">&quot;肖鹿小姐😍&quot;</span><br>&#125;<br><br> <span class="hljs-regexp">//</span> get [<span class="hljs-built_in">Symbol</span>.toStringTag]() &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;肖鹿小姐😍&quot;</span>&#125; 这样用getter定义更加专业，并且不会被枚举<br><br>let MyWife = <span class="hljs-keyword">new</span> girlfriend()<br><br>console.log(MyWife.toString())<br></code></pre></td></tr></table></figure><h3 id="4-Symbol-species"><a href="#4-Symbol-species" class="headerlink" title="4. Symbol.species"></a>4. Symbol.species</h3><p>这个方法比较冷门，但是确实实用，在 <code>ES6</code> 中， 继承的时候会把上一层的species也继承过来，<code>map</code> 以及 <code>slice</code> 等函数会先调用 <code>new this.constructor[Symbol.species]() 创建新数组</code></p><p>比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">WifeArray</span> <span class="hljs-title">extends</span> <span class="hljs-title">Array</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> [Symbol.species]() &#123;<span class="hljs-keyword">return</span> WifeArray&#125;<br>    <span class="hljs-keyword">get</span> [Symbol.toStringTag]() &#123;<span class="hljs-keyword">return</span> WifeArray&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">first</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>]&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">last</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-keyword">this</span>.length<span class="hljs-number">-1</span>]&#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> WifeArray(<span class="hljs-string">&#x27;肖&#x27;</span>, <span class="hljs-string">&#x27;鹿&#x27;</span>, <span class="hljs-string">&#x27;😍&#x27;</span>)<br><span class="hljs-keyword">let</span> f = e.map(item =&gt; item + <span class="hljs-string">&#x27;🥰&#x27;</span>)<br>console.log(f)<br></code></pre></td></tr></table></figure><h3 id="5-Symbol-isConcatSpreadable🤐"><a href="#5-Symbol-isConcatSpreadable🤐" class="headerlink" title="5. Symbol.isConcatSpreadable🤐"></a>5. Symbol.isConcatSpreadable🤐</h3><p>如果是一个数组concat另一个数组，会发生什么？比如 <code>[1]</code> 和 <code>[2]</code>，是会变成 <code>[1,2]</code>, 还是 <code>[[1], [2]]</code> ？这就是咱们 isConcatSpreadable 发挥的地方了</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">let <span class="hljs-built_in">array</span>like = &#123;<br>    length: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">0</span>:<span class="hljs-number">1</span>,<br><span class="hljs-string">    [Symbol.isConcatSpreadable]</span>: <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-string"></span><br><span class="hljs-string">[]</span>.concat(<span class="hljs-built_in">array</span>like)<br></code></pre></td></tr></table></figure><p>简单吧😏</p><h3 id="6-唯一真神，Symbol-toPrimitive🐶🐶🐶🐶🐶🐶🐶🐶"><a href="#6-唯一真神，Symbol-toPrimitive🐶🐶🐶🐶🐶🐶🐶🐶" class="headerlink" title="6. 唯一真神，Symbol.toPrimitive🐶🐶🐶🐶🐶🐶🐶🐶"></a>6. 唯一真神，Symbol.toPrimitive🐶🐶🐶🐶🐶🐶🐶🐶</h3><h4 id="还是经典面试题起手"><a href="#还是经典面试题起手" class="headerlink" title="还是经典面试题起手"></a>还是经典面试题起手</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> a;<br><span class="hljs-attribute">a</span> == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span> 什么时候成立？<br></code></pre></td></tr></table></figure><p>除了经典做法，还可以使用Symbol.toPrimitive方法，为什么说它是唯一真神，就是因为它<strong>可以覆盖 <code>valueOf</code> 和 <code>toString</code> 这两个幻神方法</strong></p><p>使用 <code>Symbol.toPrimitive</code> 也很简单, 只不过要注意，与 <code>valueOf</code> 和 <code>toString</code> 不同，它接受一个参数 <code>hint</code>, <code>hint</code>有三个取值： <code>default</code>, <code>string</code>, <code>number</code></p><pre><code class="hljs">--&quot;string&quot;：当需要一个字符串表示的对象时，例如通过 String(obj) 进行转换或在某些与字符串相关的操作中（如调用 alert(obj)）。在这种情况下，JavaScript会尝试优先调用对象的 toString 方法（如果存在），然后尝试 valueOf 方法。-- &quot;number&quot;：当需要一个数字表示的对象时，例如通过 Number(obj) 进行转换、算术运算（如 +obj 或 obj - 0）。在这种情况下，JavaScript会尝试优先调用对象的 valueOf 方法（如果存在），然后尝试 toString 方法。-- &quot;default&quot;：当操作不需要特定的类型（既不需要字符串也不需要数字），例如使用双等号 == 进行比较。在这种情况下，多数情况下的行为与 &quot;number&quot; 类似，但并非总是如此。例如，使用二进制加法操作符 + 时，如果其中一个操作数是对象，那么该对象的 Symbol.toPrimitive 方法（如果存在）会被调用并传入 &quot;default&quot; 作为 hint。</code></pre><p>因此，可以将上面的面试题改写成： </p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">a = &#123;<br>    [<span class="hljs-built_in">Symbol</span>.toPrimitive]: <span class="hljs-function">(<span class="hljs-params">(i)</span> =&gt;</span> () =&gt; ++i) (<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的写法比较巧妙， 分为外层立即执行函数， 内层(i) &#x3D;&gt; (), 最内层 () &#x3D;&gt; ++i，因此会形成闭包，之后每一次调用都会使返回值递增</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染原理</title>
    <link href="/2023/10/14/tmp%20(2)/"/>
    <url>/2023/10/14/tmp%20(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><h3 id="1-parseHTML"><a href="#1-parseHTML" class="headerlink" title="1.parseHTML"></a>1.parseHTML</h3><p>网络线程在接受到HTML文件后会生成一个渲染任务，推入到渲染主线程的消息队列中，在事件循环的作用下，渲染主线程取出渲染任务并执行</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">为了快速解析文件，在解析开始之前，会启动预解析线程，遇到css文件就下载，遇到<span class="hljs-keyword">js</span>就执行，如果解析时遇到css而预解析线程还没下载完成，主线程不会等待，但如果是<span class="hljs-keyword">js</span>，主线程会暂停所有任务<br></code></pre></td></tr></table></figure><p>在解析完成后，会生成DOM树和CSSOM树</p><h3 id="2-1-生成DOM树和CSSOM树"><a href="#2-1-生成DOM树和CSSOM树" class="headerlink" title="2.1.生成DOM树和CSSOM树"></a>2.1.生成DOM树和CSSOM树</h3><p><code>CSSOM树</code>: 包含StyleSheetList -&gt; CSSStyleSheet -&gt; CSSStyleRule</p><p><code>StyleSheetList</code>: 包含不同的StyleSheet，一共有四种： <code>内部样式表，内联样式表，外部样式表，默认样式表</code></p><p><code>CSSStyleRule</code>: 包含选择器和声明</p><h3 id="2-2-合并DOM树和CSSOM树（样式计算）"><a href="#2-2-合并DOM树和CSSOM树（样式计算）" class="headerlink" title="2.2.合并DOM树和CSSOM树（样式计算）"></a>2.2.合并DOM树和CSSOM树（样式计算）</h3><p>样式计算，计算出最终样式，比如<code>color: red</code>会变成<code>color: rgb(255,0,0)</code></p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol><li><p>CSS属性值的计算过程</p><ol><li>层叠</li><li>继承</li></ol></li><li><p>视觉格式化模型</p><ol><li>盒模型</li><li>包含块</li></ol></li></ol><h3 id="3-生成layout树"><a href="#3-生成layout树" class="headerlink" title="3.生成layout树"></a>3.生成layout树</h3><p>合并后的dom树和与之对应生成的layout树不一定一一对应，display:none的元素,没有<code>几何信息</code>，不会存在在layout树中。或者说伪元素在DOM树中不存在，但是由于他有几何信息，会出现在layout树中。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl">在<span class="hljs-keyword">layout</span>树中：<br><br>行盒块盒不能相邻<br>内容必须在行盒中<br><br>如果相邻，会在行盒上层创建匿名块盒包裹行盒<br>如果内容不在行盒中，会在内容外部套一层匿名行盒<br><br>这也会导致<span class="hljs-keyword">layout</span>树和dom树不一样<br></code></pre></td></tr></table></figure><h3 id="4-分层"><a href="#4-分层" class="headerlink" title="4.分层"></a>4.分层</h3><p>浏览器主线程自动分层，分层可以减少重绘的次数和数量，优化性能</p><p>如果经常需要重绘，可以在css中使用will-change更大程度影响分层。</p><h3 id="5-绘制"><a href="#5-绘制" class="headerlink" title="5.绘制"></a>5.绘制</h3><p>主线程成绘制的指令（与canvas类似），每层都会生成单独的绘制指令。渲染主线程工作到此为止，剩余步骤交给其余线程。</p><h3 id="6-分块"><a href="#6-分块" class="headerlink" title="6.分块"></a>6.分块</h3><p>完成绘制之后，主线程会把每个图层的绘制信息交给合成线程进行划分快操作。<br>分块将每一层分为更小的块，优先绘制离视口近的区域。<br>分块工作交给合成线程处理，合成线程也处于渲染进程中，它可以启动许多线程，多线程处理分块。会从线程池中挑取多个线程完成工作</p><h3 id="7-光栅化"><a href="#7-光栅化" class="headerlink" title="7.光栅化"></a>7.光栅化</h3><p>把每个块变成位图，包含每个点的像素信息，优先处理靠近视口的块。光栅化会在gpu中进行。光栅化的结果就是一块一块的位图</p><h3 id="8-画"><a href="#8-画" class="headerlink" title="8.画"></a>8.画</h3><p>合成线程计算出每个位图在屏幕上的位置，生成quad信息，并把quad送进gpu，gpu再委派给其他硬件进行计算</p><p>transform也在画的过程中进行，不在主线程中进行，因此transform效率高</p><p>quad：指引信息，描述位图的位置距离屏幕的距离</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">因为渲染进程处在沙盒中，与硬件环境隔离，提高安全性，所以不能直接委派任务给硬件，要先交给gpu<br></code></pre></td></tr></table></figure><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="https://s2.loli.net/2023/09/25/Cv7ms1q4aVnLSRY.png" alt="整体流程"></p><h3 id="ques"><a href="#ques" class="headerlink" title="ques:"></a>ques:</h3><ol><li><p>什么是reflow</p><p> reflow的本质就是重新计算layout树，layout树之后的分层、绘制、分块、光栅化、画都会根据情况决定重新执行与否。</p> <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">为了避免layout树的重复计算，浏览器异步处理对layout树的操作，在js执行完之后，取出<span class="hljs-built_in">ref</span>low的任务批量处理，这也是为什么dom元素修改是微任务的原因<br><br>也因此，浏览器获取dom信息时，可能会得到修改前的信息<br><br>修改颜色等属性并不会触发<span class="hljs-built_in">ref</span>low，因为并没有修改几何信息<br></code></pre></td></tr></table></figure></li><li><p>什么是repaint</p><p> repaint的本质就是重新根据分层信息重新计算了绘制指令。改动了可见元素的属性后，就会触发repaint。</p> <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">由于布局的几何信息也属于可见元素的属性，因此<span class="hljs-built_in">ref</span>low触发也一定会触发repaint<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器执行原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>浏览器执行原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环和raf</title>
    <link href="/2023/09/16/eventloop&amp;raf/"/>
    <url>/2023/09/16/eventloop&amp;raf/</url>
    
    <content type="html"><![CDATA[<h2 id="事件循环和raf"><a href="#事件循环和raf" class="headerlink" title="事件循环和raf"></a>事件循环和raf</h2><h3 id="一-为什么需要事件循环"><a href="#一-为什么需要事件循环" class="headerlink" title="一. 为什么需要事件循环"></a>一. 为什么需要事件循环</h3><p>由于js是<code>单线程</code>执行的，所以设计了事件循环用于处理<code>异步函数</code></p><h3 id="二-事件循环介绍"><a href="#二-事件循环介绍" class="headerlink" title="二. 事件循环介绍"></a>二. 事件循环介绍</h3><h4 id="1-队列"><a href="#1-队列" class="headerlink" title="1. 队列"></a>1. 队列</h4><p>事件循环中<code>至少</code>需要两个队列 – <code>宏任务队列</code>、 <code>微任务队列</code>，可能有其他不同的队列，不同浏览器有不同的方案</p><p>其中<code>宏任务队列</code>主要包含<code>点击事件</code>、<code>计时器</code>、<code>网络请求</code>的回调<br><code>微任务队列</code>主要包含<code>Promise</code>、<code>async</code>中的<code>await</code>后的语句</p><h4 id="2-队列机制"><a href="#2-队列机制" class="headerlink" title="2. 队列机制"></a>2. 队列机制</h4><p>每个循环中，会先判断微任务队列是否为空，不为空就之行微任务队列直至队列空，然后从宏任务队列中取出一个任务执行，如果修改了DOM，会触发页面渲染</p><p>因此可以说： 队列优先处理微任务</p><p><img src="https://s2.loli.net/2023/09/16/IfFu1Z4b2OEDSQt.png" alt="Alt text"></p><p>来看题😀</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>  await async2();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br>&#125;<br><br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;c&#x27;</span>)<br>&#125;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;d&#x27;</span>)<br>async1();<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;e&#x27;</span>)<br>&#125;,<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;g&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="三-来看渲染😵"><a href="#三-来看渲染😵" class="headerlink" title="三. 来看渲染😵"></a>三. 来看渲染😵</h4><p><img src="https://s2.loli.net/2023/09/16/AFozdM5Jt8nlwUK.png" alt="Alt text"></p><p>前面说了setTimeout是宏任务，那结合事件队列的知识，setTimeout函数就需要等待之前的所有微任务和宏任务执行完才能执行，那就导致了一个问题： <code>setTimeout函数计时是不准的！</code></p><p>还要要知道浏览器的默认渲染频率是固定的，大概为每秒60帧</p><p><img src="https://s2.loli.net/2023/09/16/BDZiwp3UnmJo4LK.png" alt="Alt text"></p><p>所以用setTimeout整的动画函数执行频率会不同，可能每次渲染中执行的函数数量不同，看起来就会有抖动，还没完！</p><p>如果事件执行时间过长，还会导致丢帧，因为事件循环和渲染是两个独立的进程！js还是个单线程，两头顾不上</p><p><img src="https://s2.loli.net/2023/09/16/Lp9UhITesmjkg4V.png" alt="Alt text"></p><p>因此，js开发者们有了一个天才的点子，<code>raf</code>动画</p><h4 id="四-RAF"><a href="#四-RAF" class="headerlink" title="四. RAF"></a>四. RAF</h4><p>RequestAnimationFrame 是一个在现代 Web 开发中广泛使用的 JavaScript 方法，它用于在浏览器的下一次重绘之前执行动画帧，以提供更平滑的动画效果。这种方法通常用于创建用 HTML、CSS 和 JavaScript 编写的交互式网页动画。</p><p><img src="https://s2.loli.net/2023/09/16/n5L8I3qWsQbwer1.png" alt="Alt text"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;<br>    positionX += speed;<br>    <span class="hljs-keyword">if</span> (positionX &gt; <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>) &#123;<br>        positionX = -animatedElement.<span class="hljs-property">clientWidth</span>;<br>    &#125;<br>    <span class="hljs-title class_">Element</span>.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translateX(<span class="hljs-subst">$&#123;positionX&#125;</span>px)`</span>;<br>    <span class="hljs-title function_">requestAnimationFrame</span>(animate);<br>&#125;<br><br><span class="hljs-title function_">animate</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器执行原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>浏览器执行原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS</title>
    <link href="/2023/09/10/CSS/"/>
    <url>/2023/09/10/CSS/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS😀"><a href="#CSS😀" class="headerlink" title="CSS😀"></a>CSS😀</h2><h3 id="1-CSS简介😶‍🌫️"><a href="#1-CSS简介😶‍🌫️" class="headerlink" title="1.CSS简介😶‍🌫️"></a>1.CSS简介😶‍🌫️</h3><p>CSS (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，是前端技术中十分重要的一环🐶。</p><p>通过使用 CSS 我们可以大大提升网页开发的工作效率！</p><hr><h3 id="2-CSS语法介绍😗"><a href="#2-CSS语法介绍😗" class="headerlink" title="2.CSS语法介绍😗"></a>2.CSS语法介绍😗</h3><p>CSS 规则由两个主要的部分构成：<code>选择器</code>，以及一条或多条<code>声明</code>:</p><p><code>选择器</code>通常是您需要改变样式的 <code>HTML 元素</code>。</p><p>每条<code>声明</code>由一个<code>属性</code>和一个<code>值</code>组成。</p><p><code>属性（property）</code>是您希望设置的样式属性（style attribute）。每个属性有一个值。<em>属性和值被冒号分开</em>。😏</p><hr><h3 id="3-声明🫥"><a href="#3-声明🫥" class="headerlink" title="3.声明🫥"></a>3.声明🫥</h3><p><code>CSS声明</code>总是以分号<code>;</code>结束，<code>声明</code>总以大括号<code>&#123;&#125;</code>括起来:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:red;<span class="hljs-attribute">text-align</span>:center;&#125;<br></code></pre></td></tr></table></figure><p>为了让CSS可读性更强，你可以每行只描述一个属性:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>:red;<br>    <span class="hljs-attribute">text-align</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-选择器🌟"><a href="#4-选择器🌟" class="headerlink" title="4.选择器🌟"></a>4.选择器🌟</h3><p>CSS选择器用于选择你想要为其应用样式的HTML元素。以下是一些常见的CSS选择器及其描述：</p><ol><li><p><strong>通用选择器</strong> (<code>*</code>):<br>选择页面上的所有元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>类型选择器</strong> (或元素选择器):<br>选择所有给定的HTML元素类型。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>类选择器</strong> (<code>.</code>):<br>选择所有带有指定类属性的元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.highlight</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>ID选择器</strong> (<code>#</code>):<br>选择带有指定ID属性的元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#header</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>后代选择器</strong> (空格):<br>选择特定元素的后代。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>子元素选择器</strong> (<code>&gt;</code>):<br>选择特定元素的直接子元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">list-style-type</span>: square;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>相邻兄弟选择器</strong> (<code>+</code>):<br>选择紧接在另一个元素后的元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span> + <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>属性选择器</strong>:<br>选择带有指定属性的元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>伪类选择器</strong> (<code>:</code>):<br>选择元素的特定状态。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>伪元素选择器</strong> (<code>::</code>):<br>选择元素的特定部分，如首行或首字母。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>分组选择器</strong>:<br>将多个选择器分组以应用相同的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">h3</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这只是CSS选择器的基础。随着CSS的发展，还有许多其他的选择器和组合方法可以使用，以满足更复杂的选择需求。</p><hr><h3 id="5-选择器权重😍"><a href="#5-选择器权重😍" class="headerlink" title="5.选择器权重😍"></a>5.选择器权重😍</h3><p>在CSS中，选择器的权重（或优先级）决定了哪些样式规则将被应用到元素上，特别是当多个规则与同一个元素匹配时。选择器的权重是基于其类型和结构来计算的。</p><p>以下是选择器权重的基本规则：</p><ol><li><p><strong>类型选择器和伪元素</strong> (例如 <code>h1</code>, <code>::before</code>):</p><ul><li>权重: 0-0-1 &#x3D;&gt; 1</li></ul></li><li><p><strong>类选择器、属性选择器和伪类</strong> (例如 <code>.classname</code>, <code>[type=&quot;text&quot;]</code>, <code>:hover</code>):</p><ul><li>权重: 0-1-0 &#x3D;&gt; 2</li></ul></li><li><p><strong>ID选择器</strong> (例如 <code>#idname</code>):</p><ul><li>权重: 1-0-0 &#x3D;&gt; 4</li></ul></li><li><p><strong>内联样式</strong> (直接在HTML元素上使用的<code>style</code>属性):</p><ul><li>权重: 1-0-0-0 &#x3D;&gt; infinite</li></ul></li><li><p><strong>通用选择器</strong> (<code>*</code>), <strong>组合符</strong> (例如 <code>+</code>, <code>&gt;</code>, <code>~</code>, 空格) 和 <strong>否定伪类</strong> (<code>:not()</code>) 对权重没有影响。</p></li><li><p><strong>重要性</strong> (<code>!important</code>): 如果在样式声明后添加了<code>!important</code>，则该声明的权重会超过其他任何声明。但是，如果有多个<code>!important</code>声明，那么上述权重规则仍然适用于确定哪个声明最重要。</p></li></ol><p>权重计算示例：</p><ul><li><code>#id</code>: 1-0-0</li><li><code>.class</code>: 0-1-0</li><li><code>h1</code>: 0-0-1</li><li><code>#id .class h1</code>: 1-1-1 &#x3D;&gt; 7</li></ul><p>当多个选择器目标同一个元素并有冲突的样式时，权重较高的选择器的样式将被应用。如果权重相同，那么在CSS文件中最后出现的规则将被应用。</p><p>为了避免权重问题和复杂性，建议尽量使用简单的选择器，并避免过度使用<code>!important</code>。</p><hr><h3 id="6-基本属性"><a href="#6-基本属性" class="headerlink" title="6.基本属性"></a>6.基本属性</h3><ol><li><p><strong>position</strong> : 定位 relative（默认） | absolute | fixed | sticky</p></li><li><p><strong>display</strong> : 元素显示模式 inline | block | inline-block | flex | grid …</p></li></ol><p>…</p><h3 id="6-实操部分🤔"><a href="#6-实操部分🤔" class="headerlink" title="6.实操部分🤔"></a>6.实操部分🤔</h3>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>css基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES13 新特性</title>
    <link href="/2023/08/30/New%20Document/"/>
    <url>/2023/08/30/New%20Document/</url>
    
    <content type="html"><![CDATA[<h1 id="ES13-新特性"><a href="#ES13-新特性" class="headerlink" title="ES13 新特性"></a>ES13 新特性</h1><p>ES13（也称为 ES2020）是 ECMAScript 标准的最新版本，于 2020 年 6 月发布。它引入了一些新的语言特性，以帮助开发者更轻松地编写代码。以下是一些 ES13 的新特性：</p><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a><code>BigInt</code></h2><p><code>BigInt</code> 是一种新的 JavaScript 类型，用于表示任意精度的整数。在旧版 JavaScript 中，<code>Number</code> 类型只能表示 2 的 53 次方以内的整数，如果需要进行更大的数字计算，就需要借助第三方库。而 <code>BigInt</code> 可以表示任意长度的整数，例如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const bigIntNum = <span class="hljs-number">9007199254740991</span>n;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> bigIntNum); <span class="hljs-comment">// 输出 &quot;bigint&quot;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>BigInt</code> 类型的数字需要加上后缀 <code>n</code>。</p><h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h2><p>可选链操作符是一种新的语言特性，用于简化 JavaScript 代码中的属性访问。在旧版 JavaScript 中，我们通常会通过 &amp;&amp; 运算符来检查对象的属性是否存在，例如：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">if (<span class="hljs-keyword">person</span> &amp;&amp; <span class="hljs-keyword">person</span>.address &amp;&amp; <span class="hljs-keyword">person</span>.address.city) &#123;<br>  console.log(<span class="hljs-keyword">person</span>.address.city);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法虽然能够正常工作，但是会让代码变得冗长，尤其是在访问深层次的属性时。可选链操作符可以让我们更简洁地检查属性是否存在，例如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (person?.address?.city) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person.address.city);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>?.</code> 表示如果 <code>person</code> 或者 <code>address</code> 属性不存在，就不会再去访问 <code>city</code> 属性，避免了出现 TypeError。当然，如果你希望在访问不存在的属性时，返回一个默认值，也可以像下面这样使用可选链操作符：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const city = person?.address?.city ?? <span class="hljs-string">&#x27;Unknown&#x27;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(city);<br></code></pre></td></tr></table></figure><p>这里的 <code>??</code> 表示如果 <code>city</code> 为 null 或 undefined，就会返回 ‘Unknown’。</p><h2 id="Nullish-合并操作符"><a href="#Nullish-合并操作符" class="headerlink" title="Nullish 合并操作符"></a>Nullish 合并操作符</h2><p>Nullish 合并操作符是一种新的语言特性，用于解决 JavaScript 中变量默认值的问题。在 JavaScript 中，我们通常会用 || 运算符来给变量赋默认值，例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-type">name</span> = person.name || <span class="hljs-string">&#x27;Unknown&#x27;</span>;<br></code></pre></td></tr></table></figure><p>但是如果变量的值为 0 或者空字符串，这种写法就会出现问题，因为这些值在逻辑上是存在的。Nullish 合并操作符就是为了解决这个问题，它只会在变量的值为 null 或 undefined 时才会使用默认值，例如：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> <span class="hljs-keyword">name</span> = person.<span class="hljs-keyword">name</span> ?? <span class="hljs-string">&#x27;Unknown&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这里的 <code>??</code> 表示如果 <code>name</code> 为 null 或 undefined，就会返回 ‘Unknown’。如果 <code>name</code> 的值为 0 或空字符串，这种写法依然会将其视为存在</p><h2 id="类的私有方法-属性："><a href="#类的私有方法-属性：" class="headerlink" title="类的私有方法&#x2F;属性："></a>类的私有方法&#x2F;属性：</h2><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs leaf"><br>class MyClass &#123;<br>  <span class="hljs-punctuation">#</span><span class="hljs-keyword">myPrivateMethod</span><span class="hljs-params">()</span> &#123;<br>    console.log(&#x27;This is a private method&#x27;);<br>  &#125;<br>  <span class="hljs-punctuation">#</span><span class="hljs-keyword">privateName</span> = &#x27;lkq&#x27;<br>  myPublicMethod() &#123;<br>    console.log(&#x27;This is a public method&#x27;);<br>    this.<span class="hljs-punctuation">#</span><span class="hljs-keyword">myPrivateMethod</span><span class="hljs-params">()</span>;<br>  &#125;<br>&#125;<br><br>const myInstance = new MyClass();<br>myInstance.myPublicMethod(); <br>myInstance.<span class="hljs-punctuation">#</span><span class="hljs-keyword">myPrivateMethod</span><span class="hljs-params">()</span>; <br>console.log(myInstance.<span class="hljs-punctuation">#</span><span class="hljs-keyword">privateName</span>);<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个私有方法<code>#myPrivateMethod()</code>，并在公共方法<code>myPublicMethod()</code>中调用它。在创建<code>MyClass</code>的实例时，我们可以使用<code>myPublicMethod()</code>方法，但是尝试直接调用私有方法时，会抛出一个<code>TypeError</code>。</p><ol start="2"><li>静态方法：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentClass</span> </span>&#123;<br>  static parentStaticMethod() &#123;<br>    console.log(&#x27;<span class="hljs-type">This</span> is a parent static method&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParentClass</span> </span>&#123;<br>  static childStaticMethod() &#123;<br>    console.log(&#x27;<span class="hljs-type">This</span> is a child static method&#x27;);<br>    <span class="hljs-keyword">super</span>.parentStaticMethod();<br>  &#125;<br>&#125;<br><br><span class="hljs-type">ChildClass</span>.childStaticMethod(); <span class="hljs-comment">// 输出: This is a child static method</span><br><span class="hljs-type">ChildClass</span>.parentStaticMethod(); <br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个父类<code>ParentClass</code>和一个子类<code>ChildClass</code>。父类中有一个静态方法<code>parentStaticMethod()</code>，子类中有一个静态方法<code>childStaticMethod()</code>，并且它调用了父类的静态方法。在调用子类的静态方法时，它将输出两个字符串。</p><h2 id="await运算符"><a href="#await运算符" class="headerlink" title="await运算符"></a>await运算符</h2><p>在 JavaScript 中，await 运算符用于暂停执行，直到 Promise 被解决（履行或拒绝）。</p><p>以前，我们只能在 async 函数中使用此运算符 - 使用 async 关键字声明的函数。我们无法在全球范围内这样做。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>function setTimeoutAsync(timeout) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>     resolve();<br>   &#125;, timeout);<br> &#125;);<br>&#125;<br><span class="hljs-regexp">//</span> SyntaxError: <span class="hljs-keyword">await</span> <span class="hljs-keyword">is</span> only valid <span class="hljs-keyword">in</span> <span class="hljs-keyword">async</span> functions<br><span class="hljs-keyword">await</span> setTimeoutAsync(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>使用 ES13，现在我们可以：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>function setTimeoutAsync(timeout) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>     resolve();<br>   &#125;, timeout);<br> &#125;);<br>&#125;<br><span class="hljs-regexp">//</span> Waits <span class="hljs-keyword">for</span> timeout - <span class="hljs-literal">no</span> error thrown<br><span class="hljs-keyword">await</span> setTimeoutAsync(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><h2 id="at-方法进行索引"><a href="#at-方法进行索引" class="headerlink" title="at() 方法进行索引"></a>at() 方法进行索引</h2><p>我们通常在 JavaScript 中使用方括号 ([]) 来访问数组的第 N 个元素，这通常是一个简单的过程，我们只访问数组的 N - 1 属性。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br>const arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr[<span class="hljs-number">1</span>]); <span class="hljs-comment">// b</span><br></code></pre></td></tr></table></figure><p>但是，如果我们想使用方括号访问数组末尾的第 N 个项目，我们必须使用 arr.length - N 的索引。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br>const arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br><span class="hljs-comment">// 1st element from the end</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr[arr.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>]); <span class="hljs-comment">// d</span><br><span class="hljs-comment">// 2nd element from the end</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr[arr.<span class="hljs-built_in">length</span> - <span class="hljs-number">2</span>]); <span class="hljs-comment">// c</span><br></code></pre></td></tr></table></figure><p>新的 at() 方法让我们可以更简洁、更有表现力地做到这一点，要访问数组末尾的第 N 个元素，我们只需将负值 -N 传递给 at()。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br>const arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br><span class="hljs-comment">// 1st element from the end</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.at(<span class="hljs-number">-1</span>)); <span class="hljs-comment">// d</span><br><span class="hljs-comment">// 2nd element from the end</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.at(<span class="hljs-number">-2</span>)); <span class="hljs-comment">// c</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async 和 await</title>
    <link href="/2023/07/10/async/"/>
    <url>/2023/07/10/async/</url>
    
    <content type="html"><![CDATA[<h1 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h1><h2 id="1、async函数"><a href="#1、async函数" class="headerlink" title="1、async函数"></a>1、async函数</h2><p>异步函数声明声明一个async function，其中函数体中允许使用 await 关键字。async 和 await 关键字允许以更简洁的样式编写异步、基于 promise 的行为，从而避免了显式配置承诺链的需要。</p><h2 id="2、Promise"><a href="#2、Promise" class="headerlink" title="2、Promise"></a>2、Promise</h2><p>Promise 对象表示异步操作的最终完成（或失败）及其结果值。Promise拥有自己的state</p><h3 id="2-1、Promise的state"><a href="#2-1、Promise的state" class="headerlink" title="2-1、Promise的state"></a>2-1、Promise的state</h3><p><code>pending</code>: initial state, neither fulfilled nor rejected.</p><p><code>fulfilled</code>: meaning that the operation was completed successfully.</p><p><code>rejected</code>: meaning that the operation failed.</p><h3 id="2-2、Promise的工作流程"><a href="#2-2、Promise的工作流程" class="headerlink" title="2-2、Promise的工作流程"></a>2-2、Promise的工作流程</h3><p>pending状态中如果执行被reject，那么Promise进入rejected状态，并调用.catch函数，如果执行成功，则进入fulfilled状态，并调用.then函数</p><h2 id="3、与Taro-request结合"><a href="#3、与Taro-request结合" class="headerlink" title="3、与Taro.request结合"></a>3、与Taro.request结合</h2><p>由于Taro.request返回的是一个Promise，如果直接将其输出，将会得到在pending状态的Promise，而不是希望得到的结果。这个时候，使用async函数，并使用await等待Promise执行完毕，则可获得.then函数中期望的返回值</p><pre><code class="hljs">async function InfoData() &#123;    const info = await Request(&#39;post&#39;,&#39;/project/games/find&#39;,Token,&#123;        &quot;crowd&quot;: `$&#123;crowdList[state.list[2]]&#125;`,        &#39;time&#39;:`$&#123;timeList[state.list[1]]&#125;`,        &quot;venue&quot;: `$&#123;placeList[state.list[0]]&#125;`,      &#125;)      setgameL(info.data.data)      console.log(&#39;info&#39;,info.data.data);      return info.data.data;  &#125;</code></pre><p>在上面的例子中，Request是封装好的请求函数，.then回调返回拿到的数据，如果直接使 </p><pre><code class="hljs">info = Request(&#39;post&#39;,&#39;/project/games/find&#39;,Token,&#123;            &quot;crowd&quot;: `$&#123;crowdList[state.list[2]]&#125;`,            &#39;time&#39;:`$&#123;timeList[state.list[1]]&#125;`,            &quot;venue&quot;: `$&#123;placeList[state.list[0]]&#125;`,       &#125;)</code></pre><p>则会得到：<code>Promise&lt;pending...&gt;</code>这个结果</p><h2 id="4、问题"><a href="#4、问题" class="headerlink" title="4、问题"></a>4、问题</h2><p>在下面的程序中，调用.then函数可以正常对dataList赋值，但是如果使用Taro.request自带的success回调则不能正常赋值</p><pre><code class="hljs"> dataList = await Taro.request(&#123;          url: &#39;http://116.204.121.9:65000/api/v1&#39;+url,           method: method,          header: &#123;            &#39;Authorization&#39;: Token?Token:&#39;&#39;,            &#39;Content-Type&#39;: &#39;application/json&#39;,            &#39;Accept&#39;: &#39;*/*&#39;,          &#125;,          data: JSON.stringify(body),                  &#125;).then((res) =&gt; &#123;          if(url === &#39;/login&#39; ) &#123;            if(res.statusCode !== 401) &#123;              Taro.setStorageSync(&#39;token&#39;,res.data.data.Token)              dataList = [res.data.data]            &#125; else &#123;              register()            &#125;               &#125; else &#123;            // console.log(&#39;iiiiiiiiiiiiiiiiiiiiiii&#39;,res);            res.data.data.qq?Taro.setStorageSync(&#39;nickName&#39;,res.data.data.qq):&#39;&#39;            res.data.data.qq?Taro.setStorageSync(&#39;url&#39;,res.data.data.photo):&quot;&quot;            // res.data.data.qq?Taro.setStorageSync(&#39;uid&#39;,res.data.data.uid):&#39;&#39;            return res           &#125;                  &#125;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js基础</tag>
      
      <tag>taro小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useReducer 和 useContext</title>
    <link href="/2023/03/03/useReducer/"/>
    <url>/2023/03/03/useReducer/</url>
    
    <content type="html"><![CDATA[<h1 id="useReducer-和-useContext"><a href="#useReducer-和-useContext" class="headerlink" title="useReducer 和 useContext"></a>useReducer 和 useContext</h1><blockquote><p>useReducer 是一个 React Hook，它允许你向组件添加一个化简器。</p><p>useContext 是一个 React Hook，它允许你从组件中读取和订阅上下文。</p></blockquote><h2 id="useContext使用方法"><a href="#useContext使用方法" class="headerlink" title="useContext使用方法"></a>useContext使用方法</h2><p>1、在全局createContext</p><p><code>const globalContext = createContext()</code></p><p>2、在需要传递参数的组件外面套一层Context.Provider，并把要传递的参数写在value中</p><pre><code class="hljs">&lt;globalContext.Provider value=&quot;dark&quot;&gt;  &lt;Form /&gt;&lt;/globalContext.Provider&gt;</code></pre><p>3、在需要接受参数的组件中使用useContext</p><pre><code class="hljs">function Form() &#123;  return (    &lt;Panel title=&quot;Welcome&quot;&gt;      &lt;Button&gt;Sign up&lt;/Button&gt;      &lt;Button&gt;Log in&lt;/Button&gt;    &lt;/Panel&gt;  );&#125;function Panel(&#123; title, children &#125;) &#123;  const theme = useContext(ThemeContext);  const className = &#39;panel-&#39; + theme;  return (    &lt;section className=&#123;className&#125;&gt;      &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;      &#123;children&#125;    &lt;/section&gt;  )&#125;</code></pre><h2 id="Redux原理"><a href="#Redux原理" class="headerlink" title="Redux原理"></a>Redux原理</h2><p><img src="https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=redux%E5%8E%9F%E7%90%86&step_word=&hs=0&pn=2&spn=0&di=7189064908862914561&pi=0&rn=1&tn=baiduimagedetail&is=0,0&istype=0&ie=utf-8&oe=utf-8&in=&cl=2&lm=-1&st=undefined&cs=3280256628,1358513824&os=3135708404,212282761&simid=3280256628,1358513824&adpicid=0&lpn=0&ln=307&fr=&fmq=1677853227002_R&fm=&ic=undefined&s=undefined&hd=undefined&latest=undefined&copyright=undefined&se=&sme=&tab=0&width=undefined&height=undefined&face=undefined&ist=&jit=&cg=&bdtype=0&oriquery=&objurl=https://img-blog.csdnimg.cn/fc5388fecf8449d49e771fac967579a8.gif&fromurl=ippr_z2C$qAzdH3FAzdH3Fks52_z&e3Bvf1g_z&e3BgjpAzdH3F4a_mabdnmb9AzdH3Fw6ptvsjAzdH3F1jpwtsfAzdH3F8d8c9c09a&gsm=1e&rpstart=0&rpnum=0&islist=&querylist=&nojc=undefined&dyTabStr=MCwzLDQsMSwyLDUsNiw3LDgsOQ==" alt="这是图片" title="photo"></p><p>ui操作 -&gt; dispatch方法 -&gt; 进入store,调用对应reducer改变state</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>1、在外部定义reducer方法，以处理dispatch传递的action</p><pre><code class="hljs">const reducer = (prevState,action) =&gt; &#123;  let newState = &#123;...prevState&#125;  newstate.list[action.type-1] = action.value;  return newstate&#125;</code></pre><p>2、在函数内部定义state和dispatch方法</p><p> <code>const [state, dispatch] = useReducer(reducer, initialState)</code></p><p>3、在需要使用或改变该状态的地方使用useContext，将state和dispatch方法传入</p><pre><code class="hljs">&lt;globalContext.Provider value=&#123;&#123;       state,       dispatch &#125;&#125;&gt;    &lt;View id=&#39;filt&#39; &gt;        &lt;Gameselect text = &#39;场地&#39; &gt;&lt;Placechild type=&#39;1&#39; ItemText = &#123;placeList&#125; func=&#123;Info&#125;&gt;&lt;/Placechild&gt;&lt;/Gameselect&gt;        &lt;Gameselect text = &#39;时间&#39;  &gt;&lt;Placechild type=&#39;2&#39; ItemText = &#123;timeList&#125; func=&#123;Info&#125;&gt;&lt;/Placechild&gt;&lt;/Gameselect&gt;        &lt;Gameselect text = &#39;人数&#39; &gt;&lt;Placechild  type = &#39;3&#39; ItemText = &#123;crowdList&#125; func=&#123;Info&#125;&gt;&lt;/Placechild&gt;&lt;/Gameselect&gt;                    &lt;/View&gt;           &lt;/globalContext.Provider&gt;</code></pre><p>4、在组件中调用dispatch方法，改变state</p><pre><code class="hljs">export function Placechild(props) &#123;  const &#123;dispatch&#125; = useContext(globalContext)  const &#123;state&#125; = useContext(globalContext)  // console.log(state);  const&#123;    type,    ItemText,    func  &#125; = props    return (    &lt;View&gt;      &#123;ItemText.map((text,index)=&gt;&#123;        return (          &lt;View onTap=&#123;async ()=&gt;&#123;            await dispatch(&#123;              type:`$&#123;type&#125;`,              value:`$&#123;index&#125;`            &#125;)            func(type-1,index)            &#125;&#125;&gt;            &lt;GameSelctItem type = &#123;type&#125; text = &#123;text&#125;  style = &#123;state.list[props.type-1]&#125; index =&#123;index&#125;/&gt;          &lt;/View&gt;        )      &#125;)&#125;          &lt;/View&gt;  )&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>react基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>react基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript编码原则</title>
    <link href="/2023/01/07/howToWriteJS/"/>
    <url>/2023/01/07/howToWriteJS/</url>
    
    <content type="html"><![CDATA[<h1 id="Javascript编码原则"><a href="#Javascript编码原则" class="headerlink" title="Javascript编码原则"></a>Javascript编码原则</h1><h2 id="一、-各司其职"><a href="#一、-各司其职" class="headerlink" title="一、 各司其职"></a>一、 各司其职</h2><p>结构行为分离，js中尽量少写样式修改，尽量只保留基本逻辑代码，用class操作css，这样代码更为简洁，可读性更强。简单逻辑甚至可以只使用css完成。总之应该避免js直接操作样式</p><h2 id="二、-组件封装"><a href="#二、-组件封装" class="headerlink" title="二、 组件封装"></a>二、 组件封装</h2><p>注意组件复用性、拓展性，避免重复“造轮子”。<br>以轮播图为例，首先写好html结构</p><pre><code class="hljs">&lt;template&gt;      &lt;div class=&#39;xtx-carousel&#39;&gt;        &lt;ul class=&quot;carousel-body&quot;&gt;          &lt;!-- 所有图片列表 --&gt;          &lt;li class=&quot;carousel-item fade&quot;&gt;            &lt;RouterLink to=&quot;/&quot;&gt;              &lt;img src=&quot;&quot; alt=&quot;&quot;&gt;            &lt;/RouterLink&gt;          &lt;/li&gt;        &lt;/ul&gt;        &lt;!-- 左箭头 --&gt;        &lt;a href=&quot;javascript:;&quot; class=&quot;carousel-btn prev&quot;&gt;&lt;i class=&quot;iconfont icon-angle-left&quot;&gt;&lt;/i&gt;&lt;/a&gt;        &lt;!-- 右箭头 --&gt;        &lt;a href=&quot;javascript:;&quot; class=&quot;carousel-btn next&quot;&gt;&lt;i class=&quot;iconfont icon-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt;        &lt;!-- 计数器 --&gt;        &lt;div class=&quot;carousel-indicator&quot;&gt;          &lt;span v-for=&quot;i in 5&quot; :key=&quot;i&quot;&gt;&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;&lt;/template&gt;</code></pre><p>之后写好js框架，决定行为设计</p><pre><code class="hljs">import &#123; ref &#125; from &#39;vue&#39;export default &#123;  name: &#39;swiper&#39;,  props: &#123;    sliders: &#123;      type: Array,      default: () =&gt; []    &#125;  &#125;,  setup () &#123;    // 记录图片的下标值变量    const index = ref(0)     return &#123; index &#125;  &#125;&#125;</code></pre><p>最后使用css实现展示效果</p><p>封装完成后的组件引用时只用写<code>&lt;Swiper&gt;&lt;Swiper/&gt;</code>,在react、vue中还可以进一步将轮播内容封装起来，使用<code>props.children</code>动态更改轮播内容，进一步增强复用性</p><h2 id="三、-过程抽象"><a href="#三、-过程抽象" class="headerlink" title="三、 过程抽象"></a>三、 过程抽象</h2><p>可以将复杂的过程封装成函数，形成闭包直接调用，不需要在意过程细节，类似于api的调用，可以选择命令式、声明式的编程方式</p><h2 id="四、-代码质量优化"><a href="#四、-代码质量优化" class="headerlink" title="四、 代码质量优化"></a>四、 代码质量优化</h2><h3 id="1、减少全局变量使用"><a href="#1、减少全局变量使用" class="headerlink" title="1、减少全局变量使用"></a>1、减少全局变量使用</h3><p>每个 JavaScript 执行环境都有一个全局对象 例如： 浏览器窗口的 window 对象, 可在函数外部使用 this 关键字进行访问。JavaScript 中在函数外部创建的每一个变量都是全局变量， 可以在整个执行环境中的各个地方使用 例如：下面的定义 globalVar 变量可以在代码块中的各个部分访问， 即使在不同的 script 标签内。<br>而在 function foo 中定义的 localVar 变量， 就只局限于 foo 函数的作用域内可以访问</p><pre><code class="hljs">&lt;script&gt;    var globalVar = &#39;feifeiyu&#39;    function foo() &#123;        var localVar = &#39;feiyu&#39;        console.log(&#39;global foo:&#39;, globalVar) // =&gt; feifeiyu        console.log(&#39;local foo:&#39;, localVar)  // =&gt; feiyu    &#125;    console.log(&#39;global:&#39;, globalVar)  // =&gt; feifeiyu    console.log(&#39;global window1:&#39;, window.globalVar) // =&gt; feifeiyu    console.log(&#39;global window2:&#39;, window[&#39;globalVar&#39;])  // =&gt; feifeiyu    // console.log(&#39;local:&#39;, localVar) // error&lt;/script&gt;&lt;script&gt;    console.log(&#39;global2:&#39;, globalVar)&lt;/script&gt;</code></pre><p>由上例中想到， 如果一个页面中如果有两块独立的代码中， 包含有相同名称的变量， 但却有着不同的作用时， 会引起程序运行出错。在其他的程序中为了解决这个问题引入了命名空间的概念， 例如： C++ 有个专门的关键字 namespace 来声明命名空间。在 JavaScript 中没这样的关键字来控制命名空间， 因此， 为了避免变量在全局作用域中冲突， 在同一个页面中应该尽可能地减少全局作用域中的使用。如何减少全局变量数量， 大致的解决方案有两种， 一种是人为去构造 JavaScript 的命名空间， 这种模式相对复杂不常用; 另一种是采用自执行即使函数(self-execting immediate funtionsl)来实现。</p><h3 id="2、-关注变量提升"><a href="#2、-关注变量提升" class="headerlink" title="2、 关注变量提升"></a>2、 关注变量提升</h3><p>变量提升是 JavaScript 代码编写中容易忽略的一个点。JavaScript 允许在函数任意地方声明多个变量， 无论在哪里声明， 效果都等同于在函数顶部声明， 这就是变量提升（hoisting)。当先使用变量后定义变量，将会导致逻辑上的错误。例如：</p><pre><code class="hljs">(function() &#123;    var myName = &#39;feifeiyu&#39;    function func() &#123;        console.log(&#39;myName 1:&#39;, myName)  // =&gt; myName 1: undefined        var myName = &#39;feiyu&#39;        console.log(&#39;myName 2:&#39;, myName)  // =&gt; myName 2: feiyu    &#125;&#125;())</code></pre><p>上述代码执行后， 安装开发者的意图， 第一个console 输出的应该是 myName 1: feifeiyu, 第二个 console 输出的应该是 feiyu, 然而意想不到的结果出现了， 第一个 console 输出的是 undefined。 导致这个的元凶是 JavaScript 的变量提升， JavaScript 解释器在执行时， 函数中的 myName 会提升到函数 func 最顶部去定义， 本质上述代码是按如下逻辑去执行的：</p><pre><code class="hljs">(function() &#123;    var myName = &#39;feifeiyu&#39;    function func() &#123;        var myName  //此时 myName 是 undefined        console.log(&#39;myName 1:&#39;, myName)  // =&gt; myName 1: undefined        myName = &#39;feiyu&#39;        console.log(&#39;myName 2:&#39;, myName)  // =&gt; myName 2: feiyu    &#125;&#125;())</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重定义this的方法</title>
    <link href="/2022/11/27/this/"/>
    <url>/2022/11/27/this/</url>
    
    <content type="html"><![CDATA[<h1 id="重定义this的方法"><a href="#重定义this的方法" class="headerlink" title="重定义this的方法"></a>重定义this的方法</h1><pre><code class="hljs">var name=&#39;刘恺卿&#39;,age=&#39;19&#39;;var obj= &#123;    name=&#39;帅哥&#39;,    objage:this.age,    from:function(fr,to) &#123;        console.log(this.name + &quot;年龄&quot; + this.age + &quot;来自&quot; + fr + &quot;去往&quot; + to);    &#125;&#125;var lao_die= &#123;    name:lao_die,    age:99&#125;</code></pre><p>​<br>​</p><h3 id="call-apply-bind-三个方法第一个参数均为this的指向-但是后面参数有所不同"><a href="#call-apply-bind-三个方法第一个参数均为this的指向-但是后面参数有所不同" class="headerlink" title="call()&#x2F;apply()&#x2F;bind()三个方法第一个参数均为this的指向,但是后面参数有所不同"></a>call()&#x2F;apply()&#x2F;bind()三个方法第一个参数均为this的指向,但是后面参数有所不同</h3><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><pre><code class="hljs">obj.from.call(lao_die,&#39;hang_zhou&#39;,&#39;wu_han&#39;);</code></pre><h3 id="call-的后面参数直接放入"><a href="#call-的后面参数直接放入" class="headerlink" title="call()的后面参数直接放入"></a>call()的后面参数直接放入</h3><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><pre><code class="hljs">obj.from.apply(lao_die,[&#39;hang_zhou&#39;,&#39;wu_han&#39;]);</code></pre><h3 id="apply-的后面参数要套在中括号内"><a href="#apply-的后面参数要套在中括号内" class="headerlink" title="apply()的后面参数要套在中括号内"></a>apply()的后面参数要套在中括号内</h3><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><pre><code class="hljs">obj.from.bind(lao_die,&#39;hang_zhou&#39;,&#39;wu_han&#39;)();</code></pre><h3 id="bind-比较特殊，它返回一个函数，所以要在末尾加上-自调用才能运行"><a href="#bind-比较特殊，它返回一个函数，所以要在末尾加上-自调用才能运行" class="headerlink" title="bind()比较特殊，它返回一个函数，所以要在末尾加上()自调用才能运行"></a>bind()比较特殊，它返回一个函数，所以要在末尾加上()自调用才能运行</h3>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>箭头函数与普通函数</title>
    <link href="/2022/11/07/arrowFunction/"/>
    <url>/2022/11/07/arrowFunction/</url>
    
    <content type="html"><![CDATA[<h2 id="一、箭头函数与普通函数"><a href="#一、箭头函数与普通函数" class="headerlink" title="一、箭头函数与普通函数"></a>一、箭头函数与普通函数</h2><blockquote><p>箭头函数表达式语法比函数表达式更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>等，也不能用作构造函数。箭头函数表达式更适用于那些本来需要<code>匿名函数</code>的地方。 </p></blockquote><h3 id="普通函数，函数的名字叫shuai-ge"><a href="#普通函数，函数的名字叫shuai-ge" class="headerlink" title="普通函数，函数的名字叫shuai_ge"></a>普通函数，函数的名字叫shuai_ge</h3><pre><code class="hljs">var x=&quot;shaui_ge&quot;function shuai_ge()&#123;    console.log(`$&#123;x=&quot;刘恺卿&quot;&#125;`);&#125;</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code class="hljs"> var x=&quot;shuai_ge&quot;; (() =&gt; x=&quot;刘恺卿&quot;)() console.log(x);</code></pre><h2 id="二、箭头函数与匿名函数"><a href="#二、箭头函数与匿名函数" class="headerlink" title="二、箭头函数与匿名函数"></a>二、箭头函数与匿名函数</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><pre><code class="hljs">function ()&#123;console.log(&quot;刘恺卿&quot;);&#125;</code></pre><h3 id="运行匿名函数-单独运行时结尾加上括号"><a href="#运行匿名函数-单独运行时结尾加上括号" class="headerlink" title="运行匿名函数(单独运行时结尾加上括号)"></a>运行匿名函数(单独运行时结尾加上括号)</h3><pre><code class="hljs">(function ()&#123;    //此时会输出刘恺卿    console.log(&quot;刘恺卿&quot;);&#125;)(//传入的值)</code></pre><h3 id="箭头函数相当于匿名函数，并且简化了函数定义"><a href="#箭头函数相当于匿名函数，并且简化了函数定义" class="headerlink" title="箭头函数相当于匿名函数，并且简化了函数定义"></a>箭头函数相当于匿名函数，并且简化了函数定义</h3><blockquote><p>但实际上，箭头函数和匿名函数有个明显的区别：匿名函数的this指向执行时上下文（由于执行时的<code>全局性</code>，this一般指向window）；箭头函数内部的this与父级元素this绑定</p></blockquote><h2 id="三、this"><a href="#三、this" class="headerlink" title="三、this"></a>三、this</h2><blockquote><h3 id="1：this永远指向一个对象；"><a href="#1：this永远指向一个对象；" class="headerlink" title="1：this永远指向一个对象；"></a>1：this永远指向一个对象；</h3></blockquote><blockquote><h3 id="2：this的指向完全取决于函数调用的位置；"><a href="#2：this的指向完全取决于函数调用的位置；" class="headerlink" title="2：this的指向完全取决于函数调用的位置；"></a>2：this的指向完全取决于函数调用的位置；</h3></blockquote><blockquote><h3 id="3：this指向可以动态改变，只有在运行时才知道this指向"><a href="#3：this指向可以动态改变，只有在运行时才知道this指向" class="headerlink" title="3：this指向可以动态改变，只有在运行时才知道this指向"></a>3：this指向可以动态改变，只有在运行时才知道this指向</h3></blockquote><p>eg1.</p><pre><code class="hljs">var A = &#123;    name: &#39;张三&#39;,    f: function () &#123;        console.log(&#39;姓名：&#39; + this.name);    &#125;&#125;;​var B = &#123;    name: &#39;李四&#39;&#125;;​B.f = A.f;B.f()   // 姓名：李四A.f()   // 姓名：张三</code></pre><p>eg2.</p><pre><code class="hljs">function foo() &#123;    console.log(this.a);&#125;var obj2 = &#123;    a: 2,    fn: foo&#125;;var obj1 = &#123;    a: 1,    o1: obj2&#125;;obj1.o1.fn(); // 2</code></pre><h3 id="this的事件绑定"><a href="#this的事件绑定" class="headerlink" title="this的事件绑定"></a>this的事件绑定</h3><pre><code class="hljs">&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;clickFun()&quot;&gt;&lt;script&gt;    function clickFun()&#123;        this // 此函数的运行环境在全局window对象下，因此this指向window;    &#125;&lt;/script&gt;​&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;this&quot;&gt;&lt;!-- 运行环境在节点对象中，因此this指向本节点对象 --&gt;</code></pre><blockquote><p>当事件触发时，属性值就会作为JS代码被执行，当前运行环境下没有clickFun函数，因此浏览器就需要跳出当前运行环境，在整个环境中寻找一个叫clickFun的函数并执行这个函数，所以函数内部的this就指向了全局对象window；如果不是一个函数调用，直接在当前节点对象环境下使用this，那么显然this就会指向当前节点对象；</p></blockquote><h2 id="四、匿名函数和箭头函数的this指向区别"><a href="#四、匿名函数和箭头函数的this指向区别" class="headerlink" title="四、匿名函数和箭头函数的this指向区别"></a>四、匿名函数和箭头函数的this指向区别</h2><h3 id="eg1-匿名函数的全局性"><a href="#eg1-匿名函数的全局性" class="headerlink" title="eg1.匿名函数的全局性"></a>eg1.匿名函数的全局性</h3><pre><code class="hljs">function fun() &#123;    (function () &#123;        console.log(this);    &#125;)()&#125;fun();</code></pre><h3 id="eg2-匿名函数在obj中this指向对象"><a href="#eg2-匿名函数在obj中this指向对象" class="headerlink" title="eg2.匿名函数在obj中this指向对象"></a>eg2.匿名函数在obj中this指向对象</h3><pre><code class="hljs">var name = &#39;window&#39;var person = &#123;    name :&#39;Alan&#39;,    sayOne:function () &#123;            console.log(this.name)    &#125;,    sayTwo:function () &#123;        return function () &#123;            console.log(this.name)        &#125;    &#125;&#125;person.sayOne()person.sayTwo()()</code></pre><blockquote></blockquote><ul><li>函数内部的this指向调用者</li><li>sayOne调用者是person对象，所以this指向person；</li></ul><ul><li>sayTwo的调用者虽然也是person对象，但是区别在于这次调用并没有打出this而是在全局返回了一个匿名函数<br>,而这个匿名函数不是作为某个对象的方法来调用执行，是在全局执行，最后的执行者就是window</li></ul><h3 id="eg3-匿名函数性质运用"><a href="#eg3-匿名函数性质运用" class="headerlink" title="eg3.匿名函数性质运用"></a>eg3.匿名函数性质运用</h3><pre><code class="hljs">var name = &#39;window&#39;var person = &#123;    name :&#39;one&#39;,    wrap: function()&#123;        (function ()&#123;            console.log(this.name)// window        &#125;)()        function sum()&#123;            console.log(this.name)// window        &#125;        sum()，        good: function sum2() &#123;            console.log(this.name)        &#125;    &#125;&#125;person.wrap()person.good()</code></pre><blockquote><ul><li>function是调用自身的匿名函数 ，this指向全局，sum被function调用，sum的this指向function，也是全局</li><li>good被person直接调用，this指向person</li></ul></blockquote><h3 id="eg4-箭头函数this"><a href="#eg4-箭头函数this" class="headerlink" title="eg4.箭头函数this"></a>eg4.箭头函数this</h3><pre><code class="hljs">var name=&#39;window&#39;;var obj = &#123;    name:&#39;obj&#39;,    nameprintf:()=&gt;&#123;        console.log(this.name)    &#125;&#125;obj.nameprintf()</code></pre><blockquote><ul><li>nameprintf是箭头函数，this与父级元素obj的this绑定，而obj的this指向window，因此nameprintf的this也指向window</li></ul></blockquote><h3 id="eg5-匿名函数和箭头函数结合"><a href="#eg5-匿名函数和箭头函数结合" class="headerlink" title="eg5.匿名函数和箭头函数结合"></a>eg5.匿名函数和箭头函数结合</h3><pre><code class="hljs">var name=&quot;window&quot;var obj=&#123;    num:4,    name:obj,    fn:function()&#123;          console.log(this.name);         (() =&gt; &#123;            console.log(this.name);        &#125;)();    &#125;&#125;obj.fn(); var w = obj.fn;w(); var obj1 = &#123;name:&#39;obj1&#39;, fn:obj.fn&#125;obj1.fn(); </code></pre><blockquote><ul><li>箭头函数中的this包含在匿名函数中，匿名函数被function调用，因此箭头函数的this指向与function中的相同</li><li>obj调用fn，因此fn的this指向obj，输出为obj</li><li>w()是新创建的定义在window下的变量，this指向window，输出为window</li><li>obj1调用obj中的fn函数，因此调用对象为obj1，this指向obj1</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
